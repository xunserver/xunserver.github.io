import{_ as a,c as t,o as n,ah as o}from"./chunks/framework.BurO9VyR.js";const h=JSON.parse('{"title":"Vue查漏补缺（四）渲染流程中的细节","description":null,"frontmatter":{"title":"Vue查漏补缺（四）渲染流程中的细节","comments":true,"hide":false,"abbrlink":"d0fc54e0","date":"2022-03-24T08:03:10.000Z","updated":"2022-03-24T08:03:10.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/Vue查漏补缺（七）patch中看kepp-alive.md","filePath":"posts/Vue查漏补缺（七）patch中看kepp-alive.md"}'),d={name:"posts/Vue查漏补缺（七）patch中看kepp-alive.md"};function r(p,e,i,l,s,u){return n(),t("div",null,e[0]||(e[0]=[o('<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>之前的基础了解了vue的流程，全流程了解下。</p><h3 id="首次渲染" tabindex="-1">首次渲染 <a class="header-anchor" href="#首次渲染" aria-label="Permalink to &quot;首次渲染&quot;">​</a></h3><p>从根元素开始，new Vue({ el: &#39;xxx&#39; }); Vue的构造函数中调用_init函数（minxin，extend初始化，state，$event,lifeCircle），到检查是否存在el，存在就执行render函数，开始走渲染的流程。根元素显然有el，走render流程，render后返回一个vnode节点，如果是组件vnode，有data(hook.init)和componentOptions(构造器（构造器中又包含组件申明时一系列静态的配置）事件和真实的props) 属性。render返回vnode后，执行update流程</p><h3 id="update流程" tabindex="-1">update流程 <a class="header-anchor" href="#update流程" aria-label="Permalink to &quot;update流程&quot;">​</a></h3><p>调用patch将vnode转换成dom，如果vnode是元素节点，将vnode示例成dom，同时渲染处理children属性，挂载到当前组件的el上。如果vnode是一个组件vnode，调用createComponent(), 执行data.hook.init, init中createComponentForVnode 将执行new componentOptions.ctor()，又走到了_init 流程。将组件的vnode实例化后，因为el不存在。手动执行$mount语句，又会继续执行该组件vnode的render流程。</p><h3 id="当组件update时" tabindex="-1">当组件update时 <a class="header-anchor" href="#当组件update时" aria-label="Permalink to &quot;当组件update时&quot;">​</a></h3><p>经过一系列的通知，最后执行还是会走到_update(render()), 又得到一个vnode，因为vnode相同，所以走diff的流程。diff 流程中检查到是组件，又是走prepatch流程</p>',8)]))}const _=a(d,[["render",r]]);export{h as __pageData,_ as default};
