import{_ as a,c as s,o as l,ah as e}from"./chunks/framework.BurO9VyR.js";const c=JSON.parse('{"title":"面试基础篇（一）","description":null,"frontmatter":{"title":"面试基础篇（一）","comments":true,"abbrlink":"135d9d92","date":"2019-09-24T13:58:14.000Z","updated":"2019-09-24T13:58:14.000Z","tags":["html","css","javascript"],"categories":["面试"],"description":null},"headers":[],"relativePath":"posts/面试基础篇（一）.md","filePath":"posts/面试基础篇（一）.md"}'),t={name:"posts/面试基础篇（一）.md"};function n(h,i,r,o,p,d){return l(),s("div",null,i[0]||(i[0]=[e(`<h2 id="前端-seo-注意情况" tabindex="-1">前端 SEO 注意情况 <a class="header-anchor" href="#前端-seo-注意情况" aria-label="Permalink to &quot;前端 SEO 注意情况&quot;">​</a></h2><ol><li><code>title</code> &gt; <code>description</code> &gt; <code>keywords</code></li><li>搜索引擎从上到下，重要内容放前面</li><li>内容不用 js 动态输出</li><li>搜索引擎会跳过 frame</li><li>非装饰图片使用 alt</li></ol><h2 id="post-和-put-区别" tabindex="-1">post 和 put 区别 <a class="header-anchor" href="#post-和-put-区别" aria-label="Permalink to &quot;post 和 put 区别&quot;">​</a></h2><p>put 是幂等的，多次操作不会新增数据条数，可以理解为修改某条数据。post 是非幂等的，多次操作会增加多条数据，理解为新增接口。建议管理系统不做区分， 都用 post。</p><h2 id="优化的一些点" tabindex="-1">优化的一些点 <a class="header-anchor" href="#优化的一些点" aria-label="Permalink to &quot;优化的一些点&quot;">​</a></h2><ol><li>静态资源分布到多域名下</li><li>控制资源大小，小文件合并。</li><li>css 和 js 单独放置为文件</li><li>压缩图片，减少位深。</li></ol><h2 id="iframe-问题" tabindex="-1">iframe 问题 <a class="header-anchor" href="#iframe-问题" aria-label="Permalink to &quot;iframe 问题&quot;">​</a></h2><ol><li>阻塞主页面 onload 事件，通过 动态添加 src 或更优的 createElmenet 的形式来添加</li><li>iframe 和主页面同域共享连接池，会影响主页面资源加载</li></ol><h2 id="采用多个域名存储资源的原因" tabindex="-1">采用多个域名存储资源的原因 <a class="header-anchor" href="#采用多个域名存储资源的原因" aria-label="Permalink to &quot;采用多个域名存储资源的原因&quot;">​</a></h2><ol><li>突破浏览器并发限制</li><li>节约 cookie 带宽</li><li>节约主域名连接数</li></ol><h2 id="电商图片处理" tabindex="-1">电商图片处理 <a class="header-anchor" href="#电商图片处理" aria-label="Permalink to &quot;电商图片处理&quot;">​</a></h2><ol><li>小图标 雪碧图</li><li>加载缩略图</li><li>懒加载，滚动位置再加载</li></ol><h2 id="bfc" tabindex="-1">BFC <a class="header-anchor" href="#bfc" aria-label="Permalink to &quot;BFC&quot;">​</a></h2><ol><li>overflow 不为 visible;</li><li>position: absolute || fixed;</li><li>display: inline-block || table-cell || flex</li><li>float 不为 none</li><li>html 元素</li></ol><h2 id="清除浮动" tabindex="-1">清除浮动 <a class="header-anchor" href="#清除浮动" aria-label="Permalink to &quot;清除浮动&quot;">​</a></h2><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  zoom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfloat:after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  visibility</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hidden</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="css-优先级" tabindex="-1">css 优先级 <a class="header-anchor" href="#css-优先级" aria-label="Permalink to &quot;css 优先级&quot;">​</a></h2><p>!important &gt; 内联 &gt; id &gt; class &gt; tag</p><h2 id="消除-display-inline-block-间隙" tabindex="-1">消除 display: inline-block 间隙 <a class="header-anchor" href="#消除-display-inline-block-间隙" aria-label="Permalink to &quot;消除 display: inline-block 间隙&quot;">​</a></h2><ol><li>父元素 font-size: 0;</li><li>父元素 word-spacing: 0; // 单词间隙</li><li>删除空格</li><li>letter-spacing: 0 // 字母间隙</li></ol><h2 id="动画间隔时间" tabindex="-1">动画间隔时间 <a class="header-anchor" href="#动画间隔时间" aria-label="Permalink to &quot;动画间隔时间&quot;">​</a></h2><p>保证 30fps 1000/30 = 33.333ms</p><h2 id="bind-注意" tabindex="-1">bind 注意 <a class="header-anchor" href="#bind-注意" aria-label="Permalink to &quot;bind 注意&quot;">​</a></h2><p>bind 是强绑定的， 绑定后不能更换 this</p><h2 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h2><ol><li>强制缓存 =&gt; 根据 Expired(http1.0)(通过服务端返回有效时间) ， 或者 Cache-control 来控制， 一般使用 max-age： 1h。</li></ol><p>强制缓存是直接从浏览器获得请求，一个是 from memory cache(页面刷新的缓存)，一个是 from disk cache（页面关闭再打开）<br> js 和图片等文件 当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache</p><ol start="2"><li>协商缓存 =&gt; 强制缓存失效时， 就会启用协商缓存</li></ol><p>last-modified(第一次响应) =&gt; if-modified-since（浏览器再次请求） =&gt; 服务端和本地文件进行对比</p><p>Etag 和 if-none-match 返回 etat =&gt; if-none-match =&gt; 对比 etag</p><h2 id="viewport-的值有哪些" tabindex="-1">viewport 的值有哪些 <a class="header-anchor" href="#viewport-的值有哪些" aria-label="Permalink to &quot;viewport 的值有哪些&quot;">​</a></h2><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0 user-scaleable=yes&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><h2 id="如何判断一个单链表是否有环" tabindex="-1">如何判断一个单链表是否有环 <a class="header-anchor" href="#如何判断一个单链表是否有环" aria-label="Permalink to &quot;如何判断一个单链表是否有环&quot;">​</a></h2><p>使用快慢指针, 快指针追上慢指针表示有环，快指针到末尾还未追上， 表示没环。</p><h2 id="如何判断环的长度和环的起点" tabindex="-1">如何判断环的长度和环的起点 <a class="header-anchor" href="#如何判断环的长度和环的起点" aria-label="Permalink to &quot;如何判断环的长度和环的起点&quot;">​</a></h2><p>设置一个指针从 head 开始， 一个从相遇点开始，知道两个指针重合， 就是起点<br> 环的长度，可以通过快指针和慢指针下次相遇的，操作步数</p><h2 id="两个无环链表-判断是否相交和相交节点是多少" tabindex="-1">两个无环链表，判断是否相交和相交节点是多少 <a class="header-anchor" href="#两个无环链表-判断是否相交和相交节点是多少" aria-label="Permalink to &quot;两个无环链表，判断是否相交和相交节点是多少&quot;">​</a></h2><p>将任意一个链表守卫相接，然后从另一个链表开始， 如果是有环的，证明必然有环</p><h2 id="xss-和-csrf" tabindex="-1">xss 和 csrf <a class="header-anchor" href="#xss-和-csrf" aria-label="Permalink to &quot;xss 和 csrf&quot;">​</a></h2><p>xss 跨站脚本攻击，网站内容被插入了 js 代码。包括在 url 里面被植入 例如 javascript: alert()这种代码。</p><ol><li>转义 csrf 跨站请求伪造， 直接在 B 网站上发送请求 A 网站的请求。</li><li>禁止跨站访问，根据 referer 来判断。</li><li>点击劫持 嵌套 iframe, 服务端配置禁止被引用。</li></ol><h2 id="深拷贝" tabindex="-1">深拷贝 <a class="header-anchor" href="#深拷贝" aria-label="Permalink to &quot;深拷贝&quot;">​</a></h2><ol><li>递归拷贝引用类型</li><li>循环引用的情况，每次检测是否某个对象的字段是本身对象或祖先对象</li><li>平级引用，使用 weakMap 检测有个属性是否在 weakMap 存在</li></ol>`,43)]))}const E=a(t,[["render",n]]);export{c as __pageData,E as default};
