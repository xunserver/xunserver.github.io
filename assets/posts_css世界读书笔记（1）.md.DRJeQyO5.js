import{_ as i,c as t,o as s,ah as l}from"./chunks/framework.BurO9VyR.js";const k=JSON.parse('{"title":"css世界读书笔记（1）","description":null,"frontmatter":{"title":"css世界读书笔记（1）","comments":true,"abbrlink":"b78f1e6b","date":"2019-04-17T15:39:03.000Z","updated":"2019-04-17T15:39:03.000Z","tags":["css","css元素尺寸","css世界"],"categories":["读书笔记"],"description":null},"headers":[],"relativePath":"posts/css世界读书笔记（1）.md","filePath":"posts/css世界读书笔记（1）.md"}'),e={name:"posts/css世界读书笔记（1）.md"};function n(o,a,r,h,p,d){return s(),t("div",null,a[0]||(a[0]=[l(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>上次去整了本张鑫旭大佬编的《CSS世界》，一直没有时间研读，仅记录一些之前未接触的内容。</p><h2 id="块级元素" tabindex="-1">块级元素 <a class="header-anchor" href="#块级元素" aria-label="Permalink to &quot;块级元素&quot;">​</a></h2><p>粗略理解为 <code>display</code> 值为 <code>table</code>，<code>block</code>，<code>list-item</code>等值元素。具有独占一行水平流的功能，可以使用<code>clear</code> 属性。</p><h2 id="list-item-出现项目符号理解" tabindex="-1">list-item 出现项目符号理解 <a class="header-anchor" href="#list-item-出现项目符号理解" aria-label="Permalink to &quot;list-item 出现项目符号理解&quot;">​</a></h2><p>元素可以理解为多个盒子构成，外在盒子，容器盒子（内在盒子），标记盒子（这个是<code>list-item</code>独有的盒子）。可以按照每种盒子具有自身的display来理解行为。<code>block =&gt; block-flow</code> <code>inline-block =&gt; inline-block</code></p><h2 id="理解width-auto" tabindex="-1">理解width：auto <a class="header-anchor" href="#理解width-auto" aria-label="Permalink to &quot;理解width：auto&quot;">​</a></h2><ol><li><strong>充分利用可用空间</strong>：表现在div，p等元素上，会尽可能扩伸。</li><li><strong>收缩与包裹</strong>：表现在table，inline-block上面，收缩到合适。有种根据内容来设置min-width的感觉。</li><li><strong>收缩到最小</strong>：table-layout：auto 会出现</li><li><strong>超出限制</strong>：长连续的英文和数字会出现。还有 white-space:nowrap设置后的内联元素</li></ol><h2 id="元素的宽度是由什么决定的" tabindex="-1">元素的宽度是由什么决定的？ <a class="header-anchor" href="#元素的宽度是由什么决定的" aria-label="Permalink to &quot;元素的宽度是由什么决定的？&quot;">​</a></h2><h3 id="外部尺寸" tabindex="-1">外部尺寸 <a class="header-anchor" href="#外部尺寸" aria-label="Permalink to &quot;外部尺寸&quot;">​</a></h3><p>指的是元素自身就能决定宽度</p><ol><li>正常流，div，p等元素，总是尽可能扩伸。按照流来理解</li><li>position为absolute，fixed等情况下对边属性都存在时。可以理解为，自身把自身拉开</li><li>显式设置宽度</li></ol><h3 id="内部尺寸" tabindex="-1">内部尺寸 <a class="header-anchor" href="#内部尺寸" aria-label="Permalink to &quot;内部尺寸&quot;">​</a></h3><p>指的是元素的尺寸由内部元素决定</p><ol><li>包裹性的元素：下方inline-block宽度为123宽度</li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;display: inline-block;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;123&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol start="2"><li>首选最小宽度：当父元素宽度设置为0时，子元素表现出最小宽度</li></ol><h2 id="伪元素-after-before-的定义" tabindex="-1">伪元素::after ::before 的定义 <a class="header-anchor" href="#伪元素-after-before-的定义" aria-label="Permalink to &quot;伪元素::after ::before 的定义&quot;">​</a></h2><p>命中元素的最后|最前一个<strong>子元素</strong></p><h2 id="宽度分离" tabindex="-1">宽度分离 <a class="header-anchor" href="#宽度分离" aria-label="Permalink to &quot;宽度分离&quot;">​</a></h2><p>当需要限定宽度时，把宽度定义单独提取出一个元素，box-sizing: border-content功能相同</p><h2 id="宽度100-和-高度100" tabindex="-1">宽度100% 和 高度100% <a class="header-anchor" href="#宽度100-和-高度100" aria-label="Permalink to &quot;宽度100% 和 高度100%&quot;">​</a></h2><p>width：100% _ auto = 无效 height：100% _ auto = 无效。但是宽度这种未定义行为各个厂商把auto视为包含块的最小宽度来处理的。<br> 要明白其中的原因要先了解浏览器渲染的基本原理。首先，先下载文档内容，加载头部的样式资源（如果有的话），然后按照从上而下、自外而内的顺序渲染 DOM 内容。套用本例就是，先渲染父元素，后渲染子元素，是有先后顺序的。因此，当渲染到父元素的时候，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素宽度已经固定，此时的 width:100%就是已经固定好的父元素的宽度。宽度不够怎么办？溢出就好了，overflow 属性就为此而生的</p><h2 id="如何让高度支持100" tabindex="-1">如何让高度支持100% <a class="header-anchor" href="#如何让高度支持100" aria-label="Permalink to &quot;如何让高度支持100%&quot;">​</a></h2><p>position: absolute; 不过注意的是绝对定位的宽高百分比计算是相对于 padding box 的</p><h2 id="超越-important和超越最大" tabindex="-1">超越! important和超越最大 <a class="header-anchor" href="#超越-important和超越最大" aria-label="Permalink to &quot;超越! important和超越最大&quot;">​</a></h2><p>权重优先级 min-_ &gt; max-_ &gt; ! important</p><h2 id="任意高度的展开动画效果" tabindex="-1">任意高度的展开动画效果 <a class="header-anchor" href="#任意高度的展开动画效果" aria-label="Permalink to &quot;任意高度的展开动画效果&quot;">​</a></h2><p>通过过度 max-* 来实现效果</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  max-height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  overflow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hidden</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: max-height </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.element.active</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  max-height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">666</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 一个足够大的最大高度值 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="幽灵空白节点" tabindex="-1">幽灵空白节点 <a class="header-anchor" href="#幽灵空白节点" aria-label="Permalink to &quot;幽灵空白节点&quot;">​</a></h2><p>在 HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。<br><code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code> 高度为span空白节点的高度</p><h2 id="内联元素的定义" tabindex="-1">内联元素的定义 <a class="header-anchor" href="#内联元素的定义" aria-label="Permalink to &quot;内联元素的定义&quot;">​</a></h2><p>可以看做外在盒子是 inline 的元素</p><h2 id="bfc" tabindex="-1">BFC <a class="header-anchor" href="#bfc" aria-label="Permalink to &quot;BFC&quot;">​</a></h2><p>块级格式化上下文</p><ol><li>格式化上下文中的box在垂直方向排列</li><li>上下文中的垂直margin会合并，取最大那个</li><li>上下文中margin-left 会和容器的border-left 紧贴</li><li>上下文中高度会考虑浮动元素</li><li>上下文中的子元素不会和float-box 重叠</li><li>两个不同的BFC不会触发margin 重叠</li></ol><p>盒子默认情况不下触发BFC，通过下面几种方式开启</p><ol><li>html 默认是BFC</li><li>存在float</li><li>overflow 不等于visible</li><li>display: inline-block inline-table table-cell</li><li>position 是absolute或者fixed</li></ol><h2 id="字体大小" tabindex="-1">字体大小 <a class="header-anchor" href="#字体大小" aria-label="Permalink to &quot;字体大小&quot;">​</a></h2><p>字体大小建议设置为偶数倍，因为windows的默认字体支持的是偶数倍，对于奇数字体会表现成大小相同，但是间距变大的情况</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2><h2 id="元素设置100-的参考" tabindex="-1">元素设置100%的参考 <a class="header-anchor" href="#元素设置100-的参考" aria-label="Permalink to &quot;元素设置100%的参考&quot;">​</a></h2><p>padding: 包含块的宽度 margin: 包含块的宽度 border: // 不能使用百分比 font-size: 相对于父元素的文子大小 background-size： 相对于背景区域来设置图片大小，只设置一遍另一边会等图片比例获取（auto） height: 包含块高度 width: 包含块宽度 left: 包含块宽度，从包含块的padding开始计算 top: 包含块高度 translate: 根据子元素本身，（考虑子元素box-size情况,相对的是border-box 计算的宽度或者高度（加了border还有padding还有content的宽度）</p><p>总结下来两个点，padding根据的包含块宽度，margin竖直方式按照包含块宽度translate 根据自身的border-box 宽度来计算，其余的都是常规逻辑</p><h2 id="居中" tabindex="-1">居中 <a class="header-anchor" href="#居中" aria-label="Permalink to &quot;居中&quot;">​</a></h2><h3 id="水平居中" tabindex="-1">水平居中 <a class="header-anchor" href="#水平居中" aria-label="Permalink to &quot;水平居中&quot;">​</a></h3><ol><li>inline-block + 父元素text-align: center</li><li>absolute left:50% margin-left: 50px;</li><li>absolute left:calc(50% - 50px);</li><li>absolute left: 0 right: 0 margin: auto;</li><li>absolute left: 50% transform: translate(-50%);</li><li>flex justify-content: center;</li></ol><h3 id="垂直居中" tabindex="-1">垂直居中 <a class="header-anchor" href="#垂直居中" aria-label="Permalink to &quot;垂直居中&quot;">​</a></h3><ol><li>line-height 和 vertical-algin: middle</li><li>flex align-items: center;</li></ol><h2 id="css特殊关键字" tabindex="-1">css特殊关键字 <a class="header-anchor" href="#css特殊关键字" aria-label="Permalink to &quot;css特殊关键字&quot;">​</a></h2><ol><li>unset 如果该属性是能够继承，表现和inherit 相同，如果是不能继承，使用initial</li><li>initial 初始值</li><li>none 表示忽略这条属性的解析</li><li>auto</li><li>inherit 父元素的值, 即使当前属性不能被继承</li></ol><h4 id="color" tabindex="-1">&lt;color&gt; <a class="header-anchor" href="#color" aria-label="Permalink to &quot;\\&lt;color\\&gt;&quot;">​</a></h4><ol><li>transparent 表示rgba(0, 0, 0, 0)</li><li>currentColor 表示当前色，一般指文本的颜色</li></ol><h3 id="grid" tabindex="-1">grid <a class="header-anchor" href="#grid" aria-label="Permalink to &quot;grid&quot;">​</a></h3><h4 id="规划单元格" tabindex="-1">规划单元格 <a class="header-anchor" href="#规划单元格" aria-label="Permalink to &quot;规划单元格&quot;">​</a></h4><p>grid-template: grid-template-rows / grid-template-columns 设置单元格轨道大小，fr 等比分配剩余空间，repeat类似于宏命令，会重复执行<br> 在规划单元格时，通过 200px [col1-start] 这种方式可以给轨道线命令，如果一个轨道两侧的轨道线命令方式[x-start] 和 [x-end], 这个轨道将会被命令x</p><p>其中有auto-fill 和 auto-fit 能够在repeat中被使用，正常情况下，两个取值相同，在和minmax(200px, 1fr) 配置时有区别 ，autofill是使用先最小的200px来填充，比如总宽度是1500px, auto-fill 先填充7个单元格（即使没有7个项目），再将剩余的100px分配到7个单元格上面。auto-fit是先按照子项目个数来确定初始单元格，比如子项目只有3个， 单元格是按照3个来分配，再把剩余空间分配给这三个单元格。</p><p>还有比较常见的是百分比，百分比大小是根据容器的的宽度或者高度来计算的，如果是存在gap的情况，比如3等分需要repeat(3, calc(100% - 2 * 10px) / 3)来计算</p><p>还有个两个属性max-content和min-content, 一个会尽量把剩余空间填充满， 一个会最小填充。 auto等价于max-content</p><p>通过grid-template-area: &quot;top top&quot; &quot;content content&quot; &quot;....... content&quot;</p><p>这种方式还能生成具名的轨道，其中连续的... 会被处理成匿名的块。生成具名的轨道也会默认生成轨道线,比如[top-start] 和 [top-end]</p><p>大部分情况都写具体的属性， 不要用简写。不方便理解。</p><h4 id="摆设单元格" tabindex="-1">摆设单元格 <a class="header-anchor" href="#摆设单元格" aria-label="Permalink to &quot;摆设单元格&quot;">​</a></h4><p>子项目通过摆设有三种情况，如果设置了order属性，按照order的大小，小的值有限排列 如果设置了grid-column或者grid-row，优先排列有定位属性的。，剩下的就是自动排列，规则是轨道的开始线必须要在上一个自动排序的项目后面</p><p>grid-areas: 设置子项目的具名轨道或者是grid-row-start / grid-column-start/ xx /xx 的缩写</p><p>子元素的定位是要么选择两边，要么选择一边再选择span的块，要么只选择span，span 指的是横跨的个数，也可以指定到横跨的具名轨道 span main表示横跨到下一个main之前(包含这个main)</p><h4 id="对齐" tabindex="-1">对齐 <a class="header-anchor" href="#对齐" aria-label="Permalink to &quot;对齐&quot;">​</a></h4><p>容器对齐 如果容器中子元素并不能撑满容器，比如容器长1000px；规划了3个轨道，一个轨道长200px; 就会有400px的空白 通过 justify-content 主轴方向调整 align-content 副轴调整或者 place-content简写来调整</p><p>子项目对齐，子项目能够通过容器统一调整或者子项目本身调整。 place-items = justify-items / align-items 容器统一调整 place-self = justify-self / align-self 子项目调整</p><p>注意区分 space-around - 在每个网格项目之间放置均匀的空间，在远端有一半大小的空间（子项目左右两边有相同间距，两个子项目相邻就会有两个间距， 第一个项目左边的空间只有中间的空间的一半） space-between - 在每个网格项目之间放置均匀的空间，远端没有空间 space-evenly - 在每个网格项目之间放置均匀的空间，包括远端（子项目左右共享间距，这样第一个子项目左边的空间和中间的间隙是相同的）</p>`,71)]))}const g=i(e,[["render",n]]);export{k as __pageData,g as default};
