import{_ as n,C as l,c as r,o,ah as a,j as i,a as e,G as p}from"./chunks/framework.BurO9VyR.js";const b=JSON.parse('{"title":"vue-router","description":null,"frontmatter":{"title":"vue-router","comments":true,"hide":false,"abbrlink":"6098be36","date":"2022-11-22T22:07:22.000Z","updated":"2022-11-22T22:07:22.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/vue-router.md","filePath":"posts/vue-router.md"}'),h={name:"posts/vue-router.md"},k={start:"2"};function d(u,s,E,c,g,m){const t=l("router-view");return o(),r("div",null,[s[5]||(s[5]=a(`<h3 id="基础中需要注意的点" tabindex="-1">基础中需要注意的点 <a class="header-anchor" href="#基础中需要注意的点" aria-label="Permalink to &quot;基础中需要注意的点&quot;">​</a></h3><ol><li>如果通过path导航，总是回匹配到子路由，如果只想展示父路由，通过name的形式导航</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;parent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    component: ParentComponent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    children: [{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;child&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        component: ChildrenComponent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 会渲染parentComponent 和 ChildComponent</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;parent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只会渲染parentComponent，刷新后</span></span></code></pre></div>`,3)),i("ol",k,[s[2]||(s[2]=i("li",null,[i("p",null,"嵌套路由中子路由如果使用绝对路径代表路由不嵌套，只嵌套组件。")],-1)),s[3]||(s[3]=i("li",null,[i("p",null,"新版本vue-router 支持正则表达式的匹配，同时取消了*匹配符，404页面使用正则来匹配")],-1)),i("li",null,[i("p",null,[s[0]||(s[0]=e("支持命令路由和命令视图, 大致意思是同一个url，可以渲染多个视图。")),p(t,{name:"slider"}),s[1]||(s[1]=e(" ，路由配置中通过components: {default: xxx, slider: xxx} 形式配置"))])]),s[4]||(s[4]=i("li",null,[i("p",null,"支持别名，即url显示一个地址，实际界面展示的是另一个路由url配置的组件")],-1))]),s[6]||(s[6]=a(`<div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    url: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    component: Home,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    alias: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/home&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接浏览器导航到/home 也会展示/的界面</span></span></code></pre></div><ol start="6"><li><p>支持相对重定向和动态重定向，相对重定向对于当前路由，绝对重定向通过传入一个函数实现</p></li><li><p>router-link 支持v-slot，将跳转能力自自定义。</p></li><li><p>同时router-view 也支持v-slot，能将路由页面进行包裹</p></li></ol><h3 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h3><ol><li>组件内beforeRouterLeave</li><li>全局的beforeEach</li><li>路由的beforeEach</li><li>组件内的beforeEnter</li><li>全局的beforeResolve</li><li>全局的afterEach</li><li>新路由的beforeCreated到beforeMounted</li><li>老路由组件的销毁</li><li>新路由mounted</li></ol><h3 id="几个关键概念-routerrecord-和-routerlocation" tabindex="-1">几个关键概念 RouterRecord 和 RouterLocation <a class="header-anchor" href="#几个关键概念-routerrecord-和-routerlocation" aria-label="Permalink to &quot;几个关键概念 RouterRecord 和 RouterLocation&quot;">​</a></h3><p>RouterRecord 表示路由表，指的是用户在配置路由时的定义，用户配置时RouterRecordRaw，vue-router内部补全成RouterRecordNormalized。理解成路由实例的构造器选项</p><p>RouterLocation是实际生效的路由，理解成路由的实例化。其中RouterLocationRaw用于push的参数，相当于根据RouterLocationRaw查找到具体的路由。在to和from以及matched中$route均是这个对象</p><h3 id="源码解析" tabindex="-1">源码解析 <a class="header-anchor" href="#源码解析" aria-label="Permalink to &quot;源码解析&quot;">​</a></h3><h4 id="安装插件" tabindex="-1">安装插件 <a class="header-anchor" href="#安装插件" aria-label="Permalink to &quot;安装插件&quot;">​</a></h4><ol><li>通过mixin添加在beforeCreated中添加绑定_currentRoot._router和_currentRoot._route 属性，在Vue.prototype中将两个$route和$router代理到上面两个属性上.</li><li>注册两个全局组件router-link 和 router-view</li><li>同时还添加了防止重复安装的判断</li></ol><h4 id="new-vuerouter-routes" tabindex="-1">new VueRouter(Routes) <a class="header-anchor" href="#new-vuerouter-routes" aria-label="Permalink to &quot;new VueRouter(Routes)&quot;">​</a></h4><p>大致过程就是递归的根据的传入的RouteRecordRaw 生成路由记录表，并生成nameMap和pathMap，同时生成match函数，通过调用match函数获取当前匹配的路由表</p><h4 id="router-init" tabindex="-1">router.init() <a class="header-anchor" href="#router-init" aria-label="Permalink to &quot;router.init()&quot;">​</a></h4><p>在安装插件时根据是否是根路由，对不同的路由模式添加监听，监听函数主要对url变化时，调整当前激活的路由写入到全局$route中</p><h4 id="router-view" tabindex="-1">router-view <a class="header-anchor" href="#router-view" aria-label="Permalink to &quot;router-view&quot;">​</a></h4><p>router总是监听当前$route的变化并喧嚷路由对应的界面。通过添加$dataView参数标记自身，查找自身的深度来渲染matched数组的第几项。</p>`,16))])}const F=n(h,[["render",d]]);export{b as __pageData,F as default};
