import{_ as a,c as o,o as r,ah as i}from"./chunks/framework.BurO9VyR.js";const p=JSON.parse('{"title":"cookie","description":null,"frontmatter":{"title":"cookie","comments":true,"hide":false,"abbrlink":"8ae0ba66","date":"2022-02-25T06:40:45.000Z","updated":"2022-02-25T06:40:45.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/cookie.md","filePath":"posts/cookie.md"}'),t={name:"posts/cookie.md"};function n(l,e,c,h,s,d){return r(),o("div",null,e[0]||(e[0]=[i('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>最近在公司碰到了内嵌的iframe始终提示未登录的问题，查询到时接口请求时未自动携带cookie，排查过程中一直没搞懂cookie携带的机制。将排查后学习到总计一下。</p><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><p>先来几个问题</p><ol><li>cookie是怎么设置到浏览器中，设置cookie有什么限制</li><li>什么样的请求能携带cookie，能携带哪些cookie</li><li>cookie存储方式是什么</li><li>cookie 和 storeage 区别</li><li>跨域和跨站</li></ol><h2 id="跨域和跨站" tabindex="-1">跨域和跨站 <a class="header-anchor" href="#跨域和跨站" aria-label="Permalink to &quot;跨域和跨站&quot;">​</a></h2><p>同域: 协议、域名、端口相同，反之是跨域<br> 同站: eTLD + 1, 顶级域名 + 1 相同则是同站，反之是跨站</p><h2 id="请求的场景" tabindex="-1">请求的场景 <a class="header-anchor" href="#请求的场景" aria-label="Permalink to &quot;请求的场景&quot;">​</a></h2><p>假设当前网站是xunserver.cn, 页面地址是<a href="http://cloud.xunserver.cn/file%E3%80%82%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%87%BA%E7%9A%84%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D" target="_blank" rel="noreferrer">http://cloud.xunserver.cn/file。这个页面发出的请求有以下几种</a></p><ol><li>同域请求，<a href="http://cloud.xunserver.cn/patha" target="_blank" rel="noreferrer">http://cloud.xunserver.cn/patha</a></li><li>跨域请求不跨站 <a href="https://cloud.xunserver.cn/patha" target="_blank" rel="noreferrer">https://cloud.xunserver.cn/patha</a> 和 <a href="http://cloud.xunserver.cn:8088/patha" target="_blank" rel="noreferrer">http://cloud.xunserver.cn:8088/patha</a></li><li>子域名请求 <a href="http://nps.cloud.xunserver.cn/patha" target="_blank" rel="noreferrer">http://nps.cloud.xunserver.cn/patha</a></li><li>跨域同时跨站 <a href="http://docker.xunserver.com/patha" target="_blank" rel="noreferrer">http://docker.xunserver.com/patha</a></li><li>上级域名请求 <a href="http://xunserver.cn" target="_blank" rel="noreferrer">http://xunserver.cn</a></li></ol><h2 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h2><h3 id="cookie组成" tabindex="-1">cookie组成 <a class="header-anchor" href="#cookie组成" aria-label="Permalink to &quot;cookie组成&quot;">​</a></h3><p>cookie 包括name, value, domain, path, expire, httpOnly, secure, samesite。</p><h3 id="cookie-如何被设置" tabindex="-1">cookie 如何被设置 <a class="header-anchor" href="#cookie-如何被设置" aria-label="Permalink to &quot;cookie 如何被设置&quot;">​</a></h3><p>有两种设置cookie的方法</p><ol><li>请求响应头中set-cookie</li><li>前端JS代码document.cookie。</li></ol><p>通过响应设置cookie时， domian默认是当前请求的eTLD + 1， 路径默认是/。可以设置上级域名和上级路径的cookie，如果设置子域名或者子路径，cookie设置会无效，而且会被抛弃。</p><p>document.cookie 设置和set cookie类似，前者被限制于当前文档的地址（浏览器地址栏）,而且不能设置httpOnly和secure 属性。</p><h3 id="cookie-如何被携带" tabindex="-1">cookie 如何被携带 <a class="header-anchor" href="#cookie-如何被携带" aria-label="Permalink to &quot;cookie 如何被携带&quot;">​</a></h3><p>当浏览器发送请求时，根据请求的场景携带cookie不同。</p><ol><li>同域请求， 自动携带当前请求所有的子域名和父路径, 会携带path=/patha、path=/ 和 domain=cloud.xunserver.cn、xunserver.cn的cookie</li><li>cookie不区分端口和协议，所以同上一致</li><li>会携带domain=nps.cloud.xunserver.cn 以及上级域名</li><li>携带domian=docker.xunserver.cn</li><li>携带domain=xunsrever.cn 不会携带cloud.xunserver.cn 域名</li></ol><h4 id="samesite-是啥" tabindex="-1">samesite 是啥 <a class="header-anchor" href="#samesite-是啥" aria-label="Permalink to &quot;samesite 是啥&quot;">​</a></h4><p>用户在银行登录了系统，这个时候浏览器嵌入了cookie，如果恶意网站中有一个form表单，提交地址是银行的链接，用户在点击链接后就会触发接口，因为请求携带了cookie，所以银行会判断为正常用户，从而带来不安全。或者恶意网站嵌套i银行frame，诱导用户点击，实际点击到了银行网站的接口。 samesite有三个值,strict, lax 和none<br> strict 表示只有请求在同站的情况下，才会携带cookie。<br> lax 表示除了a标签、预加载、get表单能cookie外，其余场景都不能携带，包括iframe<br> none 表示不限制</p><p>samesite 如何设置，浏览器默认是lax, 匿名浏览器如果关闭第三方共享是strict。如果设置none，需要同时secure，同时在https下设置</p><h3 id="跨域如何携带cookie" tabindex="-1">跨域如何携带cookie <a class="header-anchor" href="#跨域如何携带cookie" aria-label="Permalink to &quot;跨域如何携带cookie&quot;">​</a></h3><h4 id="哪些些请求能跨域" tabindex="-1">哪些些请求能跨域 <a class="header-anchor" href="#哪些些请求能跨域" aria-label="Permalink to &quot;哪些些请求能跨域&quot;">​</a></h4><p>link、img、script 标签支持跨域，但是new Image不支持。跨域能发送请求，但是不能解析响应。 其余的通过axios或者fetch发送跨域请求， axios 需要添加withCredentials: true支持跨域携带cookie<br> fetch 需要添加withCredentials: include属性</p><h4 id="fetch-withcredentials解析" tabindex="-1">fetch withCredentials解析 <a class="header-anchor" href="#fetch-withcredentials解析" aria-label="Permalink to &quot;fetch withCredentials解析&quot;">​</a></h4><p>omit 跨域不打送cookie include 总是发送 same-origin 同站才发送</p><h3 id="storage" tabindex="-1">storage <a class="header-anchor" href="#storage" aria-label="Permalink to &quot;storage&quot;">​</a></h3><p>localstorage 和 sessionStorage 严格按照同源原则。</p><h3 id="document-domain-用来干嘛" tabindex="-1">document.domain 用来干嘛 <a class="header-anchor" href="#document-domain-用来干嘛" aria-label="Permalink to &quot;document.domain 用来干嘛&quot;">​</a></h3><p>可以把父页面和iframe的domain设置成一个（都需要设置，因为document.domain调用后端口会被设置为null），父页面可以拿到iframe的window对象，从而调用iframe中的方法实现跨域。设置document.domain 仅设置自身或者上级域名，不能设置为其他或者子域名。</p><p>也可以通过window.open 获取引用</p><h3 id="如何检查浏览器同时打开多个相同页面" tabindex="-1">如何检查浏览器同时打开多个相同页面 <a class="header-anchor" href="#如何检查浏览器同时打开多个相同页面" aria-label="Permalink to &quot;如何检查浏览器同时打开多个相同页面&quot;">​</a></h3><p>循环检查localStorage</p><h3 id="host、referer和origin" tabindex="-1">host、referer和origin <a class="header-anchor" href="#host、referer和origin" aria-label="Permalink to &quot;host、referer和origin&quot;">​</a></h3><p>host: 指向请求的host和端口号，任何请求都有<br> referer: 当前请求发起的来源，一个页面跳转到另一个页面指向的是之前的页面，页面内发起的资源请求，指向当前文档的地址，不包含hash origin: 跨域请求中常见 ，指向原始</p>',38)]))}const k=a(t,[["render",n]]);export{p as __pageData,k as default};
