import{_ as e,c as t,o,ah as l}from"./chunks/framework.BurO9VyR.js";const _=JSON.parse('{"title":"小数相加问题","description":null,"frontmatter":{"title":"小数相加问题","comments":true,"hide":false,"abbrlink":"e6fe5687","date":"2023-03-14T19:09:36.000Z","updated":"2023-03-14T19:09:36.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/小数相加问题.md","filePath":"posts/小数相加问题.md"}'),i={name:"posts/小数相加问题.md"};function r(s,a,n,d,p,h){return o(),t("div",null,a[0]||(a[0]=[l('<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>以前只知道0.1 + 0.2 !== 0.3，不知道为什么，而且解决方案也很粗糙，就是简单的扩大， 将小数部分隐藏掉</p><h3 id="为什么js会出现-0-1-0-2-0-3" tabindex="-1">为什么js会出现 0.1 + 0.2 !== 0.3 <a class="header-anchor" href="#为什么js会出现-0-1-0-2-0-3" aria-label="Permalink to &quot;为什么js会出现 0.1 + 0.2 !== 0.3&quot;">​</a></h3><p>js数字的存储按照64位双精度浮点数保存，小数和整数都是。部分小数在转换成二进制时，总是无限循环的（整数部分除2取余，小数部分是乘2，递归的对小数部分继续处理）。 所以即使再多位也没法保存一个0.1，0.1 保存在内存中就会丢失部分信息，一个不准确的值和另一个不准确的值相加自然不会等于另一个不准确的值。</p><p>0.3转换成二进制 0.3 * 2 = 0.6不大于1， 二进制输入0， 继续对0.6 * 2 = 1.2，大于1，二进制为01, 继续对0。2处理，会发现永远都有小数部分，陷入无限循环。</p><h3 id="tofixed精度问题" tabindex="-1">toFixed精度问题 <a class="header-anchor" href="#tofixed精度问题" aria-label="Permalink to &quot;toFixed精度问题&quot;">​</a></h3><p>四舍五入是按位比较，0舍1入， 有可能1.335.toFixed(2) 不等于1.34 而是1.33</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>解决就是将值能够正常的在内存中保存。</p><ol><li>将小数相加的结果toFixed，保留几位小数，但是也有精度问题，常见的是保留3位小数，然后用正则匹配出两位小数。</li><li>将小数扩大成整数，然后除，前提是知道最多多少位，而且扩大成整数后不会超出最大长度。</li><li>采用自定义的方式计算</li></ol><h3 id="双精度64位是啥" tabindex="-1">双精度64位是啥 <a class="header-anchor" href="#双精度64位是啥" aria-label="Permalink to &quot;双精度64位是啥&quot;">​</a></h3><p>就是用64位空间表示一个整数或者小数，头一位表示符号位，中间11位是指数E，后面52位是尾数位M。</p><blockquote><p>E = -1 ^ 1 * M * 2 ^ E 十进制5表示成二进制是101 也是 1.01 * 2^2 表示成 -1 * 1.01(M) * 2 ^ 2</p></blockquote><p>0.3表示成二进制是 0.01000100010001。。。。 表示成E = 1.000011111 ^ 2 ^ -2</p>',14)]))}const u=e(i,[["render",r]]);export{_ as __pageData,u as default};
