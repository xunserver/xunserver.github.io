import{_ as a,c as s,o as t,ah as e}from"./chunks/framework.BurO9VyR.js";const _=JSON.parse('{"title":"浏览器解析","description":null,"frontmatter":{"title":"浏览器解析","comments":true,"hide":false,"abbrlink":"50c7c64b","date":"2022-03-01T15:35:42.000Z","updated":"2022-03-01T15:35:42.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/浏览器解析.md","filePath":"posts/浏览器解析.md"}'),i={name:"posts/浏览器解析.md"};function o(r,l,n,c,d,h){return t(),s("div",null,l[0]||(l[0]=[e('<h3 id="浏览器渲染进程包含的线程" tabindex="-1">浏览器渲染进程包含的线程 <a class="header-anchor" href="#浏览器渲染进程包含的线程" aria-label="Permalink to &quot;浏览器渲染进程包含的线程&quot;">​</a></h3><ol><li>GUI 渲染线程，负责解析HTML，CSS，构建DOM、CSSOM和render tree, 布局和绘制。当页面回流时。</li><li>js引擎线程，一个渲染进程只有一个js引擎线程，负责解析执行js代码</li><li>事件线程，当事件触发时，会添加到队尾，等待js引擎执行</li><li>定时器线程，触发后放在队尾</li><li>htto请求线程，请求后放在队尾</li></ol><h3 id="简略版xuanran" tabindex="-1">简略版xuanran <a class="header-anchor" href="#简略版xuanran" aria-label="Permalink to &quot;简略版xuanran&quot;">​</a></h3><ol><li>解析html，构建dom树</li><li>解析css,构建css树</li><li>cssom和dom合并成渲染树</li><li>根据渲染树计算节点位置，布局</li><li>调用GUI绘图，上色，合成图层，并渲染到界面上</li></ol><h3 id="html、css和js解析构建顺序" tabindex="-1">html、css和js解析构建顺序 <a class="header-anchor" href="#html、css和js解析构建顺序" aria-label="Permalink to &quot;html、css和js解析构建顺序&quot;">​</a></h3><ol><li>html解析从上到下解析文档，依次构建DOM</li><li>如果碰到link或者style，异步的进行cssom构建</li><li>如果碰到js脚本，会先等到前面的cssom构建完成，才会解析js脚本（可以先下载）。js脚本解析执行期间，html会停止解析</li><li>初始的html解析完成后，会触发documentContentLoad 事件。此时图片资源可能还未下载完成</li><li>load 事件表示初始html以及资源全部load</li></ol><h3 id="渲染进程中各种线程的配合" tabindex="-1">渲染进程中各种线程的配合 <a class="header-anchor" href="#渲染进程中各种线程的配合" aria-label="Permalink to &quot;渲染进程中各种线程的配合&quot;">​</a></h3><p>js引擎线程会执行一个有多个字队列的队列，队列中每个子队列是由各种引擎推送的的。刚开始时会GUI线程会解析HTML，当碰到js代码会将js推送到js的引擎队列，这时js引擎会立即执行。中断GUI进程的渲染。在代码中js引擎可能会发起请求、定时器或者新建事件绑定，就是通知其他线程开始工作， 定时线程会在定时完成后将代码转移到js引擎的新子队列中。 事件引擎和网络同理</p>',8)]))}const u=a(i,[["render",o]]);export{_ as __pageData,u as default};
