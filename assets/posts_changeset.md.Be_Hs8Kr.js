import{_ as t,c as a,o as i,ah as n}from"./chunks/framework.BurO9VyR.js";const g=JSON.parse('{"title":"npm包的CI和changeset","description":null,"frontmatter":{"title":"npm包的CI和changeset","comments":true,"hide":false,"abbrlink":"69a9cdfe","date":"2022-11-30T11:28:44.000Z","updated":"2022-11-30T11:28:44.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/changeset.md","filePath":"posts/changeset.md"}'),s={name:"posts/changeset.md"};function o(l,e,c,h,r,p){return i(),a("div",null,e[0]||(e[0]=[n('<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>目前的config仓库按照monorepo的方式存放的，里面有完全不同种类的的config包，大部分包的依赖的都是独立的,也有部分公共的包比如typescript和prettier。同时各个仓库的发布阶段都是交给github-action在做CI如何设计。</p><h3 id="changeset" tabindex="-1">changeset <a class="header-anchor" href="#changeset" aria-label="Permalink to &quot;changeset&quot;">​</a></h3><p>changeset生成能够被消耗的changeset描述文件, 开发自行调整描述文件， changeset version消耗描述文件，调整需要发布的包， changeset publish到各个包发布，流程很简单。 按照下面步骤描述下细节</p><ol><li><p>changeset init 初始化changeset配置</p></li><li><p>changeset add 对当前更改新增描述文件，changeset add 会自动的查找到当前的修改的包，前提是没有commit的情况下</p></li><li><p>选择包进入命令式的交互填写，主要写需要更新那些包。通过patch minor 或者major的方式更新包。</p></li><li><p>changeset version消耗刚才描述文件来对包进行version的更新。</p></li><li><p>changeset publish 会到各个包下面进行npm publish，这个步骤也可以通过自行publish实现</p></li></ol><h3 id="实战" tabindex="-1">实战 <a class="header-anchor" href="#实战" aria-label="Permalink to &quot;实战&quot;">​</a></h3><ol><li>本地修改代码，运行changeset add 生成消耗文件，可以不修改文件，强行生成changeset文件。</li><li>正常上传代码，github action 根据存在pub来决定是否打包</li><li>github action 运行 changeset version 消耗文件同时修改版本号</li><li>运行pnpm -F &quot;[origin/xx]&quot;... run build 来分别执行相关的包的build</li><li>运行pnpm publish -F &quot;[origin/xxx]&quot; 发布包或者[HEAD]...（当前分支比较）</li><li>使用<code>git add -A</code> git commit -m &quot;&quot; git push 推送包， 也可以通过merge来推送包避免多人修改时的问题</li></ol>',7)]))}const u=t(s,[["render",o]]);export{g as __pageData,u as default};
