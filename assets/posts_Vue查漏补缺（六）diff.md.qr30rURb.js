import{_ as s,c as a,o as e,ah as l}from"./chunks/framework.BurO9VyR.js";const E=JSON.parse('{"title":"Vue查漏补缺（一）生命周期","description":null,"frontmatter":{"title":"Vue查漏补缺（一）生命周期","comments":true,"hide":false,"abbrlink":"69b5cd9a","date":"2022-03-24T08:03:10.000Z","updated":"2022-03-24T08:03:10.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/Vue查漏补缺（六）diff.md","filePath":"posts/Vue查漏补缺（六）diff.md"}'),n={name:"posts/Vue查漏补缺（六）diff.md"};function t(d,i,h,p,k,o){return e(),a("div",null,i[0]||(i[0]=[l(`<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>该死的八股文，问就是diff。vue中使用两种diff方案，第一个是简单diff，用在vue2中，第二个是双端diff，vue3再用。首先明白diff要做什么，总的目的是为了能不动就不动，能移动绝不创建新的，实在没法才创建新的。 能不能就不动是指比如diff前的dom是 A B C D， diff后的dom是 B C D A，尽量只移走A, BCD不动。能移动绝不创建值得是将A移动到末尾而不是新创建一个A，</p><h3 id="前提" tabindex="-1">前提 <a class="header-anchor" href="#前提" aria-label="Permalink to &quot;前提&quot;">​</a></h3><ol><li>sameVnode判断前后Vnode是否相同</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sameVnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldVnode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVnode.key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        oldVnode.tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVnode.tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        oldVnode.isComment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVnode.isComment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        isDef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVnode.data) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isDef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVnode.data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li>patchVnode是将两个相同sameVnode的vnode处理，如果是普通的vnode，将新节点上属性移植到旧节点上，然后再对children递归进行diff。如果是组件节点。走组件的prepatch 流程。</li></ol><h3 id="简单diff" tabindex="-1">简单diff <a class="header-anchor" href="#简单diff" aria-label="Permalink to &quot;简单diff&quot;">​</a></h3><ol><li>diff总是对同级的节点进行比较，如果节点不同，直接新节点替换旧节点</li><li>如果节点相同，按照patchVnode方式，将新节点的属性复制到旧节点的dom上（复用了旧节点的dom避免创建新）</li><li>再对children进行处理，按照头比较头，尾尾比较，新头比较旧尾，新尾比较旧头的方式循环处理 <ol><li>头头比较相同，头头指针++</li><li>尾尾相同，尾尾指针--，</li><li>新头旧尾相同，新头++。旧尾--。将旧尾的dom移动到旧头vnode对象的dom前面</li><li>新尾旧头相同，新尾--，旧头++。将旧头的dom移动到旧尾的下一个节点的前面。</li><li>将旧节点建立key-vnode的映射表，从新节点头到尾查找旧节点（通过key查找），没有key，直接双重循环找有没有和新节点相同的旧节点，找到相同的旧节点后，patchVnode节点，将旧节点移动到旧头dom前面，同时将旧节点的标志位设置为了null，在后续的查找中跳过该节点</li><li>如果没有在旧节点中查找到，证明该新节点是需要新创建</li><li>如果双端指针重合，证明复用已经完成，旧节点剩余的需要全部删除，新节点剩余的依次添加在新尾下一个节点的前面（反向循环队列）</li></ol></li></ol><p>其中可以看到关键的key，没有这个key，很多场景下都会走全部删除并新建的流程，</p><h3 id="vue3的diff" tabindex="-1">vue3的diff <a class="header-anchor" href="#vue3的diff" aria-label="Permalink to &quot;vue3的diff&quot;">​</a></h3><ol><li>头头比较相同，尾尾也相同</li><li>将旧建立索引表，新建一个数组表示新队列的在旧队列中索引（如果没有找到，置为0）</li><li>找到这个数组的最长递增区块。</li><li>将新节点从尾到头遍历，如果在最长递增区块中不处理（按照patchVnode流程走），如果是0，按照新建流程，插入当前vnode下一个vnode对应dom的前面。</li><li>如果最后旧队列中还存在未处理的vnode，做删除操作。</li></ol>`,11)]))}const f=s(n,[["render",t]]);export{E as __pageData,f as default};
