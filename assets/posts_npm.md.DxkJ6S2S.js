import{_ as e,c as p,o as n,ah as i}from"./chunks/framework.BurO9VyR.js";const d=JSON.parse('{"title":"npm","description":null,"frontmatter":{"title":"npm","comments":true,"hide":false,"abbrlink":"a1345b2b","date":"2022-07-19T10:26:23.000Z","updated":"2022-07-19T10:26:23.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/npm.md","filePath":"posts/npm.md"}'),l={name:"posts/npm.md"};function s(t,a,o,r,c,h){return n(),p("div",null,a[0]||(a[0]=[i(`<h3 id="npm-下载包流程" tabindex="-1">npm 下载包流程 <a class="header-anchor" href="#npm-下载包流程" aria-label="Permalink to &quot;npm 下载包流程&quot;">​</a></h3><ol><li>检查项目中是否存在package-lock.json 文件，如果有，比较和package.json和lock.json（一般都不一致），如果版本兼容则使用lock.json 定义的依赖，如果不兼容使用package.json 并更新。</li><li>检查缓存，无缓存使用,registry中获取包的tgz压缩包，下载(npm-registry-fetch)到本地缓存目录。</li><li>从缓存目录解压到node_modules目录，tgz是一个package目录，解压时未包含package目录</li></ol><h3 id="npm-本地添加离线包" tabindex="-1">npm 本地添加离线包 <a class="header-anchor" href="#npm-本地添加离线包" aria-label="Permalink to &quot;npm 本地添加离线包&quot;">​</a></h3><p>公司处于内网环境无法下载包，需要自行添加包。</p><ol><li>使用npm-pack-all 制作tgz离线包。</li><li>上传离线包到npm仓库</li><li>网络下载或者使用npm i xxx.tgz安装</li></ol><h3 id="yarn-常用命令" tabindex="-1">yarn 常用命令 <a class="header-anchor" href="#yarn-常用命令" aria-label="Permalink to &quot;yarn 常用命令&quot;">​</a></h3><p>npm i =&gt; yarn npm i xx =&gt; yarn add xx -S npm i xx -S =&gt; yarn add xx npm i xx -D =&gt; yarn add xx -D npm i -g xx =&gt; yarn global add xx npm uninstall xx =&gt; yarn remove xx</p><h3 id="mutilrepo-和-monorepo" tabindex="-1">mutilRepo 和 monoRepo <a class="header-anchor" href="#mutilrepo-和-monorepo" aria-label="Permalink to &quot;mutilRepo 和 monoRepo&quot;">​</a></h3><p>当团队项目变多，而且各个项目存在关联时，就需要采用monoRepo方式管理。传统的muti的lRepo将项目分散到各个仓库。会出现如下痛点</p><ul><li>不能批量操作，操作某个项目需要到相应的目录下操作。项目多起来简直就是地狱</li><li>比如一个组件库升级了版本，需要在组件库修改版本号，发布npm。然后业务库再更新package.json 重新安装依赖。</li><li>组件库如果是break change 的更新，业务库可能会忘记及时更新</li></ul><p>monoRepo出现会解决这些痛点，可以在一个地方对所有仓库进行，仓库相互之间能互相感知。</p><h3 id="npm-痛点" tabindex="-1">npm 痛点 <a class="header-anchor" href="#npm-痛点" aria-label="Permalink to &quot;npm 痛点&quot;">​</a></h3><p>npm1 npm2项目下根据项目的package.json下载依赖到node_module，如果依赖存在依赖其他的情况会在node_modules/xxx/node_modules, 而且递归下去。 出现问题是大量重复的包被安装，而且文件目录过生对于查找耗时严重。</p><p>npm3 后优化了结构扁平化处理，如果一个依赖没在项目node_modules 出现，依赖的依赖就会安装在项目的node_modules 中，如果两个依赖同时依赖一个版本不一致的库，先安装的依赖在项目下，后安装按照npm1 npm2 处理。这样做也有问题 1.扁平的算法耗时严重。2. 项目未在package.json 中声明的依赖也可以直接引用，会出现不确定性(往往是自动补全代码带来的)。 3. 对于相同依赖的不同版本，完全是按照安装先后顺序来的，会有不确定的情况，这种会对缓存有较大影响（后续的package-lock.json专门解决这个）</p><h3 id="pnpm-解决的痛点" tabindex="-1">pnpm 解决的痛点 <a class="header-anchor" href="#pnpm-解决的痛点" aria-label="Permalink to &quot;pnpm 解决的痛点&quot;">​</a></h3><p>pnpm通过软链接的方式把扁平的结构放到.pnpm目录中，同时.pnpm 通过npm2 的方式保证了包的正确性，子package中的node_module也是引用的root node_module/.pnpm的包。</p><h3 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h3><h4 id="常用的命令" tabindex="-1">常用的命令 <a class="header-anchor" href="#常用的命令" aria-label="Permalink to &quot;常用的命令&quot;">​</a></h4><ul><li><p>pnpm help xxx 查询各cli使用</p></li><li><p>pnpm config set xx=xxx --location=project | user | global</p></li><li><p>pnpm xxx 自动查询找package中定义的脚本，如果未查询到当做shell命令执行，pnpm pwd =&gt; /xx/xx/xx</p></li><li><p>pnpm install，安装整个项目包括子项目的依赖, --frozen-lockfile 保证安装依赖不会更新lockFile。-P 只安装Dependencies依赖， -D 只下载devDependencies依赖。</p></li><li><p>pnpm add xx 安装某个依赖，默认会添加依赖到dependencies， -E 明确版本（必备） -D 保存到devDependencies -P 添加到peerDependencies -O 添加到可选依赖 -W 安装到项目根目录<br> 当运行安装依赖时默认会在子集中查找是否有满足条件的包，如果有引用子项目的，通过--workspace 指定包只能在子项目中查找。</p></li><li><p>npm update 更新某个包，也用于更新子项目。</p></li><li><p>pnpm env use 16 -g 代替nvm功能安装包，也支持在项目的npmrc 文件中配置use-node-version=16 保证不同的项目使用不同盖尔nodejs</p></li><li><p>pnpm publish -F @xunserver/test 发布某个子项目，发布项目时，会替换package中workspace协议的依赖。--public=access 发布公共项目 --dry-run 仅执行发布流程但是不发布 --no-git-checks 不检查git --public-branch 设置发布的分支 通过packagejson中的publishConfig字段可以定义在发布时替换相应的package字段</p></li><li><p>pnpm pack 将需要publish的包xxx.gz输出到本地目录</p></li></ul><h4 id="npm-config" tabindex="-1">npm_config <a class="header-anchor" href="#npm-config" aria-label="Permalink to &quot;npm_config&quot;">​</a></h4><p>pnpm 复用.npmrc 配置文件，大部分配置都能在cli指定通过选项指定，部分不能指定的配置在.npmrc中key=value，如果需要在cli动态指定参数有两种方案添加npm_config_key=value 的环境变量，二是添加选项--config.key=value 常用的npm_config 有如下</p><ul><li>registry=<a href="http://xxxx/" target="_blank" rel="noreferrer">http://xxxx/</a> 制定依赖安装的仓库，支持@bable:registry=xxx，指定某个包（或者组织）只按照某个仓库安装</li><li><code>\\&lt;URL\\&gt;</code>:_authToken url 是仓库的地址，_authToken 支持从环境变量获得\${xxx}</li><li><code>\\&lt;URL\\&gt;</code>:tokenHelper tokenHelper指向一个可以执行的文件，通过文件返回的结果作为token。</li><li>use-node-version=16.1.1 指定项目运行需要的nodejs版本</li><li>node-mirror:&lt;releaseDir&gt; 默认值 <a href="https://nodejs.org/download/%5C" target="_blank" rel="noreferrer">https://nodejs.org/download/\\</a>&lt;releaseDir&gt;/ 指定pnpm env use 的下载的nodejs目录</li></ul><h4 id="packagejson需要关注的字段" tabindex="-1">packageJSON需要关注的字段 <a class="header-anchor" href="#packagejson需要关注的字段" aria-label="Permalink to &quot;packageJSON需要关注的字段&quot;">​</a></h4><ul><li>engines 指定项目的nodejs版本和pnpm版本</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;engines&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;=10&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;pnpm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;=3&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>publishConfig 发布时替换packageJSON中字段</li></ul><h4 id="pnpm-解决patch问题" tabindex="-1">pnpm 解决patch问题 <a class="header-anchor" href="#pnpm-解决patch问题" aria-label="Permalink to &quot;pnpm 解决patch问题&quot;">​</a></h4><p>有时候用的第三方依赖有bug，需要我们自行调整，使用package alias简单实现，下载第三方源码（比如xxx1），修改编译发布到自己的仓库（取了了新名字xxx2）。pnpm add xxx1@npm:xxx2 即可把对xxx1的引用全部换成xxx2。</p><h4 id="pnpm-命令补全" tabindex="-1">pnpm 命令补全 <a class="header-anchor" href="#pnpm-命令补全" aria-label="Permalink to &quot;pnpm 命令补全&quot;">​</a></h4><p>pnpm install-completion</p><h4 id="用好pnpm的关键-filter-f" tabindex="-1">用好pnpm的关键 --filter -F <a class="header-anchor" href="#用好pnpm的关键-filter-f" aria-label="Permalink to &quot;用好pnpm的关键 --filter -F&quot;">​</a></h4><h4 id="pnpm生产实战" tabindex="-1">pnpm生产实战 <a class="header-anchor" href="#pnpm生产实战" aria-label="Permalink to &quot;pnpm生产实战&quot;">​</a></h4><p>假设项目中存在packageA和packageB，其中packageA依赖于packageB。面临着如下的问题</p><ol><li>packageA在构建生产环境时，使用本地构建的packageB还是发布到环境的packageB</li><li>如果是CI在构建，是否需要在CI环境上构建packageB</li><li>本地构建开发环境时，如何引入packageB的包，引入的是构建前的包还是构建后的包</li><li>本地开发环境如何对packageB的代码进行调试</li><li>packageA需要依赖packageB的老版本，但是当前项目中packageB是新版本，如何解决</li></ol><p>packageJson中依赖通过workspace: x.x.x 指定，如果当前项目需要workspace中的版本，则通过这种方式指定，如果当前项目依赖的是老版本，则通过删除workspace的指定</p><p>pnpm -F 支持依赖的层级的选择，pnpm -F @xunserver/test... run build。会依次的查找@xunserver/test 依赖的同时存在项目中的包执行build，比如@packageA定义了依赖packageB， npm -F @packageA... run build 会先执行packageB的build，在执行packageA的build</p><p>问题一：解决如下，如果依赖的packageB已经发布，同时项目中的packageB比较新，packageA依赖的旧版本的packageB，则应该修改packageA的package删除workspace协议。如果需要使用的packageB是本地最新的，则按照workspace的方式使用，如果使用的是打包后的B，直接在本地执行B的打包</p><p>问题二：解决方案同问题一，主要看是否需要使用workspace中的代码，如果需要使用workspace的代码，使用依赖层层构建的方式</p><p>问题三 ：这个情况有两种场景，一般来说引入packageB不会引入B的源码，都是引入的构建后的代码，因为packageB和packageA不一定使用的相同的构建工具和流程，但是也有packageB的是packageA的子项目，这个时候也就不存在packageB源码的生产代码有区别，直接引用即可， 如果packageB引入的是构建后代码，那么调试的时候就没法找到是哪个文件出错，需要引入sourcemap的调试方法，同时在vscode中源码映射的方式来实现调试。还有个问题需要解决的是，packageB每次调试改动后如何通知packageA重新构建，将watch选项添加到生产环境的构建流程中，新增production:watch的构建选项</p><p>问题四：本地开发时如何对packageA的依赖项packageB进行调试，packageB在构建时始终构建sourcemap，特别是在本地开发环境中。针对线上环境，通过调整packageA构建的参数来屏蔽packageB的sourcemap是否引入。packageB构建参数sourcemap后，参考前面的devtools通关秘籍进行调试</p><p>问题五：前面已经论述</p><h3 id="pnpm-发布流程控制" tabindex="-1">pnpm 发布流程控制 <a class="header-anchor" href="#pnpm-发布流程控制" aria-label="Permalink to &quot;pnpm 发布流程控制&quot;">​</a></h3><h3 id="只允许pnpm" tabindex="-1">只允许pnpm <a class="header-anchor" href="#只允许pnpm" aria-label="Permalink to &quot;只允许pnpm&quot;">​</a></h3><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;preinstall&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;npx only-allow pnpm&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="n-包管理器是啥" tabindex="-1">n 包管理器是啥 <a class="header-anchor" href="#n-包管理器是啥" aria-label="Permalink to &quot;n 包管理器是啥&quot;">​</a></h3><p>ni xx -S =&gt; npm i xxx -S nr =&gt; npm run nrm =&gt; npm uninstall nx =&gt; npm execute</p><p>n 会自动检查项目下存在package-lock.json、yarn.lock或者pnpm-lock.yaml 自动选择包管理器安装。</p><h3 id="npmrc、-yarnrc和-pnpmrc" tabindex="-1">.npmrc、.yarnrc和.pnpmrc <a class="header-anchor" href="#npmrc、-yarnrc和-pnpmrc" aria-label="Permalink to &quot;.npmrc、.yarnrc和.pnpmrc&quot;">​</a></h3><p>npmrc格式是key=value的形式 value和key有空格需要用&quot;&quot;包起来 yarnrc格式是key value 的形式，有空格需要用&quot;&quot;包裹 pnpmrc使用的npmrc配置</p><h3 id="packagejson中需要关注的字段" tabindex="-1">packageJson中需要关注的字段 <a class="header-anchor" href="#packagejson中需要关注的字段" aria-label="Permalink to &quot;packageJson中需要关注的字段&quot;">​</a></h3><p>dependencies: 生产依赖，总是会被安装 dev dependencies: 如果这个包出现在首应用中，总是会被安装，如果是作为另一个包的依赖，则不会安装，比如A依赖了B，B中定义dev dependencies的不会被安装 peer dependencies：声明这个包不是我需要直接安装的，我只是需要这个包，要求依赖方自行安装依赖。npm7后也会自动安装。安装过程如果碰到重复依赖不能处理的情况会报错，添加--legacy-peer-dep 会忽略冲突的依赖，以先安装的为准</p>`,51)]))}const m=e(l,[["render",s]]);export{d as __pageData,m as default};
