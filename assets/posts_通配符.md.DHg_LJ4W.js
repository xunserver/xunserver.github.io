import{_ as t,c as e,o as a,ah as i}from"./chunks/framework.BurO9VyR.js";const m=JSON.parse('{"title":"通配符","description":null,"frontmatter":{"title":"通配符","comments":true,"hide":false,"abbrlink":"aecba7e5","date":"2022-12-06T16:18:35.000Z","updated":"2022-12-06T16:18:35.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/通配符.md","filePath":"posts/通配符.md"}'),r={name:"posts/通配符.md"};function s(n,l,o,p,u,c){return a(),e("div",null,l[0]||(l[0]=[i('<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>开发中常用到各种通配符，目前通配符规范较多，有linux通配符，也有nodejs通配符。简单记录一下区别和各自的使用场景，</p><h1 id="linux通配符" tabindex="-1">linux通配符 <a class="header-anchor" href="#linux通配符" aria-label="Permalink to &quot;linux通配符&quot;">​</a></h1><ul><li>* 匹配零个或者多个字符，但是不匹配&quot;.&quot;开头的文件, 也不会匹配/之外的内容（限制在单个路径）</li><li>? 匹配任何单个字符</li><li>~yang 用户杨根目录</li><li>[0-9] 匹配0-9 一次</li><li>[!0-9] 不匹配0-9一次</li></ul><p>linux是先匹配再执行。比如touch *.txt。先匹配发现没有则不执行。</p><p>touch {1..9}.txt 先解开大括号创建1到9的txt</p><p>后来bash又在这个基础上扩展了几个语法</p><ul><li>** 跨目录匹配，也是先按照目录展开模式再匹配 ls <em>/</em>.* 和 ls **/<em>.</em> 有区别</li><li>{a,b,c} 重复执行匹配模式，先展开大括号再执行*等匹配</li><li>{a..c} 重复执行a到c之间的匹配模式</li><li>?(parttern-list) 匹配一次括号里面的模式</li><li>*(parttern-list) 匹配0次或者多次</li><li>+(parttern-list) 匹配一次或者多次</li><li>@(parttern-list) 匹配一次</li><li>!(parttern-list) 不匹配</li></ul><p>回到开头node中大部分都使用的是扩展后的语法，而且是自行实现，不和平台挂钩。但是我们在命令行中执行命令时根据使用shell的版本，有可能没有实现一些扩展语法</p><p>比如在rimraf中删除东西 rimraf **/node_modules 有可能就不会删除，因为没有实现** 语法。</p><p>还有一个坑是npm中执行脚本，npm执行脚本不一定会在当前的shell执行，有可能会在其他的shell。就会出现glob语法和在命令行执行不一致的情况，比如上面的rimraf。 大部分工具目前都是用的自定义的glob，通过将glob用引号包裹起来可以避免shell的glob模式</p><p><a href="https://medium.com/@jakubsynowiec/you-should-always-quote-your-globs-in-npm-scripts-621887a2a784" target="_blank" rel="noreferrer">npm 中一定要用引号包裹</a></p>',12)]))}const _=t(r,[["render",s]]);export{m as __pageData,_ as default};
