import{_ as a,c as e,o as r,ah as o}from"./chunks/framework.BurO9VyR.js";const b=JSON.parse('{"title":"栈内存还是堆内存","description":null,"frontmatter":{"title":"栈内存还是堆内存","comments":true,"hide":false,"abbrlink":"baf4fca4","date":"2023-03-24T17:06:13.000Z","updated":"2023-03-24T17:06:13.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/栈内存还是堆内存.md","filePath":"posts/栈内存还是堆内存.md"}'),l={name:"posts/栈内存还是堆内存.md"};function s(n,t,i,h,p,c){return r(),e("div",null,t[0]||(t[0]=[o('<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>相信很多小伙伴在学习基础类型和引用类型时经常看到一些文章介绍。基础类型保存在栈内存中，引用类型保存在堆内存中，然后栈内存是一个关联数组的结构，里面保存了变量名和值的映射关系。其中基础类型的直value 直接是值</p><table tabindex="0"><thead><tr><th>变量名</th><th>值</th></tr></thead><tbody><tr><td>a</td><td>0x111111</td></tr><tr><td>b</td><td>0x111112</td></tr></tbody></table><p>引用类型保存的是指向的堆内存地址。然后具体的值在堆内存中。当变量赋值时，就是将栈内存的值复制到另一个变量。堆内存是一个无序的结构，栈内存时一个固定长度的结构，value固定是8b（这也是number 类型64位双精度的由来）</p><p>看完这些介绍，难道小伙伴没有疑问吗，</p><ol><li>为什么要用栈内存，栈不是先进后出的结构吗，如何做到快读的查找。</li><li>如果堆内存中某个属性又是个基础类型，这个基础类型又保存在哪儿?</li><li>比如在全局申明一个var a = 1，应该保存在栈内存中吧，但是window.a 也等于1，又应该保存在堆内存中。这就矛盾了。</li></ol><h3 id="js中的栈内存和堆内存" tabindex="-1">js中的栈内存和堆内存 <a class="header-anchor" href="#js中的栈内存和堆内存" aria-label="Permalink to &quot;js中的栈内存和堆内存&quot;">​</a></h3><p>栈内存是一个线性的、规则的、大小基本固定的、有序的排列起来的一块块内存空间，每个单元大小固定，规则有序的排列下来。栈内存由系统自动分配。Boolean、Null、Undefined、Number保存在栈类型中 同学们会有误解为什么要采用栈内存啊，其实栈内存和栈没什么关系，只是借用了c++中的指针是按照栈来保存的，查找时不会先出栈在读取，而是一种具有hash结构映射关系，所以不要纠结了。</p><p>堆内存是无序的结构，长度大小也不固定，只能通过地址索引到。</p><h3 id="为什么string内保存很长" tabindex="-1">为什么string内保存很长 <a class="header-anchor" href="#为什么string内保存很长" aria-label="Permalink to &quot;为什么string内保存很长&quot;">​</a></h3><p>栈内存照理只有64位，保存字符串按理上不会太长。实际字符串值也是保存的指向另一个空间的内存地址（我还不知道是啥空间，就是称为系统）。当需要一个字符串时，字符串空间就会申请一个地址来保存字符串，同时栈内存中指向这个地址，类似于引用类型。这也是为什么我们在repeat函数中，尽量减少字符串拼接。</p><p><strong>找到了找到了，大佬的文章</strong><br><a href="https://www.51cto.com/article/694979.html" target="_blank" rel="noreferrer">https://www.51cto.com/article/694979.html</a></p><p>当我们声明一个字符串时：</p><ol><li><p>v8内部有一个名为stringTable的hashmap缓存了所有字符串，在V8阅读我们的代码，转换抽象语法树时，每遇到一个字符串，会根据其特征换算为一个hash值，插入到hashmap中。 在之后如果遇到了hash值一致的字符串，会优先从里面取出来进行比对，一致的话就不会生成新字符串类。</p></li><li><p>缓存字符串时，根据字符串不同采取不同hash方式。</p></li></ol><p>所以让我们梳理一下，在我们创建字符串的时候，V8会先从内存中（哈希表）查找是否有已经创建的完全一致的字符串，如果存在，直接复用。如果不存在，则开辟一块新的内存空间存进这个字符串，然后把地址赋到变量中。这也是为什么我们不能直接用下标的方式修改字符串: V8中的字符串都是不可变的。</p><h3 id="最终结论" tabindex="-1">最终结论 <a class="header-anchor" href="#最终结论" aria-label="Permalink to &quot;最终结论&quot;">​</a></h3><p>从来就没有栈内存，永远都是堆内存。下面是V8 引擎的官方讲解</p><blockquote><p>JavaScript values in V8 are represented as objects and allocated on the V8 heap, no matter if they are objects, arrays, numbers or strings. This allows us to represent any value as a pointer to an object.</p></blockquote><h3 id="后文" tabindex="-1">后文 <a class="header-anchor" href="#后文" aria-label="Permalink to &quot;后文&quot;">​</a></h3><p>其实掌握这些知识没有什么作用，对于写代码没什么帮助，但是在设计到buffer编程时，可能会有些困惑。</p><p><a href="https://mdnice.com/writing/7bc5fe7ffba2434c8eb997af03420ed3" target="_blank" rel="noreferrer">https://mdnice.com/writing/7bc5fe7ffba2434c8eb997af03420ed3</a><br><a href="https://www.cnblogs.com/Qooo/p/13685207.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/Qooo/p/13685207.html</a><a href="https://www.51cto.com/article/694979.html" target="_blank" rel="noreferrer">https://www.51cto.com/article/694979.html</a></p>',21)]))}const m=a(l,[["render",s]]);export{b as __pageData,m as default};
