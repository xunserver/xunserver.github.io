import{_ as t,c as o,o as n,j as a,a as r}from"./chunks/framework.BurO9VyR.js";const u=JSON.parse('{"title":"form-data的故事","description":null,"frontmatter":{"title":"form-data的故事","comments":true,"hide":false,"abbrlink":"ff59502f","date":"2022-11-28T10:42:02.000Z","updated":"2022-11-28T10:42:02.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/form-data的故事.md","filePath":"posts/form-data的故事.md"}'),s={name:"posts/form-data的故事.md"};function d(l,e,m,c,i,p){return n(),o("div",null,e[0]||(e[0]=[a("h3",{id:"介绍",tabindex:"-1"},[r("介绍 "),a("a",{class:"header-anchor",href:"#介绍","aria-label":'Permalink to "介绍"'},"​")],-1),a("p",null,"前端请求中经常碰到content-type，主要需要关注的是以下几种 application/json 请求以json的形式上传，后端需要按照的json的方式解析body application/x-www-form-urlencoded 按照key=name&key=name的形式将参数拼接在body中。其中key和name需要用URLSearchParams处理(不能用urlEncodeComponent是历史遗留原因，application/x-www-form-urlencoded 需要将空格转义成+，urlEncodeComponent将空格转义成%20) multipart/form-data boundary=xxxx 将请求按照xxxx分隔包围，每一段包括一个字段. 其中每一个keyvalue 也需要转义（空格转+）,这一块比较奇怪",-1)]))}const x=t(s,[["render",d]]);export{u as __pageData,x as default};
