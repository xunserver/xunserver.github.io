import{_ as i,c as a,o as n,ah as l}from"./chunks/framework.BurO9VyR.js";const g=JSON.parse('{"title":"模块联邦","description":null,"frontmatter":{"title":"模块联邦","comments":true,"hide":false,"abbrlink":"eb9216b6","date":"2022-10-27T11:01:53.000Z","updated":"2022-10-27T11:01:53.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/模块联邦.md","filePath":"posts/模块联邦.md"}'),h={name:"posts/模块联邦.md"};function p(t,s,k,e,r,E){return n(),a("div",null,s[0]||(s[0]=[l(`<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>模块联邦提供了一种运行时的加载其他服务下模块的能力,通过下面几个问题来解决生产中模块联邦的问题</p><ol><li>模块联邦在项目源码中并不会体现，如果packageA引入了packageB，如何保证自动补全、ts类型等功能</li><li>项目工程化如何设计，单仓库还是多仓库，项目如何启动</li><li>开发环境和线上环境如何设计</li><li>和微服务框架如何结合</li></ol><h3 id="webpack中的模块联邦" tabindex="-1">webpack中的模块联邦 <a class="header-anchor" href="#webpack中的模块联邦" aria-label="Permalink to &quot;webpack中的模块联邦&quot;">​</a></h3><p>webpack中通过MF插件提供了简单配置容器和加载容器的功能</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack.config.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    plugins: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> webpack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ModuleFederationPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main_app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 本身对外暴露出的入口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;remoteEntry.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入口文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        exposes: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &#39;./functionA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./src/xxx/a.js&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 暴露出的文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        share: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 共享的模块， 不会重复打包</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        remote: {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需要加载的远程package</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &#39;packageB&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;packageB@http://localhost:3001/remoteEntry.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })]  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在packageA中使用packageB的方法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> functionA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;packageB/functionA&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(functionA)</span></span></code></pre></div><h2 id="模块联邦" tabindex="-1">模块联邦 <a class="header-anchor" href="#模块联邦" aria-label="Permalink to &quot;模块联邦&quot;">​</a></h2><p>模块联邦提供了加载其他模块的能力，可以用于跨项目共享chunk。</p><ul><li>本地模块指的是入口文件构建的模块，远程模块是MF定义出的。相当于共享配置的两个入口文件。</li><li>每个构建都是一个容器，容器可以加载远程模块。</li><li>远程模块需要使用异步的方式加载。</li><li>远程模块也可以作为容器加载其他远程模块。</li><li>远程模块中，因为publicPath是简单的拼接，如果设置了publicPath会出现加载宿主域的问题。需要将publicPath设置为auto或则动态设置。</li><li>远程模块至少会生成runtime、remote和module 3种chunk文件</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MF</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> webpack.container.ModuleFederationPlugin;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 打包逻辑 runtime -&gt; remote.js -&gt; ./componentA</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;remote&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 远程模块名称</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;remote.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成的远程模块文件，用于宿主容器加载</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      runtime: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;remote.runtime.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认情况下runtime文件生成在filename 定义的文件中，可以单独抽离出来。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      exposes: [{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;./componentA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./src/componentA.vue&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 需要使用./前缀，host 通过 import(&#39;remote/componentA&#39;)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;src/componentA/index.js&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // import(&#39;remote&#39;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="动态设置publicpath" tabindex="-1">动态设置publicPath <a class="header-anchor" href="#动态设置publicpath" aria-label="Permalink to &quot;动态设置publicPath&quot;">​</a></h3><p>因为runtime.js 需要加载remote.js和module.js 所以需要提前设置publicPath。MF在打包时如果container chunk和入口chunk同名，会合并。所以需要将name设置为一个入口name相同。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  entry: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    main: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./index.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    remote: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./public-path.js&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 在入口文件中配置动态的js。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;remote&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 远程模块名称</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;remote.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成的远程模块文件，用于宿主容器加载</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      runtime: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;remote.runtime.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认情况下runtime文件生成在filename 定义的文件中，可以单独抽离出来。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      exposes: [{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;./componentA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./src/componentA.vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;src/componentA/index.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="动态加载远程模块" tabindex="-1">动态加载远程模块 <a class="header-anchor" href="#动态加载远程模块" aria-label="Permalink to &quot;动态加载远程模块&quot;">​</a></h3><p>正常情况下远程模块是在webpack配置中制定的，可以手动实现远程模块的加载。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">containerName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadScript</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url);   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载remoteEntry js 脚本。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window[containerName];  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认情况下remoteEntry 按照var 导出。 通过window containerName 可以获取到container。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> factory</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// get方法是一个异步的方法，获取的是modules里的value。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行一次相当于执行了module文件。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上面代码不够完整，缺少共享模块的加载以及重复引用下module不是单例问题。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> remoteModuleCache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">containerName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(container, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadScript</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url);   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载remoteEntry js 脚本</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __webpack_init_sharing__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;default&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 全局初始化共享模块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window[containerName];  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认情况下remoteEntry library 按照var 导出。 通过window containerName 可以获取到container。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__webpack_share_scoped__.default)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> factory</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// get方法是一个异步的方法，获取的是modules里的value。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行一次相当于执行了module文件。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="远程模块加载流程" tabindex="-1">远程模块加载流程 <a class="header-anchor" href="#远程模块加载流程" aria-label="Permalink to &quot;远程模块加载流程&quot;">​</a></h3><ol><li><strong>webpack_modules</strong> 声明了remoteEntry入口文件。</li><li>通过__webpack_require__.e 调用 __webpack__require.f.remote 中间件加载入口js文件。</li><li>入口js文件加载好后，在全局暴露remote变量</li><li>host中加载远程模块的module会固定编译成 一个chunkid，</li><li>host 会调用remote去获取这个chunkId对应的js文件，</li><li>加载完成后回调在remote中，然后host执行这个remote中的回调函数得到module。</li></ol><h3 id="远程模块踩坑" tabindex="-1">远程模块踩坑 <a class="header-anchor" href="#远程模块踩坑" aria-label="Permalink to &quot;远程模块踩坑&quot;">​</a></h3><ol><li>远程模块的异步chunk加载方式务必不要和host应用雷同，会出现覆盖host modules问题。大坑，使用 output.chunkLoadingGlobal、output.uniquename修改</li><li>目前自动加载远程模块的方式仅默认方式能生效，即把远程模块绑定到全局变量上。其他的方式均需要自行加载远程模块</li></ol><h3 id="在vite中使用模块联邦" tabindex="-1">在vite中使用模块联邦 <a class="header-anchor" href="#在vite中使用模块联邦" aria-label="Permalink to &quot;在vite中使用模块联邦&quot;">​</a></h3><p>vite社区已经实现@originjs/vite-plugin-federation, 配置方式和webpack差不多</p><h3 id="如何保证packageb的自动补全" tabindex="-1">如何保证packageB的自动补全 <a class="header-anchor" href="#如何保证packageb的自动补全" aria-label="Permalink to &quot;如何保证packageB的自动补全&quot;">​</a></h3><p>有如下两种场景，一是packageB和packageA使用了pnpm的monorepo的方案，一种是packageB在另一个地方。第一种场景比较简单，直接在pnpm add packageB作为packageA为依赖，编辑器中就能获得所有补全，但是需要引入的packageB和源码结构类似。虽然在packageA中引用了packageB，但是并不会真正打包，这种情况存在路径映射的问题（通过package新特性支持，通过exports指明对应文件的type,这种方式需要在tsconfig中指定moduleRelution为我为Node16 或者nodenext）。第二种情况是packageB不和packageA在同一个仓库，需要对packageB进行申明文件构建，申明文件选择一个新的目录，在packageA的tsconfig中正常添加这个申明文件的引用，通过typeRoot添加一个。通过设置rootDir还能实现对第一种方案中路径映射的调整</p><h3 id="单仓库还是多仓库" tabindex="-1">单仓库还是多仓库 <a class="header-anchor" href="#单仓库还是多仓库" aria-label="Permalink to &quot;单仓库还是多仓库&quot;">​</a></h3><p>新项目无脑单仓库，自带补全功能美滋滋。</p><p>但是模块联邦目前不能很好的和monorepo结合，比如monorepo引用的是packageB的dist后的代码，但是模块联邦需要的是源码方便调试（也可以只把申明文件输出到dist目录中），两者存在冲突。模块联邦的这种黑科技方式对项目也是破坏性，所以还是推荐自行添加types到packageA的依赖中（生成声明文件时，声明文件也可以添加resouremap选项也能重定向到源代码，这个特性重要重要重要，需要珍藏）</p><h3 id="开发环境和线上环境的结合" tabindex="-1">开发环境和线上环境的结合 <a class="header-anchor" href="#开发环境和线上环境的结合" aria-label="Permalink to &quot;开发环境和线上环境的结合&quot;">​</a></h3><p>模块联邦主要的组件和复用，非应用的复用。在monorepo开发环境中，删除对模块联邦的使用，使用packageA打包packageB依赖（因为已经申明了packageB，可以放心大胆的删除），这个好处是不用启用多个服务，一个服务解决。</p><h3 id="和微服务框架如何结合" tabindex="-1">和微服务框架如何结合 <a class="header-anchor" href="#和微服务框架如何结合" aria-label="Permalink to &quot;和微服务框架如何结合&quot;">​</a></h3><p>微服务框架主要是对应用的复用和嵌套，模块联邦目前未能做到样式隔离等功能，只做到了加载器的功能。同时微服务对monorepo本地线上双模式支持也较弱。目前不考虑强行将微服务转换为模块联邦（一定不要）</p><h3 id="模块联邦如何动态设置publicpath" tabindex="-1">模块联邦如何动态设置publicPath <a class="header-anchor" href="#模块联邦如何动态设置publicpath" aria-label="Permalink to &quot;模块联邦如何动态设置publicPath&quot;">​</a></h3><p>模块联邦中，如果子应用简单的设置了publicPath，不管是相对还是绝对路径都是对于主应用而言，这种情况下需要动态的配置publicPath使子应用正常。第一个方法是设置子应用的publicPath为auto。或者通过__webpack_public_path 动态设置，具体看webpack那篇博客</p>`,37)]))}const o=i(h,[["render",p]]);export{g as __pageData,o as default};
