import{_ as i,c as a,o as n,ah as t}from"./chunks/framework.BurO9VyR.js";const g=JSON.parse('{"title":"Vue查漏补缺（二）几个响应式的原理","description":null,"frontmatter":{"title":"Vue查漏补缺（二）几个响应式的原理","comments":true,"hide":false,"abbrlink":"b534a667","date":"2023-02-23T14:05:48.000Z","updated":"2023-02-23T14:05:48.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/Vue查漏补缺（三）$set 和 array原理.md","filePath":"posts/Vue查漏补缺（三）$set 和 array原理.md"}'),e={name:"posts/Vue查漏补缺（三）$set 和 array原理.md"};function h(l,s,p,k,r,E){return n(),a("div",null,s[0]||(s[0]=[t(`<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>记录一下源码中响应式几个忽略的点</p><h3 id="get和set中的ob" tabindex="-1">get和set中的ob <a class="header-anchor" href="#get和set中的ob" aria-label="Permalink to &quot;get和set中的ob&quot;">​</a></h3><p>有两个地方会收集依赖，第一个是在defineReactive时，这个场景是某个属性发生变化时set中dep.notify()，第二个是在observer对象内部，用于手动更新依赖。ob.dep.notify()</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj[key]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> childOb </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _value.__ob__</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, key, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    enumerable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    configurable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Dep.target) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dep.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">depend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (childOb) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          childOb.dep.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">depend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于$set</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_value)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dependArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于array的push等方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="set" tabindex="-1">$set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;$set&quot;">​</a></h3><p>set绑定在this上面和Vue静态属性上，是一个和实例不太有关系的方法，在实例的开始-beforeCreate阶段执行(stateMixin中执行) this.$set(target, key, value)</p><ol><li>判断target是否是对象或者数组，如果是其他的，打印警告不处理</li><li>如果是数组，判断添加的key是否超长，超长则更新数组length，然后通通按照splice来更新数据（因为数组的splice是魔改的，也能实现响应式）</li><li>对象则需要不能直接对vm.$data 进行操作，也不能对未响应的target进行操作，如果是未响应的数据直接赋值即可</li><li>满足条件的对象，使用defineProperty来添加响应式</li><li>最后调用的target上的dep，通知整个target更新，使用了之前的<strong>ob</strong>.dep.notify()</li></ol><h3 id="array魔改" tabindex="-1">array魔改 <a class="header-anchor" href="#array魔改" aria-label="Permalink to &quot;array魔改&quot;">​</a></h3><p>array上面能够原地修改的方法有sort,reverse, splice 和几个队列栈相关的操作。其实只用关心对数组值新增的值的添加响应式</p><ol><li>初始化数组的响应式和对象差不多，通过对索引依次调用observe，建立响应式逻辑。</li><li>在初始化数组响应式时，如果数组存在上面原型的方法，重写当前方法，将添加的每个值变成响应式。</li><li>通知<strong>ob</strong>.dep.notify() 更新</li></ol><h3 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h3><p>watch算是比较简单的，有两种使用方法，在选项中声明watch，二是在原型上面this.$watch 动态声明。watch申明了一个user-watcher, user-watcher会对一个响应式对象进行监听(get)，在update中将新值和旧值传递给回调函数。属于最简单的watcher应用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Watcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, getter, cb)</span></span></code></pre></div><p>关键就是这个getter，当执行时，当前全局的Dep.target指向的是当前这个watcher，当getter里面数据变化时，当前这个watcher就会执行, 当watcher初始化时，会立即执行一次来天添加依赖。当依赖变化时会执行watcher.update(), 添加到异步队列，异步队列又会添加到nexttick中依次执行watcher.run,watcher.run 会执行cb(this.getter())</p><p>cb(this.getter())，无论是会有两个执行，render-watcher 就是放在this.getter()触发的updateComponent(), 同理computed也是没有CB只有getter</p><p>源码中可以发现，还支持sync参数，不讲watcher添加到任务队列，直接更新</p><h3 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h3><p>computed同理，外号computed-watcher, 和watcher区别是拼接getter函数不一样，getter里面可能会涉及对多个getter对象读取，所以也具有if里面的语句如果第一次未收集不会添加到依赖项中, computed懒实现原理是</p><h3 id="nexttick" tabindex="-1">nexttick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;nexttick&quot;">​</a></h3><p>如果想要获取更新的dom，需要用到该api。nexttick实际就是将代码放置到当前周期最后通过微任务或者宏任务添加。nexttick 函数返回一个promise对象，表示当前这个回调执行完毕</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ is an alias to /src</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HelloWorld </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/components/HelloWorld.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;HomeView&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      msg: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    HelloWorld,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;123&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      debugger</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 理论上这个debugger时界面应该是白屏</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 实际上debugger不会阻止渲染线程，还是alert大爷出马</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;HelloWorld&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { props: { msg: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.msg } }, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {}, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vNode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="异步队列" tabindex="-1">异步队列 <a class="header-anchor" href="#异步队列" aria-label="Permalink to &quot;异步队列&quot;">​</a></h3><p>会将所有set中触发的watcher添加到异步队列中，如果watcher已经存在在队列中，放置到队列最后。异步队列的执行总是在当前周期优先通过nexttick（）添加。</p><h3 id="forceupdate" tabindex="-1">$forceUpdate() <a class="header-anchor" href="#forceupdate" aria-label="Permalink to &quot;$forceUpdate()&quot;">​</a></h3><p>同步的执行当前异步队列并清空（不是删除nexttick中执行函数，只是清空），注意同步，意味着不需要再使用nexttick 就能获取更新后dom</p><p>上面的理解是错误的， 并不是同步的，forceUpdate只是让当前Vue实例上的所有watcher.upadte(将自身添加到异步队列中，无论对应的依赖是否有更新),话说一个组件中也不会有太多watcher</p><h3 id="事件原理" tabindex="-1">事件原理 <a class="header-anchor" href="#事件原理" aria-label="Permalink to &quot;事件原理&quot;">​</a></h3><p>主要是通过对模版的分析转换成vnode，vnode中通过on和nativeOn分别放入componentOptions, 在组件实例化时，如果是原生事件，在转换到dom时添加到dom上面，如果是自定义事件，直接走的Vue.prototype.$on监听(和代码中自定义事件差不多)</p>`,29)]))}const c=i(e,[["render",h]]);export{g as __pageData,c as default};
