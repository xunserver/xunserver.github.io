import{_ as a,c as t,o,ah as i}from"./chunks/framework.BurO9VyR.js";const h=JSON.parse('{"title":"doc 和 git submodule","description":null,"frontmatter":{"title":"doc 和 git submodule","comments":true,"hide":false,"abbrlink":"7bf438f9","date":"2022-12-02T17:31:02.000Z","updated":"2022-12-02T17:31:02.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/doc和git submodule.md","filePath":"posts/doc和git submodule.md"}'),d={name:"posts/doc和git submodule.md"};function l(u,e,r,s,m,n){return o(),t("div",null,e[0]||(e[0]=[i('<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>由于搞了一些开源工具，需要一个统一的文档管理，入了vitepress写文档的坑。目前的开源内容有一系列的config文件，集中在@xunserver/config 这个仓库中，通过pnpm管理，每个包都有自己的reameme.md 和changelog.md。 还有个仓库存放了icon,style和vui的代码，目前有下面的痛点。</p><ol><li>doc是一个单独仓库只存放文档，文档中还需要引入各个包的readme.md已经changelog。</li><li>除了changelog外，对vui的还需要进行组件的引入，对于style还需要样式的引入。</li><li>目前的doc和vui存放在一起通过pnpm的方式引入。</li></ol><h3 id="git-submodule" tabindex="-1">git submodule <a class="header-anchor" href="#git-submodule" aria-label="Permalink to &quot;git submodule&quot;">​</a></h3><p>git submodule 相当于将某个仓库的某个commit作为模块添加项目中，而且对项目透明，项目本身不能去修改。</p><h4 id="git-submodule-add" tabindex="-1">git submodule add <a class="header-anchor" href="#git-submodule-add" aria-label="Permalink to &quot;git submodule add&quot;">​</a></h4><p>添加submodule到项目中，执行后git 会下载子模块到项目中。同时生成.gitmodule文件来记录关系</p><h4 id="git-submodule-init" tabindex="-1">git submodule init <a class="header-anchor" href="#git-submodule-init" aria-label="Permalink to &quot;git submodule init&quot;">​</a></h4><p>根据.gitmodule文件下载子项目，通常用来父项目第一次拉取后</p><h4 id="git-submodule-deinit" tabindex="-1">git submodule deinit <a class="header-anchor" href="#git-submodule-deinit" aria-label="Permalink to &quot;git submodule deinit&quot;">​</a></h4><p>清空子项目代码但是不删除.gitmodule中的关系</p><h4 id="git-submodule-update" tabindex="-1">git submodule update <a class="header-anchor" href="#git-submodule-update" aria-label="Permalink to &quot;git submodule update&quot;">​</a></h4><p>根据.gitmodule 中记录的子项目的commit下载子项目的代码，通过git submodule update --remote 总是根据远端的来下载。通常情况下如果子项目更新后，父项目能够感知到子项目的最新commit，并且会生成一个差异文件，如果差异文件被提交。另一个合作伙伴需要根据最新的commit的下载代码</p><h4 id="git-submodule-foreach" tabindex="-1">git submodule foreach <a class="header-anchor" href="#git-submodule-foreach" aria-label="Permalink to &quot;git submodule foreach&quot;">​</a></h4><p>批量操作子项目，git submodule foreach &quot;echo $name&quot;</p><h4 id="git-rm-path" tabindex="-1">git rm path <a class="header-anchor" href="#git-rm-path" aria-label="Permalink to &quot;git rm path&quot;">​</a></h4><p>删除子项目</p><h3 id="解决办法" tabindex="-1">解决办法 <a class="header-anchor" href="#解决办法" aria-label="Permalink to &quot;解决办法&quot;">​</a></h3><p>doc文档有两种情况是需要更新的</p><ol><li>相关的readme或者组件变更，doc本身无需变更。这种情况doc设置一个每天自动重新构建即可。</li><li>doc本身需要变更，变更部分内容。这种需要doc发布后触发重新构建</li><li>手动更新</li></ol><h3 id="doc文档" tabindex="-1">doc文档 <a class="header-anchor" href="#doc文档" aria-label="Permalink to &quot;doc文档&quot;">​</a></h3><p>doc文档使用的vitepress, 可以在文档中直接引入vue3代码，同时还支持markdown引用。这两个可以引入其他的包的说明文档和vui组件的文档。</p>',22)]))}const b=a(d,[["render",l]]);export{h as __pageData,b as default};
