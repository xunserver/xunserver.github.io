import{_ as t,c as e,o as l,ah as o}from"./chunks/framework.BurO9VyR.js";const d=JSON.parse('{"title":"python学习笔记1","description":null,"frontmatter":{"title":"python学习笔记1","comments":true,"hide":false,"abbrlink":"5a7e895a","date":"2023-09-07T09:26:48.000Z","updated":"2023-09-07T09:26:48.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/python 学习笔记（一）.md","filePath":"posts/python 学习笔记（一）.md"}'),i={name:"posts/python 学习笔记（一）.md"};function r(s,a,n,h,p,u){return l(),e("div",null,a[0]||(a[0]=[o(`<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>通过提问的方式来街道python的疑惑</p><h3 id="python-中命名空间、作用域-包、模块的关系" tabindex="-1">python 中命名空间、作用域， 包、模块的关系 <a class="header-anchor" href="#python-中命名空间、作用域-包、模块的关系" aria-label="Permalink to &quot;python 中命名空间、作用域， 包、模块的关系&quot;">​</a></h3><p>命名空间是名字到变量的映射，全局（模块）命名空间、局部（函数）命名空间和内置命名空间（各种内置变量），通过locals()、globals() 获取命名空间（会将所有的变量映射成字典）。内置命名空间不能直接获取，只能通过dir(<strong>buildIn</strong>)获取变量列表</p><p>作用域在很多语言都有，各个语言也大差不差。通俗理解就是你想看的代码文本区块能够访问命名空间有哪些。在查找某个变量是总是按照局部作用域-&gt;闭包作用域-&gt;全局作用域-&gt;内置作用域来查找。</p><p>包和模块都是一个对象，所有申明在模块的变量其实都是模块的属性，模块中内置了很多属性和方法，都是在模块加载解释器注入到其中的。</p><p>模块的初始化: 当碰到Import语句时，解释器会生成一个模块对象（实际是一个命名空间），包括全局空间和内置空间。然后添加<strong>name</strong>到模块对象中，然后依次执行代码，添加局部空间。最后import 就会得到这个对象，注意的是模块默认情况下只会导入一次</p><h3 id="变量、对象和值" tabindex="-1">变量、对象和值 <a class="header-anchor" href="#变量、对象和值" aria-label="Permalink to &quot;变量、对象和值&quot;">​</a></h3><p>python 一切都是对象，常见的数字、字符串、函数、类、集合、列表等都是对象。对象在内存会占据一块区域，下面是对象的一个列子。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type: &quot;int&quot;</span></span>
<span class="line"><span>value: 1,</span></span>
<span class="line"><span>id: &quot;xxasfsafas1231&quot;</span></span></code></pre></div><p>其中对象有区分可变对象和不可变对象，不可变对象有数字、字符串、元组等。意思是创建成功后值不可变化，可变对象值得是创建成功后值是可变的。通过 id(xxx)可以获取对象的内存空间值</p><p>值其实就是对象的一个属性，第一种是对象的值空间直接保存原始的值，另外就是值空间保存其他若干对象的引用。</p><p>变量实际一个指针，保存在栈空间，总是会指向对象的内存空间上。</p><p>举一些列子来理解这些概念</p><h4 id="值-1-和-对象-1-有啥区别-代码中-a-1-是啥" tabindex="-1">值 1 和 对象 1 有啥区别， 代码中 a = 1 是啥 <a class="header-anchor" href="#值-1-和-对象-1-有啥区别-代码中-a-1-是啥" aria-label="Permalink to &quot;值 1 和 对象 1 有啥区别， 代码中 a = 1 是啥&quot;">​</a></h4><p>值 1 就是简单表示值是 1，对象 1 值得是一个对象，对象是有上面的特性，值 1 只是对象 1 的一个特性。 a = 1 首先创建了一个对象 1（如果之前没有创建过），把值设置成 1，type 是 int ，id 设置对象当前的内存地址，同时创建一个变量，变量保存在栈空间，变量的值指向了对象 1 的 id。 如果再写 b = 1，这个时候不会再创建对象 1，而是直接复用，应为是不可变类型</p><h4 id="为什么-1-1-1-is-1-true。" tabindex="-1">为什么 1 == 1, 1 is 1 == true。 <a class="header-anchor" href="#为什么-1-1-1-is-1-true。" aria-label="Permalink to &quot;为什么 1 == 1, 1 is 1 == true。&quot;">​</a></h4><p>弄清这个问题首先要搞清 == 是计算符，计算符的行为是可以被定义的。1 == 1 只是判断的值是不是相同，显然同一个对象的值是相同的， 1 is 1 是判断内存地址是否相同。 对于对象来说，总是全局唯一的，所以也是相同。</p><h3 id="弄清-python-中标识符、保留标识符、关键字" tabindex="-1">弄清 python 中标识符、保留标识符、关键字 <a class="header-anchor" href="#弄清-python-中标识符、保留标识符、关键字" aria-label="Permalink to &quot;弄清 python 中标识符、保留标识符、关键字&quot;">​</a></h3><p>曾经我以为 type 是关键字，除了常见的关键字，列一些容易搞错的。</p><ul><li>in</li><li>is</li><li>nonlocal</li><li>global</li><li>None</li><li>yield</li><li>with</li></ul><p>保留的标识符有</p><ul><li><p>__ 不会被 import _ 导入（不过我们从不用 import * 导入）</p></li><li><p>__ 双下划线用在类中会被解析器重命名成 <em>classname__name，避免子类覆盖，但是__*|</em>_除外（__init__）</p></li><li><p>__*__ 表示魔法方法，作为未来 python 的扩展，比如 __call__, __init__, __class__</p></li></ul><h3 id="格式化字符串" tabindex="-1">格式化字符串 <a class="header-anchor" href="#格式化字符串" aria-label="Permalink to &quot;格式化字符串&quot;">​</a></h3><p>现在只推荐 f 函数，之前 format 等等都不要再使用。repr 用于输出 python 解释器识别的，str 用于输出用户识别的内容， 比如 repr(&quot;1&quot;)会输出 &quot;1&quot;(带引号)，而 str 只会输出 1。 举例一些少见而有用的技巧</p><ol><li><blockquote><p>f&quot;{a=}&quot; 或者 {sum(2)=} // 输出 a=1 sum(2)=22</p></blockquote></li><li><blockquote><p>:表示格式化内容 :2f 保留两位小数（不四舍五入）:.3% 保留 3 位小数的% :_ 分隔符，除了前面保留的几个特殊字符都可以。当然也能自由组合 :_.4f, :e 科学计数法 :.2e 保留两位小数的科学计数法</p></blockquote></li><li><blockquote><p>格式化时间 f{a:%Y/%m/%d}</p></blockquote></li><li><blockquote><p>文本对齐 f&quot;a:&gt;n&quot; 文本前面插入空格，文本后面补齐空格</p></blockquote></li></ol><h3 id="推导式" tabindex="-1">推导式 <a class="header-anchor" href="#推导式" aria-label="Permalink to &quot;推导式&quot;">​</a></h3><p>推导式通过执行一系列的循环用于快速的创建序列，按照语法糖来理解。我们要求无脑使用推导式,当然表达式性能也是有问题，会全部计算出来。不如 推导式总是按照 表达式 + 一层一层的 for 语句或者 if 语句。执行过程是 for if 执行完后执行 表示表达式，通过是</p><ul><li>列表推导 <ul><li>创建 [x * 2 for x in range(5)] [x for x in range(10) if x % 2 == 0]</li></ul></li><li>字典推导式 {x: x + 1 for x in range(5) }</li></ul><h3 id="切片" tabindex="-1">切片 <a class="header-anchor" href="#切片" aria-label="Permalink to &quot;切片&quot;">​</a></h3><p>用的最多在列表， [start🔚step] 每个参数都可以忽略返回 start 默认列表初始 end 默认列表 len, step 默认 1，负数时需要翻转。始终是 start+step 获取下一个索引，如果 start+step 不在区间内，始终返回[] 切片总是返回一个浅拷贝，同时切片也能作为一个独立对象，表示原对象的一部分，比如 a[:0] 表示的是列表开头 a[:0] = [1,2] 这样就能插入 1,2 到列表最开始</p><p>替换元素的执行逻辑是把起始索引到解锁索引的元素删除，再添加到起始位置。</p><h3 id="序列" tabindex="-1">序列 <a class="header-anchor" href="#序列" aria-label="Permalink to &quot;序列&quot;">​</a></h3><p>字符串、元组、字节串（不可变序列），列表、字节数组（不可变序列），怎么理解不可变序列， 比如你改动 a = &quot;abc&quot;，想把&quot;abc&quot;改成了&quot;abb&quot;,一定是创建了一个新的对象，而不是在原有的对象上改动的</p><h3 id="描述器" tabindex="-1">描述器 <a class="header-anchor" href="#描述器" aria-label="Permalink to &quot;描述器&quot;">​</a></h3><h3 id="可迭代对象" tabindex="-1">可迭代对象 <a class="header-anchor" href="#可迭代对象" aria-label="Permalink to &quot;可迭代对象&quot;">​</a></h3><h3 id="hash-和字典的关系" tabindex="-1">hash 和字典的关系 <a class="header-anchor" href="#hash-和字典的关系" aria-label="Permalink to &quot;hash 和字典的关系&quot;">​</a></h3><p>字典内部使用了 hash 表的方式来查询键。</p><h3 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h3><h4 id="函数是怎么创建出来的" tabindex="-1">函数是怎么创建出来的 <a class="header-anchor" href="#函数是怎么创建出来的" aria-label="Permalink to &quot;函数是怎么创建出来的&quot;">​</a></h4><p>函数也是一个对象，这个对象有<strong>call</strong>方法，同理函数的生成也是元类在处理</p><h4 id="函数中有用的特殊属性-为什么会有这些特殊的属性-怎么来的" tabindex="-1">函数中有用的特殊属性，为什么会有这些特殊的属性，怎么来的 <a class="header-anchor" href="#函数中有用的特殊属性-为什么会有这些特殊的属性-怎么来的" aria-label="Permalink to &quot;函数中有用的特殊属性，为什么会有这些特殊的属性，怎么来的&quot;">​</a></h4><ul><li><strong>doc</strong> 获取文档字符串, 也能获取模块的</li><li><strong>name</strong> 函数名称</li><li><strong>qualname</strong> 函数在调用时的层级名字 xx.xx.xx.name</li><li><strong>defaults</strong> 默认参数组元组，</li><li><strong>dict</strong> 命名空间中属性</li><li><strong>annotations</strong> 获取参数的注解</li></ul><h3 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-label="Permalink to &quot;class&quot;">​</a></h3><h4 id="super-详解" tabindex="-1">super 详解 <a class="header-anchor" href="#super-详解" aria-label="Permalink to &quot;super 详解&quot;">​</a></h4><h4 id="class-怎么来的" tabindex="-1">class 怎么来的 <a class="header-anchor" href="#class-怎么来的" aria-label="Permalink to &quot;class 怎么来的&quot;">​</a></h4><p>当解释器碰到class的申明时，会创建一个命名空间，同时添加默认的变量<strong>name</strong> <strong>class</strong> <strong>base</strong>等，同时会添加class的元类，用于如何实例化这个类，可以看到class本身也就是一个稍微特殊的对象，我们可以自由的定义class定义和最终实例的各个步骤</p><h4 id="type" tabindex="-1">type <a class="header-anchor" href="#type" aria-label="Permalink to &quot;type&quot;">​</a></h4><p>type是所有的class默认的元类，type 本身也是一个对象，同时也是一个可执行的对象，通常type(xxx)获取对象的类型，总是会调用这个对象的类对象的元类型的<strong>call</strong>方法。按照下面来执行</p><ol><li>检查obj是否有一个名为<strong>class</strong>的属性，并且这个属性是一个类对象。</li><li>如果满足条件，直接返回obj.<strong>class</strong>。</li><li>如果不满足条件，继续执行下一步。</li><li>检查obj的类对象是否有一个名为<strong>class</strong>的属性，并且这个属性是一个类对象。</li><li>如果满足条件，直接返回obj.<strong>class</strong>.<strong>class</strong>。</li><li>如果不满足条件，继续执行下一步。</li><li>返回type(obj)，即obj的类对象的元类。</li></ol><h3 id="执行帧、代码块和小数据池" tabindex="-1">执行帧、代码块和小数据池 <a class="header-anchor" href="#执行帧、代码块和小数据池" aria-label="Permalink to &quot;执行帧、代码块和小数据池&quot;">​</a></h3><h3 id="python-中的对象是怎么来的-a-1-干了嘛" tabindex="-1">python 中的对象是怎么来的 a = 1 干了嘛 <a class="header-anchor" href="#python-中的对象是怎么来的-a-1-干了嘛" aria-label="Permalink to &quot;python 中的对象是怎么来的 a = 1 干了嘛&quot;">​</a></h3><p>添加一个a到命名空间，直接在小数据块中获取一个对象1，然后将a执行a对应的内存空间，简单理解成a -&gt; id(1)</p><h3 id="with-详解" tabindex="-1">with 详解 <a class="header-anchor" href="#with-详解" aria-label="Permalink to &quot;with 详解&quot;">​</a></h3><p>上下文管理器是一个对象，包含了__enter__ 和__exit 方法。with 语句能够自动的调用这些方法</p><h3 id="类型系统" tabindex="-1">类型系统 <a class="header-anchor" href="#类型系统" aria-label="Permalink to &quot;类型系统&quot;">​</a></h3><p>typing.get_type_hints 能够获取 class,function 和模块中注解，当然也默认给其提供了__annotations__属性</p><h3 id="模拟容器" tabindex="-1">模拟容器 <a class="header-anchor" href="#模拟容器" aria-label="Permalink to &quot;模拟容器&quot;">​</a></h3><p>官方内置了一些容器对象，比如元组、列表、字典、</p><h3 id="常见的变量和属性" tabindex="-1">常见的变量和属性 <a class="header-anchor" href="#常见的变量和属性" aria-label="Permalink to &quot;常见的变量和属性&quot;">​</a></h3><ul><li>__dict__</li><li>__name__</li><li>__module__</li></ul><h3 id="全局函数" tabindex="-1">全局函数 <a class="header-anchor" href="#全局函数" aria-label="Permalink to &quot;全局函数&quot;">​</a></h3>`,62)]))}const _=t(i,[["render",r]]);export{d as __pageData,_ as default};
