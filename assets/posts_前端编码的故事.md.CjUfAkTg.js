import{_ as a,c as t,o as i,ah as l}from"./chunks/framework.BurO9VyR.js";const p=JSON.parse('{"title":"前端编码的故事","description":null,"frontmatter":{"title":"前端编码的故事","comments":true,"hide":false,"abbrlink":"5f877c4e","date":"2020-02-18T14:51:19.000Z","updated":"2020-02-18T14:51:19.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/前端编码的故事.md","filePath":"posts/前端编码的故事.md"}'),o={name:"posts/前端编码的故事.md"};function r(n,e,s,c,d,u){return i(),t("div",null,e[0]||(e[0]=[l('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>本文记录自己理解 ascii、unicode、utf-8 的含义和区别</p><h3 id="ascii-编码" tabindex="-1">ascii 编码 <a class="header-anchor" href="#ascii-编码" aria-label="Permalink to &quot;ascii 编码&quot;">​</a></h3><p>ascii 编码使用一个字节代表一个字符，比如 <code>A</code>，二进制就是 <code>0100 0001</code>，十进制就是 <code>65</code>。目前来说 ascii 只有 128 个字符，所以第一位都统一为 <code>0</code></p><h3 id="unicode-编码" tabindex="-1">unicode 编码 <a class="header-anchor" href="#unicode-编码" aria-label="Permalink to &quot;unicode 编码&quot;">​</a></h3><p>ascii 编码只有 128 种状态，表示英语字符能够，但是表示其他国家语言字符时就不够用， 所以 unicode 编码就是在 ascii 上面扩展到多个字节。所以 unicode 编码将世界上所有符号包括在内。</p><p>unicode 只是定义的符号集，但是有些字符需要多字节存储。这个时候有个问题，如何区分多个独立字节表示的多个符号还是表示的一个符号。 有个解决方式都统一成 4 字节或者更高，这个也有个问题是，英语字符需要一个字节，补位会导致存储空间明显变大。</p><p>所有的字符均可通过\\u0000到\\uFFFF来表示,在html中技用&amp;#+10进制来表示 比如&#39;1&#39;表示1或者 \\u0031</p><h3 id="utf-8" tabindex="-1">utf-8 <a class="header-anchor" href="#utf-8" aria-label="Permalink to &quot;utf-8&quot;">​</a></h3><p>为了解决这个问题，出现 UTF-8、UTF-16、UTF-32 这些解决方案。大部分 unicode 字符都是 2 字节<br> UTF-8 是一种可变长得编码方式， 可以使用 1-4 个字节来表示一个符号。编码规则只有两条</p><ol><li>如果是单字节，第一位是 0，剩下用 unicode 编码补齐</li><li>如果字节是 n(n&gt;1), 前 n 位 1，n+1 位 0, 剩下的每个字节的前两位一律 10， 没有提及的位数使用 unicode 编码补全，</li></ol><p>浏览器中有encodeurl和encodeurlComponent两种编码方法，前面那个对大部分保留字都不转义，后面的是严格转义</p><h3 id="base64" tabindex="-1">base64 <a class="header-anchor" href="#base64" aria-label="Permalink to &quot;base64&quot;">​</a></h3><p>将二进制从左到右按照3个字节为一组，不满一组的补全0，分成4个 * 6位的数据， 每个前面补全两个0 变成4字节。再将四个字节转换成10进制，按照base64编码表，拼接成字符。存在只有一个字节不能凑成3 * 8 的情况，在后面添加一个或者两个字节，添加了字节后会出现一个或者两个 * 6的情况，这种情况使用=输出。下面对0进行base64编码</p><ol><li>&#39;0&#39;.charCodeAt() =&gt; 48 =&gt; 48.toString(2) =&gt; &quot;00110000&quot;</li><li>补全 3 * 8 =&gt; 00110000 | 00000000 | 00000000 =&gt; 明确有两个字节补全添加两个 =</li><li>调整成 4 * 6 001100 | 000000 | 000000 | 000000 =&gt; 注意第二个000000不是补全来的</li><li>再将 4 * 6 前面添加两位0 补全到 4 * 8 001100 | 0000000 .....</li><li>换成成10进制 parseInt(&#39;00001100&#39;, 10) =&gt; 12 | 0 | 0 | 0</li><li>根据base64映射表M | A | = | = 最终的结果就是 MA==</li></ol><p>base64由于将3 * 8变成了4 * 8，至少扩大了33%的大小（还有尾部额外的==补全），根据映射表来看组成总是大小写+数字+ &quot;+/=&quot;这三类 base64中有/ + = 这对url不友好的字符，所有也有一种url_safe的base64，将/+转换成其他的，将== 取消（因为base64总是4个倍数，不满足的解码时补全）</p><h3 id="urlencode-编码方式" tabindex="-1">urlencode %编码方式 <a class="header-anchor" href="#urlencode-编码方式" aria-label="Permalink to &quot;urlencode  %编码方式&quot;">​</a></h3><p>url中所有字符必须要是asscii字符集中，而且还需要除去保留字，比如?=#等在url有特殊意义的字符，所以需要通过转义的方式来表达。 url中字符就分为保留字符和非保留字符以及在这两个之外的%。 非保留字符: asscii码中字符，不做处理 保留字符: url中定义的保留字符，将保留字符的拆分成两个16进制表示，再添加%。</p><h3 id="html中的转义" tabindex="-1">html中的转义 <a class="header-anchor" href="#html中的转义" aria-label="Permalink to &quot;html中的转义&quot;">​</a></h3><p>html因为将一些符号作为了特殊符号，比如&lt;&gt; = &quot; &quot; &#39;&#39;这些，在html中使用需要转义。所以要想在html中显示&lt;&gt;都需要用转义的方式表达，html中转义基本都是&amp;开头;结尾。浏览器未提供api实现，可通过he.js实现普通字符向html编码转换的过程</p>',20)]))}const m=a(o,[["render",r]]);export{p as __pageData,m as default};
