import{_ as a,c as i,o as t,ah as n}from"./chunks/framework.BurO9VyR.js";const k=JSON.parse('{"title":"tsconfig.json","description":null,"frontmatter":{"title":"tsconfig.json","comments":true,"hide":false,"abbrlink":"727f02b2","date":"2025-02-17T21:47:54.000Z","updated":"2025-02-17T21:47:54.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/tsconfig-json.md","filePath":"posts/tsconfig-json.md"}'),e={name:"posts/tsconfig-json.md"};function p(l,s,o,r,h,d){return t(),i("div",null,s[0]||(s[0]=[n(`<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>最近vscode总是类型检查报各种奇怪的错误，严重不符合预期。重新研究下这块的配置。想起什么写什么，这块场景比较多，别名叠加monorepo后更是难以理解，里面的坑特别多。</p><h3 id="npx-执行方式" tabindex="-1">npx 执行方式 <a class="header-anchor" href="#npx-执行方式" aria-label="Permalink to &quot;npx 执行方式&quot;">​</a></h3><p>从当前目录向上一直查询node_module/.bin 查询命令。如果查询不到则下载命令到一个tmp。执行tmp中命令，执行后删除。</p><h4 id="什么是tsc根目录" tabindex="-1">什么是tsc根目录 <a class="header-anchor" href="#什么是tsc根目录" aria-label="Permalink to &quot;什么是tsc根目录&quot;">​</a></h4><p>当tsc 不指定tsconfig.json 运行时，默认查找当前执行目录最近的tsconfig.json</p><ol><li>tsc运行时的目录 (不是)</li><li>tsconfig.json 所在的目录 （正确）</li><li>tsconfig.json中baseUrl 指的目录。（不是）</li></ol><h4 id="types-和-typeroots" tabindex="-1">types 和 typeRoots <a class="header-anchor" href="#types-和-typeroots" aria-label="Permalink to &quot;types 和 typeRoots&quot;">​</a></h4><p>tsc启动时默认会查询项目根目录（项目根目录参考上面）以及祖先目录所有的node_modules/@types/* 目录中所有的<strong>软件包</strong></p><p>typeRoots 指定查询的目录，当目录至少存在一个时才生效。否则会回退默认配置</p><p>types 指定@types中哪些目录会被加载。同上当目录至少存在一个时才会生效，否则回退。</p><h4 id="rootdir-和-rootdirs" tabindex="-1">rootDir 和 rootDirs <a class="header-anchor" href="#rootdir-和-rootdirs" aria-label="Permalink to &quot;rootDir 和 rootDirs&quot;">​</a></h4><p>前者用于所有输入文件的最长路径，默认是自动计算的。 比如下面计算出路径是core/，当编译输出到outDir 会输出dist/a.js，会忽略前面core。如果想要保留core,把rootDir 修改成&quot;./&quot; 即可。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MyProj</span></span>
<span class="line"><span>├── tsconfig.json</span></span>
<span class="line"><span>├── core</span></span>
<span class="line"><span>│   ├── a.ts</span></span>
<span class="line"><span>│   ├── b.ts</span></span>
<span class="line"><span>│   ├── sub</span></span>
<span class="line"><span>│   │   ├── c.ts</span></span>
<span class="line"><span>├── types.d.ts</span></span></code></pre></div><p>rootDirs 用于虚拟目录，可以将两个在不同目录中文件，视为在一个目录。比如下a.ts 可以使用import b from &quot;./b&quot;</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rootDirs: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./core1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./core2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MyProj</span></span>
<span class="line"><span>├── tsconfig.json</span></span>
<span class="line"><span>├── core1</span></span>
<span class="line"><span>│   ├── a.ts</span></span>
<span class="line"><span>├── core2</span></span>
<span class="line"><span>│   ├── b.ts</span></span>
<span class="line"><span>├── types.d.ts</span></span></code></pre></div><h3 id="tsc如何加载软件包" tabindex="-1">tsc如何加载软件包 <a class="header-anchor" href="#tsc如何加载软件包" aria-label="Permalink to &quot;tsc如何加载软件包&quot;">​</a></h3><h3 id="tsc中import-语句" tabindex="-1">tsc中import 语句 <a class="header-anchor" href="#tsc中import-语句" aria-label="Permalink to &quot;tsc中import 语句&quot;">​</a></h3><h3 id="模块解析" tabindex="-1">模块解析 <a class="header-anchor" href="#模块解析" aria-label="Permalink to &quot;模块解析&quot;">​</a></h3><p>如果tsconfig中moduleResolution: Node 时，按照node的模块查找规则。查找规则按照path+place 的方式</p><p>path是相对或者绝对路径时，直接按照路径解析。相对路径不包含 &#39;xx/xxx&#39; path是动态路径时，比如** import xx from &#39;xx&#39; **。从当前文件开始查找同级目录是否存在node_modules/xx。</p><p>place规则如下</p><ul><li>xx.ts</li><li>xx 中存在package.json 而且存在package.types所指的文件或者exports.types指定的文件</li><li>@types/xx</li><li>xx/index.ts</li></ul><p>同时针对文件扩展名，按照.ts .tsx .d.ts 顺序解析。</p><p>另外还可以通过修改设置baseUrl和paths 映射来修改这种行为。默认情况下只要设置了baseUrl,paths会默认添加 { &quot;<em>&quot;: [&quot;./</em>&quot;] } 配置</p><p>如果想追踪每个module的解析情况，可以使用traceResolution: true 打印解析日志 tsc编译时会从入口文件开始，将相关的依赖文件同时编译。如果配置了noResolve选项指定了某些模块不编译，编译会报错。</p><p>从变量引用和类型引用两个角度分析。<br> 变量角度</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// test.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 1. 寻找是否能根据baseUrl和paths匹配到模块 2.依次向上查询node_modules/a是否存在 3.如果是文件夹，先检查package.json描述,如果package.json 不存在，检查index.ts 是否存在。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a/b&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 1. 同上 2. 检查node_modules/a/b 是否存在。 3. 同上3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./c&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 1. 检查是否配置了rootDirs。 2. ./c是否是文件夹，如果是参考1.3 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;d.xx&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 1. 同上1</span></span></code></pre></div><p>类型角度</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// test.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 1. 寻找是否能根据baseUrl和paths匹配到模块,a.ts存在，直接导出a.ts的命名空间,如果只有a.js存在，需要查找a.d.ts，如果a.d.ts未查找到，同时allowJS: false，在查询是否存在当前module的 declararion 声明，查找终止。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                       // 2. 向上查找node_modules/a.d.ts，如果是文件夹，先查找package.json相关定义，再查找node_modules/a/index.d.ts。再加载同级@types/a 文件夹，按照上述步骤处理。 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a/b&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 1. 同上1 2.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./c&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 1. 同上述文件夹处理方式 2. 检查是否有declaration 声明</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./d.xx&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 后缀当做文件名处理</span></span></code></pre></div><h3 id="vscode中typescript" tabindex="-1">vscode中typescript <a class="header-anchor" href="#vscode中typescript" aria-label="Permalink to &quot;vscode中typescript&quot;">​</a></h3><p>npm i -D typescript后。会安装typescript/core、tsc和tsserver。其中tsserver负责对vscode工作区文件的检查</p><h3 id="declare" tabindex="-1">declare <a class="header-anchor" href="#declare" aria-label="Permalink to &quot;declare&quot;">​</a></h3><ol><li>当一个d.ts 不存在export 或者import 会被视为全局文件。通过declare定义都是全局的，否则就是局部的。</li><li>namespace 理解成同一个文件中的模块化。里面的定义需要通过export 导出。否则也是局部的。</li></ol><h3 id="vscode检查ts-结论" tabindex="-1">vscode检查ts 结论 <a class="header-anchor" href="#vscode检查ts-结论" aria-label="Permalink to &quot;vscode检查ts  结论&quot;">​</a></h3><ol><li>每次点开一个ts文件时，tsserver会使用这个文件最近tsconfig.json 文件，如果这个配置文件包含这个文件。则使用这个文件的规则。</li><li>如果这个tsconfig.json 不包含这个文件，比如被排除或者不在include范围内。就会使用项目根目录的tsconfig.json</li><li>如果项目根目录的tsconfig.json 也不包含这个文件。则会使用tsserver 默认的规则检查。</li></ol><h3 id="vscode检查js" tabindex="-1">vscode检查js <a class="header-anchor" href="#vscode检查js" aria-label="Permalink to &quot;vscode检查js&quot;">​</a></h3><p>如果开启allowjs会按照上面检查ts的流程检查，如果没有会按照先查询tsconfig.json ，再查询jsconfig.json 逻辑。</p><h3 id="引用资料" tabindex="-1">引用资料 <a class="header-anchor" href="#引用资料" aria-label="Permalink to &quot;引用资料&quot;">​</a></h3><ul><li><p><a href="http://juejin.cn/post/7221551421833314360?searchId=202502191856115A9601FB9377EC637D4F" target="_blank" rel="noreferrer">moduleResolution 总结</a></p></li><li><p><a href="https://juejin.cn/post/7276408879364948028?searchId=20250219134755EDE684372A97F44D1BAB#heading-16" target="_blank" rel="noreferrer">tsconfig 的魔鬼——module 和 moduleResolution</a></p></li></ul>`,41)]))}const g=a(e,[["render",p]]);export{k as __pageData,g as default};
