import{_ as i,c as e,o as r,ah as l}from"./chunks/framework.BurO9VyR.js";const u=JSON.parse('{"title":"前端需要了解的网络知识","description":null,"frontmatter":{"title":"前端需要了解的网络知识","comments":true,"hide":false,"abbrlink":"cd116c88","date":"2022-01-12T03:42:04.000Z","updated":"2022-01-12T03:42:04.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/dhcp 和 arp.md","filePath":"posts/dhcp 和 arp.md"}'),p={name:"posts/dhcp 和 arp.md"};function t(n,a,d,o,h,c){return r(),e("div",null,a[0]||(a[0]=[l('<h3 id="dhcp" tabindex="-1">dhcp <a class="header-anchor" href="#dhcp" aria-label="Permalink to &quot;dhcp&quot;">​</a></h3><p>DHCP（dynamic host configuration protocol）动态主机配置协议。是一个应用层协议，用于给dhcp客户端配置ip，网关，dns等。</p><h4 id="首次dhcp" tabindex="-1">首次DHCP <a class="header-anchor" href="#首次dhcp" aria-label="Permalink to &quot;首次DHCP&quot;">​</a></h4><ol><li>客户端广播DISCOVER，要求当前广播域中的服务器提供可用的IP。</li><li>服务端广播OFFER，提供可选的IP。</li><li>客户端选择一个可用的IP，广播REQUEST，提示服务端已经选择某个OFFER，给我保留一下。</li><li>服务端收到REQUEST后，记录已经分配的IP，并广播ACK。</li><li>客户端收到ACK后，设置IP。</li></ol><h4 id="释放ip" tabindex="-1">释放IP <a class="header-anchor" href="#释放ip" aria-label="Permalink to &quot;释放IP&quot;">​</a></h4><ol><li>客户端单播发送RELEASE，目标地址时DHCP服务端</li><li>服务收到，释放IP</li></ol><h4 id="续租" tabindex="-1">续租 <a class="header-anchor" href="#续租" aria-label="Permalink to &quot;续租&quot;">​</a></h4><ol><li>租期50%时（T1），客户端会单播发送REQUEST，服务端单播ACK，续租成功。如果服务端单播回复NAK，会重新走DISCOVER流程请求新的IP</li><li>如果T1时发送的包REQUEST未得到回应，会在87.5%时，发送第二次RESQUEST，流程同第一次</li><li>如果租期到了，REQUEST还未得到回应，走DISCOVER流程</li></ol><h4 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h4><ul><li>配置默认网关</li><li>配置主备DNS服务器</li><li>配置开始的IP池，结束IP池</li></ul><h4 id="从dhcp服务器" tabindex="-1">从DHCP服务器 <a class="header-anchor" href="#从dhcp服务器" aria-label="Permalink to &quot;从DHCP服务器&quot;">​</a></h4><p>同一个广播域中可以存在多个DHCP服务器，所以DHCP流程有4步，不是2步。OFFER就相当于保价并保留短暂时间，如果客户端发起的REQUEST相当于通知其他DHCP没选择他们的OFFER。在多个dhcp 的子网环境中，dhcp客户端会选择最先收到的dhcp offer</p><h3 id="arp" tabindex="-1">arp <a class="header-anchor" href="#arp" aria-label="Permalink to &quot;arp&quot;">​</a></h3><p>arp协议稍微简单，是二层协议。流程如下，设备A需要向设备B发送数据 设备A不知道设备B的mac地址， 设备A发送arp广播，问 谁是ip 192.168.2.99的机器，请告诉我的你的mac地址。 并携带了自己的mac地址和ip<br> 局域网中的其他设备也会收到这个消息，发现消息自己不匹配，舍弃掉。<br> 局域网中的设备B发现自己匹配，向设备A发送单播我就是ip 192.168.2.99的机主，我的mac是xxxx。同时将设备A的ip和mac记录到arp缓存表中。<br> 设备A接受到单播，更新自己的arp表。</p><h4 id="arp缓存表" tabindex="-1">arp缓存表 <a class="header-anchor" href="#arp缓存表" aria-label="Permalink to &quot;arp缓存表&quot;">​</a></h4><p>当设备A知道了设备B的ip和mac，会缓存一段时间（180s），后续的请求不会再arp查询直到过期。</p><h4 id="arp-声明" tabindex="-1">arp 声明 <a class="header-anchor" href="#arp-声明" aria-label="Permalink to &quot;arp 声明&quot;">​</a></h4><p>有时候设备也会自己广播自己的arp地址和ip，特别是设备知道自己的ip时候。 arp announcement 报文</p><h3 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h3><p>dns分为迭代查询和递归查询。迭代查询是指自己去查询ip，递归查询是指你的dns服务器帮你做查询。</p><h3 id="ip和路由" tabindex="-1">IP和路由 <a class="header-anchor" href="#ip和路由" aria-label="Permalink to &quot;IP和路由&quot;">​</a></h3><p>IP地址32位，一个字节为一组一共4组，按照点分十进制表示为192.168.2.9形式，IP按照有类地址和无类地址的方式划分。</p><p>有类地址分为A(0开头的地址),B(10)开头,C(110开头)，通过256 - 掩码 可以确定区块大小，或者通过掩码0的个人确定大小。 192.168.2.98/26 的区块大小是64。分别是0 64 96 128。 192.168.2.98就在 192.168.2.96~192.168.2.127中，这个子网中子网地址是192.168.2.96，广播地址192.168.2.127</p><p>同时也有变长的子网规划方式，192.168.2.0/24 下可以规划25 25 27掩码的子网，需要注意的变长子网的规划时，子网的开头也必须遵循从0开始的等比序列，即不能出现192.168.2.98/26这种方式，只能是192.168.2.96/26</p><p>ip报文中包含源ip和目的ip，根据目的IP去匹配当前路由表中的子网，如果路由表中多条记录命中了子网，以最小网段为准。</p><p>比如 192.168.1.9这个目的ip可能位于 192.168.1.0/25 也可能位于 192.168.1.8/29</p><h3 id="交换机如何处理帧" tabindex="-1">交换机如何处理帧 <a class="header-anchor" href="#交换机如何处理帧" aria-label="Permalink to &quot;交换机如何处理帧&quot;">​</a></h3><p>帧有单播帧和广播帧，单播帧是指定目的mac，广播帧是的目的mac是ff:ff:ff:ff:ff:ff。交换机有多个端口，同时保存了端口-mac映射表。当一条记录在表不存在是，交换器会将这条数据转发到所有端口中，与交换机相连的设备会检查目的mac是否和自己的匹配，如果不匹配则放弃该帧，等到真正的设备接受到消息时会回复帧，交换机总是会把端口传入帧的源mac记录到表中。当交换机接收到广播帧时，交换机会将广播帧转发到每个端口发送出去。</p><h3 id="交换机的vlan" tabindex="-1">交换机的vlan <a class="header-anchor" href="#交换机的vlan" aria-label="Permalink to &quot;交换机的vlan&quot;">​</a></h3><p>一般有两种vlan划分的方法， 第一个是基于端口的vlan, 802.q协议作为支持。第二个是基于mac地址的vlan。主要学习802.q的vlan。帧里面有个4字节表示tag，交换机有3中端口，access(用于交换机和终端连接)，trunk(交换机之间连接),hybrid(access和trunk的混合)。交换机内部的转发的帧都是带有tag，每个端口都是有一个缺省的vlan id，也称为pvid，同时默认情况下也会将缺省的vid设置为允许通过（不管是发送还是接受）的tag。 access 1. 接受untag包，会添加pvid，然后交给交换机内部交换 2. 接收tag包，会和pvid 对比，如果相同通过，不相同则舍弃 3. 发送包，总是将tag去掉，发送出去</p><p>trunk 1. 接收untag包，添加pvid，检查pvid是否在允许通过的vlan列表中（一般都是允许，除非pvid不在允许的列表中） 2. 直接对比tag包是否在允许的vlan id 中，在走转发 3. 如果vlan id 和 pvid 相同，untag发出，否则带tag发出</p><p>hybird 1. untag 和 trunk 相同 2. 和 trunk 相同 3. 是否untag可以随意指定</p><h3 id="ipv6-入门" tabindex="-1">IPV6 入门 <a class="header-anchor" href="#ipv6-入门" aria-label="Permalink to &quot;IPV6 入门&quot;">​</a></h3><p>ipv6 是由128位组成，一般采用16进制的:分隔为8组，每组16位，用4个16进制组成。其中如果某个区段全是零，可以省略，但是只能省略一次，一个区段中的前置0可以省略。ipv6前面48位是组织前缀，中间16位是subnet掩码位（6w多个子网），后面64位是主机号（euid: 通过网卡48位在中间插入0xff）</p><p>FE80/10 （链路本地地址） FC00/7 （全局唯一本地） 2000/3 (全局单播)，比如2400(亚太前缀)</p><p>一般移动的运营商会分配一个前缀60或者56，局域网中机器自行设置64即可。</p>',36)]))}const P=i(p,[["render",t]]);export{u as __pageData,P as default};
