import{_ as l,c as p,o as e,ah as n,j as i,t,a as h}from"./chunks/framework.BurO9VyR.js";const c=JSON.parse('{"title":"vue3进阶","description":null,"frontmatter":{"title":"vue3进阶","comments":true,"hide":false,"abbrlink":"9a707413","date":"2022-06-12T15:37:53.000Z","updated":"2022-06-12T15:37:53.000Z","tags":null,"categories":null,"description":null},"headers":[],"relativePath":"posts/vue3进阶.md","filePath":"posts/vue3进阶.md"}'),k={name:"posts/vue3进阶.md"};function r(a,s,E,d,g,o){return e(),p("div",null,[s[3]||(s[3]=n("",17)),i("ol",null,[s[0]||(s[0]=i("li",null,'声明在顶层作用域的ref在模板中会自动解包，:count="count" 相当于:count="count.value" 子组件收到的是原始值， 不是ref对象。 state.count 就不能自动解包， 因为只有state是顶层对象',-1)),i("li",null,t(a.xxx)+" 模板计算值如果是一个ref，会自动解包 "+t(a.count)+" 不需要使用count.value",1),s[1]||(s[1]=i("li",null,"如果一个ref是reactive 对象（不包括数组和其他集合类型set，map）的property， 那么和普通的property表现相同， 会自动解包",-1))]),s[4]||(s[4]=n("",41)),i("ol",null,[s[2]||(s[2]=i("li",null,[i("p",null,[i("code",null,"<CustomComp count />"),h(" 实际是"),i("code",null,"<CustomComp count='' />"),h("的缩写，所以除了boolean类型总是会得到一个空字符串,boolean 类型在收到一个''或者undefined时会触发default")])],-1)),i("li",null,[i("p",null,"模板中可以自动使用prop属性，比如上面的count, 可以直接"+t(a.count)+"，实际上也是宏的作用，在解析模板时，如果是变量是setup定义的，会使用ctx.count, 如果是宏定义的会使用宏的props.count, 如果都没定义使用ctx.count",1)])]),s[5]||(s[5]=n("",73))])}const F=l(k,[["render",r]]);export{c as __pageData,F as default};
