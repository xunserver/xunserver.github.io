<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bang</title>
  
  <subtitle>生活总会有惊喜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xunserver.cn/"/>
  <updated>2022-02-24T22:40:45.000Z</updated>
  <id>https://blog.xunserver.cn/</id>
  
  <author>
    <name>yangmanman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cookie</title>
    <link href="https://blog.xunserver.cn/archives/8ae0ba66.html"/>
    <id>https://blog.xunserver.cn/archives/8ae0ba66.html</id>
    <published>2022-02-24T22:40:45.000Z</published>
    <updated>2022-02-24T22:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在公司碰到了内嵌的iframe始终提示未登录的问题，查询到时接口请求时未自动携带cookie，排查过程中一直没搞懂cookie携带的机制。将排查后学习到总计一下。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先来几个问题</p><ol><li>cookie是怎么设置到浏览器中，设置cookie有什么限制</li><li>什么样的请求能携带cookie，能携带哪些cookie</li><li>cookie存储方式是什么</li><li>cookie 和 storeage 区别</li><li>跨域和跨站</li></ol><h2 id="跨域和跨站"><a href="#跨域和跨站" class="headerlink" title="跨域和跨站"></a>跨域和跨站</h2><p>同域: 协议、域名、端口相同，反之是跨域<br>同站: eTLD + 1, 顶级域名 + 1 相同则是同站，反之是跨站</p><h2 id="请求的场景"><a href="#请求的场景" class="headerlink" title="请求的场景"></a>请求的场景</h2><p>假设当前网站是xunserver.cn, 页面地址是<a href="http://cloud.xunserver.cn/file。这个页面发出的请求有以下几种" target="_blank" rel="noopener">http://cloud.xunserver.cn/file。这个页面发出的请求有以下几种</a></p><ol><li>同域请求，<a href="http://cloud.xunserver.cn/patha" target="_blank" rel="noopener">http://cloud.xunserver.cn/patha</a></li><li>跨域请求不跨站  <a href="https://cloud.xunserver.cn/patha" target="_blank" rel="noopener">https://cloud.xunserver.cn/patha</a> 和 <a href="http://cloud.xunserver.cn:8088/patha" target="_blank" rel="noopener">http://cloud.xunserver.cn:8088/patha</a></li><li>子域名请求 <a href="http://nps.cloud.xunserver.cn/patha" target="_blank" rel="noopener">http://nps.cloud.xunserver.cn/patha</a></li><li>跨域同时跨站 <a href="http://docker.xunserver.com/patha" target="_blank" rel="noopener">http://docker.xunserver.com/patha</a></li><li>上级域名请求 <a href="http://xunserver.cn" target="_blank" rel="noopener">http://xunserver.cn</a></li></ol><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="cookie组成"><a href="#cookie组成" class="headerlink" title="cookie组成"></a>cookie组成</h3><p>cookie 包括name, value, domain, path, expire, httpOnly, secure, samesite。</p><h3 id="cookie-如何被设置"><a href="#cookie-如何被设置" class="headerlink" title="cookie 如何被设置"></a>cookie 如何被设置</h3><p>有两种设置cookie的方法</p><ol><li>请求响应头中set-cookie</li><li>前端JS代码document.cookie。</li></ol><p>通过响应设置cookie时， domian默认是当前请求的eTLD + 1， 路径默认是/。可以设置上级域名和上级路径的cookie，如果设置子域名或者子路径，cookie设置会无效，而且会被抛弃。</p><p>document.cookie 设置和set cookie类似，前者被限制于当前文档的地址（浏览器地址栏）,而且不能设置httpOnly和secure 属性。</p><h3 id="cookie-如何被携带"><a href="#cookie-如何被携带" class="headerlink" title="cookie 如何被携带"></a>cookie 如何被携带</h3><p>当浏览器发送请求时，根据请求的场景携带cookie不同。</p><ol><li>同域请求， 自动携带当前请求所有的子域名和父路径, 会携带path=/patha、path=/ 和 domain=cloud.xunserver.cn、xunserver.cn的cookie</li><li>cookie不区分端口和协议，所以同上一致</li><li>会携带domain=nps.cloud.xunserver.cn 以及上级域名</li><li>携带domian=docker.xunserver.cn</li><li>携带domain=xunsrever.cn 不会携带cloud.xunserver.cn 域名</li></ol><h4 id="samesite-是啥"><a href="#samesite-是啥" class="headerlink" title="samesite 是啥"></a>samesite 是啥</h4><p>用户在银行登录了系统，这个时候浏览器嵌入了cookie，如果恶意网站中有一个form表单，提交地址是银行的链接，用户在点击链接后就会触发接口，因为请求携带了cookie，所以银行会判断为正常用户，从而带来不安全。或者恶意网站嵌套i银行frame，诱导用户点击，实际点击到了银行网站的接口。<br>samesite有三个值,strict, lax 和none<br>strict 表示只有请求在同站的情况下，才会携带cookie。<br>lax 表示除了a标签、预加载、get表单能cookie外，其余场景都不能携带，包括iframe<br>none 表示不限制    </p><p>samesite 如何设置，浏览器默认是lax, 匿名浏览器如果关闭第三方共享是strict。如果设置none，需要同时secure，同时在https下设置</p><h3 id="跨域如何携带cookie"><a href="#跨域如何携带cookie" class="headerlink" title="跨域如何携带cookie"></a>跨域如何携带cookie</h3><h4 id="哪些些请求能跨域"><a href="#哪些些请求能跨域" class="headerlink" title="哪些些请求能跨域"></a>哪些些请求能跨域</h4><p>link、img、script 标签支持跨域，但是new Image不支持。跨域能发送请求，但是不能解析响应。<br>其余的通过axios或者fetch发送跨域请求，<br>axios 需要添加withCredentials: true支持跨域携带cookie<br>fetch 需要添加withCredentials: include属性</p><h4 id="fetch-withCredentials解析"><a href="#fetch-withCredentials解析" class="headerlink" title="fetch withCredentials解析"></a>fetch withCredentials解析</h4><p>omit 跨域不打送cookie<br>include 总是发送<br>same-origin 同站才发送</p><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><p>localstorage 和 sessionStorage 严格按照同源原则。</p><h3 id="document-domain-用来干嘛"><a href="#document-domain-用来干嘛" class="headerlink" title="document.domain 用来干嘛"></a>document.domain 用来干嘛</h3><p>可以把父页面和iframe的domain设置成一个（都需要设置，因为document.domain调用后端口会被设置为null），父页面可以拿到iframe的window对象，从而调用iframe中的方法实现跨域。设置document.domain 仅设置自身或者上级域名，不能设置为其他或者子域名。</p><p>也可以通过window.open 获取引用</p><h3 id="如何检查浏览器同时打开多个相同页面"><a href="#如何检查浏览器同时打开多个相同页面" class="headerlink" title="如何检查浏览器同时打开多个相同页面"></a>如何检查浏览器同时打开多个相同页面</h3><p>循环检查localStorage</p><h3 id="host、referer和origin"><a href="#host、referer和origin" class="headerlink" title="host、referer和origin"></a>host、referer和origin</h3><p>host: 指向请求的host和端口号，任何请求都有<br>referer: 当前请求发起的来源，一个页面跳转到另一个页面指向的是之前的页面，页面内发起的资源请求，指向当前文档的地址，不包含hash<br>origin: 跨域请求中常见 ，指向原始</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在公司碰到了内嵌的iframe始终提示未登录的问题，查询到时接口请求时未自动携带cookie，排查过程中一直没搞懂cookie携带的机制
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>network</title>
    <link href="https://blog.xunserver.cn/archives/608487bc.html"/>
    <id>https://blog.xunserver.cn/archives/608487bc.html</id>
    <published>2022-01-26T21:55:20.000Z</published>
    <updated>2022-01-26T21:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="console-线"><a href="#console-线" class="headerlink" title="console 线"></a>console 线</h4><p>一头网线，一头usb线的线，通过串口控制设备 一般是9600 8 0 配置</p><h4 id="盒式设备、框式设备"><a href="#盒式设备、框式设备" class="headerlink" title="盒式设备、框式设备"></a>盒式设备、框式设备</h4><p>盒式设备高度按照u来分区，一般一排网口的是半U，两排是1U。框式设备是一整块机柜，包含电源主从，控制主从等。</p><h4 id="MGT端口"><a href="#MGT端口" class="headerlink" title="MGT端口"></a>MGT端口</h4><p>通过两头网线控制，笔记和管理端口同网段即可</p><h4 id="mini-console"><a href="#mini-console" class="headerlink" title="mini-console"></a>mini-console</h4><p>一头usb，另一个mini-console接口，用于控制设备</p><h4 id="telnet和ssh"><a href="#telnet和ssh" class="headerlink" title="telnet和ssh"></a>telnet和ssh</h4><p>通过应用层协议连接</p><h4 id="rs232"><a href="#rs232" class="headerlink" title="rs232"></a>rs232</h4><p>9针口，现在的都集成变成usb</p><h4 id="telnet、ssh-端口"><a href="#telnet、ssh-端口" class="headerlink" title="telnet、ssh 端口"></a>telnet、ssh 端口</h4><p>telnet 23 ssh 22</p><h4 id="ISO，OSI"><a href="#ISO，OSI" class="headerlink" title="ISO，OSI"></a>ISO，OSI</h4><p>ISO 国际标准化组织<br>OSI 开放系统互联互通模型</p><h4 id="OSI-7层模型介绍"><a href="#OSI-7层模型介绍" class="headerlink" title="OSI 7层模型介绍"></a>OSI 7层模型介绍</h4><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>物理层层面的0，1转换传输。以太帧</p><h5 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h5><p>物理上点到点的传输， Mac</p><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>节点和节点的传输。IP</p><h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>端口到端口的传输</p><h4 id="命令行权限和用户权限"><a href="#命令行权限和用户权限" class="headerlink" title="命令行权限和用户权限"></a>命令行权限和用户权限</h4><p>命令权限有0-3级， 分别是观察级、监控级、配置级和管理级<br>用户权限有0-15级  前面和命令行对应。每一级可以使用前面所有等级命令</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>用户视图  \&lt;host> 默认登录上的视图</p><p>系统视图 [host] 用户视图输入system-view 后进入</p><p>命令视图 系统视图下输入命令的视图</p><h4 id="配置ip地址"><a href="#配置ip地址" class="headerlink" title="配置ip地址"></a>配置ip地址</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system-view <span class="comment"># 系统视图</span></span><br><span class="line">interface Ethernet 0/0/8 <span class="comment"># 接口视图</span></span><br><span class="line">ip address 192.168.1.2 24 <span class="comment"># 设置ip</span></span><br></pre></td></tr></table></figure><h4 id="开启telnet-登录"><a href="#开启telnet-登录" class="headerlink" title="开启telnet 登录"></a>开启telnet 登录</h4><h5 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1. 新建用户"></a>1. 新建用户</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system-view </span><br><span class="line">aaa <span class="comment"># 进入aa模式</span></span><br><span class="line"><span class="built_in">local</span>-user <span class="built_in">test</span> password cipher <span class="built_in">test</span> <span class="comment"># 设置用户名密码</span></span><br><span class="line"><span class="built_in">local</span>-user <span class="built_in">test</span> service-type telnet <span class="comment"># 指定用户登录模式</span></span><br></pre></td></tr></table></figure><h5 id="2-分配vty"><a href="#2-分配vty" class="headerlink" title="2. 分配vty"></a>2. 分配vty</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要指定用户登录的vty</span></span><br><span class="line">system-view </span><br><span class="line">user-interface vty 0 3 <span class="comment"># vty配置模式</span></span><br><span class="line">user privil level 3 <span class="comment"># vty 用户最大权限</span></span><br><span class="line">authentication-mode aaa <span class="comment"># 设置认证方式为aaa</span></span><br></pre></td></tr></table></figure><h5 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h5><p>CU: 控制单元<br>OB: 输出缓存<br>LC: 线路编码器<br>TX: 发射器   </p><p>RX: 接收器<br>LD: 线路解码器<br>IB: 输入缓冲<br>CU从网络层获取到packet，在CU封装成frame帧，帧传递到OB，OB会按照帧的接受顺序排列成队列，依次传递到LC。LC把一个一个的帧编码成 0 1物理电平传递给TX, TX将物理的电平增加功率，发送出去双绞线。</p><p>同理，RX,LD,OB也相同。</p><p>交换机的网卡和主机网卡在CU处理方面不同，交换机接收到帧做泛洪，舍弃，点对点转发。主机网卡接收到帧后，会解开帧后转交给上层的网络层处理。</p><h5 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h5><p>MAC 地址有48位，区分为单播MAC（首字节末尾是0），组播MAC（首字节末尾是1），广播MAC（全是1，所以是一种特殊组播），网卡的MAC又称BIA地址，前24位是厂商向IEEE申请，后24位厂商自行分配。前24位是OUI地址。</p><h5 id="以太帧"><a href="#以太帧" class="headerlink" title="以太帧"></a>以太帧</h5><p>目前使用的以太帧有IEEE 802.3 和 Ethernet II 两种格式。Ethernet II格式简单使用广泛，IEEE 802.3用于某些特殊协议。</p><p>Ethernet II由以下组成，目的MAC，源MAC，2字节表示类型，载荷，和CRC校验和结尾。</p><h5 id="2的次方速记"><a href="#2的次方速记" class="headerlink" title="2的次方速记"></a>2的次方速记</h5><p>一个字节8位，两个16进制计数。<br>2 ^ 8 = 65536;2 ^ 16 = 16777216 </p><h5 id="帧的流转"><a href="#帧的流转" class="headerlink" title="帧的流转"></a>帧的流转</h5><p>帧在交换机端口中进入时，会查找MAC表中是否存在映射，不存在时执行泛洪，并保存将帧的源MAC和端口保存更新到MAC表中。MAC和端口是多对一的关系。主机MAC在接收到单播帧时，会检查BIA地址和目的MAC是否一致，如果不一致则会丢弃帧。接收到广播帧时，CU会传递到上层模块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;console-线&quot;&gt;&lt;a href=&quot;#console-线&quot; class=&quot;headerlink&quot; title=&quot;console 线&quot;&gt;&lt;/a&gt;console 线&lt;/h4&gt;&lt;p&gt;一头网线，一头usb线的线，通过串口控制设备 一般是9600 8 0 配置&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hcna</title>
    <link href="https://blog.xunserver.cn/archives/548c626e.html"/>
    <id>https://blog.xunserver.cn/archives/548c626e.html</id>
    <published>2022-01-26T21:35:23.000Z</published>
    <updated>2022-01-26T21:35:23.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dhcp</title>
    <link href="https://blog.xunserver.cn/archives/cd116c88.html"/>
    <id>https://blog.xunserver.cn/archives/cd116c88.html</id>
    <published>2022-01-11T19:42:04.000Z</published>
    <updated>2022-01-11T19:42:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DHCP（dynamic host configuration protocol）动态主机配置协议。是一个应用层协议，用于给dhcp客户端配置ip，网关，dns等。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="首次DHCP"><a href="#首次DHCP" class="headerlink" title="首次DHCP"></a>首次DHCP</h4><ol><li>客户端广播DISCOVER，要求当前广播域中的服务器提供可用的IP。</li><li>服务端广播OFFER，提供可选的IP。</li><li>客户端选择一个可用的IP，广播REQUEST，提示服务端已经选择某个OFFER。</li><li>服务端收到REQUEST后，记录已经分配的IP，并广播ACK。</li><li>客户端收到ACK后，设置IP。</li></ol><h4 id="释放IP"><a href="#释放IP" class="headerlink" title="释放IP"></a>释放IP</h4><ol><li>客户端单播发送RELEASE，目标地址时DHCP服务端</li><li>服务收到，释放IP</li></ol><h4 id="续租"><a href="#续租" class="headerlink" title="续租"></a>续租</h4><ol><li>租期50%时（T1），客户端会单播发送REQUEST，服务端单播ACK，续租成功。如果服务端单播回复NAK，会重新走DISCOVER流程请求新的IP</li><li>如果T1时发送的包REQUEST未得到回应，会在87.5%时，发送第二次RESQUEST，流程同第一次</li><li>如果租期到了，REQUEST还未得到回应，走DISCOVER流程</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>配置默认网关</li><li>配置主备DNS服务器</li><li>配置开始的IP池，结束IP池</li></ul><h3 id="从DHCP服务器"><a href="#从DHCP服务器" class="headerlink" title="从DHCP服务器"></a>从DHCP服务器</h3><p>同一个广播域中可以存在多个DHCP服务器，所以DHCP流程有4步，不是2步。OFFER就相当于保价并保留短暂时间，如果客户端发起的REQUEST相当于通知其他DHCP没选择他们的OFFER</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;DHCP（dynamic host configuration protocol）动态主机配置协议。是一个应用层协议，用于给dhcp客户端配
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>esxi入门玩法</title>
    <link href="https://blog.xunserver.cn/archives/61a1a8d1.html"/>
    <id>https://blog.xunserver.cn/archives/61a1a8d1.html</id>
    <published>2022-01-10T00:16:56.000Z</published>
    <updated>2022-01-10T00:16:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><ol><li><a href="https://customerconnect.vmware.com/downloads/#all_products" target="_blank" rel="noopener">vm下载页面</a>，搜索<code>VMware vSphere</code>下载，当前最新版本<a href="https://customerconnect.vmware.com/downloads/info/slug/datacenter_cloud_infrastructure/vmware_vsphere/7_0" target="_blank" rel="noopener">7.0</a>，下载<a href="https://customerconnect.vmware.com/en/group/vmware/evalcenter?p=free-esxi7" target="_blank" rel="noopener">Standard版本</a></li><li>使用软碟通刷入U盘，选择硬盘镜像</li><li>主板uefi下引导，安装。</li></ol><h3 id="安装黑群晖"><a href="#安装黑群晖" class="headerlink" title="安装黑群晖"></a>安装黑群晖</h3><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://customerconnect.vmware.com/downloads/#a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="https://blog.xunserver.cn/archives/f85ddf3d.html"/>
    <id>https://blog.xunserver.cn/archives/f85ddf3d.html</id>
    <published>2021-12-20T03:49:30.000Z</published>
    <updated>2021-12-20T03:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖debounce"><a href="#防抖debounce" class="headerlink" title="防抖debounce"></a>防抖debounce</h3><p>事件发生后，规定时间内只执行一次回调, 如果重复触发，会重置计时器和事件。</p><p>有立即执行和延迟执行两种方式，应用场景不同。</p><ul><li>立即执行，触发事件 -&gt; 执行回调 -&gt; 延迟。常用在输入框远程搜索。</li><li>延迟执行，触发事件 -&gt; 延时 -&gt; 执行回调。用在防止按钮重复点击</li></ul><p>实现方式如下</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>规定时间段内，只会发生一次事件，重复事件会被舍弃掉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;防抖debounce&quot;&gt;&lt;a href=&quot;#防抖debounce&quot; class=&quot;headerlink&quot; title=&quot;防抖debounce&quot;&gt;&lt;/a&gt;防抖debounce&lt;/h3&gt;&lt;p&gt;事件发生后，规定时间内只执行一次回调, 如果重复触发，会重置计时器和事件。&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>access-control</title>
    <link href="https://blog.xunserver.cn/archives/cb8b60b3.html"/>
    <id>https://blog.xunserver.cn/archives/cb8b60b3.html</id>
    <published>2021-12-17T03:39:57.000Z</published>
    <updated>2021-12-17T03:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>必须满足下列所有条件</p><ul><li>请求方法是 GET POST HEAD(只请求资源首部)</li><li>首部只能包含下面字段<ul><li>accept</li><li>accept-language</li><li>content-language</li><li>content-type</li></ul></li><li>content-type 的值只能是<ul><li><code>application/x-www-form-urlencode</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li></ul><h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3><p>不满足简单请求的都是复杂请求, 常见的复杂请求包括 content-type: applcation/json</p><h3 id="cors-cross-origin-resource-sharing-跨域资源共享"><a href="#cors-cross-origin-resource-sharing-跨域资源共享" class="headerlink" title="cors cross-origin resource sharing  跨域资源共享"></a>cors cross-origin resource sharing  跨域资源共享</h3><h4 id="简单请求-1"><a href="#简单请求-1" class="headerlink" title="简单请求"></a>简单请求</h4><p>针对简单请求，浏览器发现是跨域，会在请求中添加origin字段，如果服务端允许跨域，会返回access-control-allow-origin 字段，浏览器检测返回字段是否和当前域匹配，决定是否舍弃当前请求。</p><p>响应会返回下面3个首部字段</p><ul><li>access-control-allow-origin, 指定允许的域。只能是origin 字段或者*</li><li>access-control-allow-credentials，决定下次请求是否可以携带cookies</li><li>access-control-allow-headers, 允许浏览器额外获取的首部字段</li></ul><h4 id="复杂请求-1"><a href="#复杂请求-1" class="headerlink" title="复杂请求"></a>复杂请求</h4><p>针对复杂请求浏览器会先发送预检请求(options)，检查当前请求能否跨域，允许的字段等。<br>浏览器发送预检查请求，包括Origin,access-control-request-method（表示当前请求的方法）,access-control-allow-Headers(表示当前请求额外的首部字段)</p><p>服务端根据预检请求，会返回origin，access-control-allow-methods（表示允许的方法），用逗号分隔access-control-allow-headers(表示允许的首部字段)（逗号分隔），浏览器会检查，如果和当前匹配，则会发送正式请求。</p><p>为了避免浏览器每次需要预检请求，还会同时返回access-control-max-age(秒), 表示有效期内不用发送预检请求。如果一个请求背、被预检通过，会走简单请求的流程，如果这个时候被简单请求拦截， 也不会成功</p><h4 id="nginx-配置cors"><a href="#nginx-配置cors" class="headerlink" title="nginx 配置cors"></a>nginx 配置cors</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">'POST,DELETE,OPTIONS'</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Max-Age: <span class="number">7200</span></span><br><span class="line">    add_header Aceess-Contorl-Allow-Headers <span class="string">'Cache-Control,Keep-Alive,If-Modified-Since,Content-Type,Authorization'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者单独对options 请求配置<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    if($request_method = 'OPTIONS) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">'GET,POST,PUT,DELETE,OPTIONS'</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Header <span class="string">'Cache-control,If-Modified-Since,If-None-Matched,Authorization,Content-Type'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单请求&quot;&gt;&lt;a href=&quot;#简单请求&quot; class=&quot;headerlink&quot; title=&quot;简单请求&quot;&gt;&lt;/a&gt;简单请求&lt;/h3&gt;&lt;p&gt;必须满足下列所有条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求方法是 GET POST HEAD(只请求资源首部)&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx之location</title>
    <link href="https://blog.xunserver.cn/archives/e22c93eb.html"/>
    <id>https://blog.xunserver.cn/archives/e22c93eb.html</id>
    <published>2021-12-15T14:31:27.000Z</published>
    <updated>2021-12-15T14:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows-安装"><a href="#windows-安装" class="headerlink" title="windows 安装"></a>windows 安装</h3><p>windows 直接下载官方二进制包，添加到环境变量</p><h3 id="其他版本安装"><a href="#其他版本安装" class="headerlink" title="其他版本安装"></a>其他版本安装</h3><p>官网download下面有个平台的快捷安装方法</p><h3 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h3><p>需要注意的是配置转发的时候不是127.0.0.1（因为指向的是nginx容器本身）</p><h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><p>指定配置文件运行</p><blockquote><p>nginx -f xxx.conf </p></blockquote><p>检查配置</p><blockquote><p>nginx -t 检查配置文件<br>nginx -T 检查并输出配置文件</p></blockquote><p>重启、停止</p><blockquote><p>nginx -s restart<br>nginx -s stop </p></blockquote><p>systemctl 管理</p><blockquote><p>systemctl start nginx<br>systemctl stop nginx<br>systemctl restart nginx</p></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h4><p>server_name 支持精准匹配、通配符，正则匹配（^）开头。</p><h3 id="location-语法"><a href="#location-语法" class="headerlink" title="location 语法"></a>location 语法</h3><p>location [= | ^~ | ~* | ~ ] xxx</p><ul><li>= 精准匹配优先级最高。</li><li>^~ 前缀匹配, 按照最长的前缀匹配，如果命中，则会阻止正则，但不会组织普通路径</li><li>~ 区分大小写的正则匹配，正则匹配只要命中就生效。</li><li>~* 不区分大小写的正则匹配</li><li>不加符号，表示前缀匹配, 采用最长匹配</li><li>/ 兜底匹配<br>按照 上述顺序匹配</li></ul><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /test_1 &#123;</span><br><span class="line">    return 400;</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /test &#123;</span><br><span class="line">    return 401;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上如果path为/test_1，返回的是400，说明^~优先级并不比普通匹配高</p><p>例子2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /test_1 &#123;</span><br><span class="line">    return 400;</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /test &#123;</span><br><span class="line">    return 401;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /test &#123;</span><br><span class="line">    return 402;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会返回 402, 因为会先命中 400 ，然后不会阻止正则</p><h3 id="静态服务器root、alias"><a href="#静态服务器root、alias" class="headerlink" title="静态服务器root、alias"></a>静态服务器root、alias</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /img/ &#123;</span><br><span class="line">    root some/path; # /img/image/1  =&gt; some/path/img/image/1 会将整个路径添加到 root 路径中</span><br><span class="line">    index index.html index.htm;   =&gt; # /user/image/1  =&gt; some/path/user/image/1 或者1.html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localtion /img/ &#123;</span><br><span class="line">    alias some/path; # /img/image/1  =&gt; some/path/image/1 会舍弃命中部分，所以要求location 和alias上级目录一致，所以location一定是一个目录，一定需要在末尾添加 / </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proxy-pass-解析"><a href="#proxy-pass-解析" class="headerlink" title="proxy_pass 解析"></a>proxy_pass 解析</h3><p>目标地址后不带/，表示将请求的path拼接在target之后，如果带，表示将请求命中之外的拼接在target后</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h3 id=&quot;windows-安装&quot;&gt;&lt;a href=&quot;#windows-安装&quot; class=&quot;headerlink&quot; title=&quot;windo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>call,apply,bind实现</title>
    <link href="https://blog.xunserver.cn/archives/8b2df16f.html"/>
    <id>https://blog.xunserver.cn/archives/8b2df16f.html</id>
    <published>2021-12-07T07:22:56.000Z</published>
    <updated>2021-12-07T07:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>模拟this调用</li><li>解析剩余参数</li><li>参数如何传到函数中</li><li>context为null时处理</li><li>处理函数非法的情况</li><li>删除额外新增的变量，最好采用symbol<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFunctionArgs = <span class="function">(<span class="params">funcArgs, startIndex = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex, len = funcArgs.length; i &lt; len; i++) &#123;</span><br><span class="line">        result.push(funcArgs[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkFunction = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> fn === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(checkFunction(<span class="keyword">this</span>))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> restArgs = getFunctionArgs(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    context = context || globalThis;</span><br><span class="line">    context.__fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">`context.__fn(<span class="subst">$&#123;restArgs&#125;</span>)`</span>)</span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, args = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!checkFunction(<span class="keyword">this</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not function'</span>);</span><br><span class="line">    context = context || globalThis;</span><br><span class="line">    context.__fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">`context.__fn(<span class="subst">$&#123;args&#125;</span>)`</span>)</span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...initArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!checkFunction(<span class="keyword">this</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not function'</span>);</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> temp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    temp.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fbind = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.myCall(<span class="keyword">this</span> <span class="keyword">instanceof</span> fn ? <span class="keyword">this</span> : context, ...initArgs, ...args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fbind.prototype = <span class="keyword">new</span> temp()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbind</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFn</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    obj.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">    <span class="keyword">constructor</span>.myApply(obj, args)</span><br><span class="line"></span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;模拟this调用&lt;/li&gt;
&lt;li&gt;解析剩余参数&lt;/li&gt;
&lt;li&gt;参数如何传到函数中&lt;/li&gt;
&lt;li&gt;context为nul
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>whistle跨平台代理调试工具</title>
    <link href="https://blog.xunserver.cn/archives/5258564a.html"/>
    <id>https://blog.xunserver.cn/archives/5258564a.html</id>
    <published>2021-11-22T09:14:22.000Z</published>
    <updated>2021-11-22T09:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>whistle用于代理http,https,websocket请求，监听修改报文，实现调式功能。语法简单，对前端友好。</p><h3 id="安装和命令行"><a href="#安装和命令行" class="headerlink" title="安装和命令行"></a>安装和命令行</h3><p>通过npm全局安装<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm i -g whistle</span><br><span class="line"><span class="comment"># 前台启动</span></span><br><span class="line">w2 run </span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">w2 start</span><br><span class="line"><span class="comment"># 后台停止</span></span><br><span class="line">w2 stop</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">w2 restart</span><br><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line">w2 <span class="built_in">help</span></span><br></pre></td></tr></table></figure></p><p>其余请求参数</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>whistle所有的操作都是通过下面范式配置， 匹配模式   操作协议+操作值</p><pre><code>pattern       operatorURI   |                |请求url表达式    对应的操作：操作协议和操作值</code></pre><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>匹配模式分为域名、路径、正则、精准匹配和，通配符匹配</p><h5 id="域名匹配"><a href="#域名匹配" class="headerlink" title="域名匹配"></a>域名匹配</h5><p>通过域名、协议和端口号进行匹配，会匹配命中的所有请求<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不区分协议</span></span><br><span class="line">www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区分协议， 注意尾部添加/ 不是域名匹配</span></span><br><span class="line">https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带端口的形式</span></span><br><span class="line">www.baiu.com:9000</span><br></pre></td></tr></table></figure></p><h5 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h5><p>匹配uri路径及其子路径，uri是由域名和路径组成<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com/xxx    <span class="comment"># 匹配 www.baidu.com/xxx 以及 www.baidu.com/xxx/xxx1/xxxx.index.html, 但是不匹配 www.baidu.com/xxx1</span></span><br></pre></td></tr></table></figure></p><p>如果想实现任何域名的路径匹配，使用通配符模式 **/xxx</p><h5 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h5><p>支持子匹配，i模式，不支持g模式。子匹配可用在operatorURI中,同时支持非匹配 <code>!/xxx/</code></p><h5 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h5><p>在路径匹配前添加$，同时支持非匹配， 表示不精准匹配某条。<code>!\$uri</code></p><h5 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h5><p>使用<code>^</code>开始，可选的<code>$</code>作为结尾</p><ul><li>*.com 匹配 xx.com 但是不能匹配 a.xx.com</li><li>**.com 可以匹配 a.xx.com</li><li>*/xx  可以匹配</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;whistle用于代理http,https,websocket请求，监听修改报文，实现调式功能。语法简单，对前端友好。&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用软件合集</title>
    <link href="https://blog.xunserver.cn/archives/f11219d6.html"/>
    <id>https://blog.xunserver.cn/archives/f11219d6.html</id>
    <published>2021-11-19T02:02:16.000Z</published>
    <updated>2021-11-19T02:02:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><a href="https://code.visualstudio.com/#alt-downloads" target="_blank" rel="noopener">vscode</a></li><li><a href="https://sublimetextcn.com/3/" target="_blank" rel="noopener">subline</a></li><li><a href="https://notepad-plus-plus.org/downloads/" target="_blank" rel="noopener">notepad++</a>，<a href="http://cdn.xunserver.cn/npp.8.1.9.1.Installer.exe" target="_blank" rel="noopener">国内下载</a></li></ul><h3 id="数据库GUI"><a href="#数据库GUI" class="headerlink" title="数据库GUI"></a>数据库GUI</h3><ul><li>mysql <a href="https://dbeaver.io/download/" target="_blank" rel="noopener">dbeaver</a>，<a href="http://cdn.xunserver.cn/dbeaver-ce-21.2.5-x86_64-setup.exe" target="_blank" rel="noopener">国内下载</a></li><li>redis <a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases" target="_blank" rel="noopener"><br>AnotherRedisDesktopManager</a></li></ul><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul><li><h3 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h3></li><li><a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">git</a></li></ul><h3 id="vscode-插件"><a href="#vscode-插件" class="headerlink" title="vscode 插件"></a>vscode 插件</h3><ul><li>code runner</li><li>css peek</li><li>eslint</li><li>stylelint</li><li>vetur</li><li>rest client</li><li>prettier</li><li>git lens</li><li>live Server</li><li>markdown all in one</li><li>git lens</li><li>git history</li></ul><h3 id="npm-包"><a href="#npm-包" class="headerlink" title="npm 包"></a>npm 包</h3><ul><li><p>代理工具</p><blockquote><p>npm i -g whistle</p></blockquote></li><li><p>静态服务器</p><blockquote><p>npm i -g static-server</p></blockquote></li></ul><h3 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h3><ul><li>act 本地运行github action工具</li><li>ftp和dhcp简单工具 tftpd64</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编辑器&quot;&gt;&lt;a href=&quot;#编辑器&quot; class=&quot;headerlink&quot; title=&quot;编辑器&quot;&gt;&lt;/a&gt;编辑器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://code.visualstudio.com/#alt-downloads&quot; targe
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端加密那些事儿</title>
    <link href="https://blog.xunserver.cn/archives/d35b105.html"/>
    <id>https://blog.xunserver.cn/archives/d35b105.html</id>
    <published>2021-11-18T11:43:45.000Z</published>
    <updated>2021-11-18T11:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>glob模式学习</title>
    <link href="https://blog.xunserver.cn/archives/5500de7d.html"/>
    <id>https://blog.xunserver.cn/archives/5500de7d.html</id>
    <published>2021-11-16T09:44:06.000Z</published>
    <updated>2021-11-16T09:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>区段 地址分隔符中分隔的区间 比如 <code>/a/b/c</code> 就分为了3个区间</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><code>*</code>  匹配单个区段中0个或者多个字符</li><li><code>**</code> 匹配跨区段 0个或者多个字符, 如果是 <code>**/</code> 只会匹配目录，或者忽略目录</li><li><code>?</code> 匹配一个字符</li><li><code>[]</code>配置括号中某个字符,当开头添加 <code>^</code>、<code>!</code>时表示不匹配</li><li><code>!</code> <code>?</code> <code>*</code> 和小括号一起使用时，和正则类似</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>匹配任意module下全部js，除了index.js</p><blockquote><p>**/module/!(index).js</p></blockquote><p>只能配置 /module 或者 xx/module，不能匹配 /xx/module</p><blockquote><p>*/module  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;区段 地址分隔符中分隔的区间 比如 &lt;code&gt;/a/b/c&lt;/code&gt; 就分为了3个区间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git再学习</title>
    <link href="https://blog.xunserver.cn/archives/141454d6.html"/>
    <id>https://blog.xunserver.cn/archives/141454d6.html</id>
    <published>2021-11-15T09:39:46.000Z</published>
    <updated>2021-11-15T09:39:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="经验技巧原则记录"><a href="#经验技巧原则记录" class="headerlink" title="经验技巧原则记录"></a>经验技巧原则记录</h3><ul><li>未推送的内容使用reset回退，已推送的内容使用revert回退</li><li>谨慎使用rebase，建议仅作为本地内容commit的合并</li><li>使用对commit –amend 对上一次commit信息进行修改，可以把当前暂存区的合并到修改中</li></ul><p>下面文件是常用的git 配置<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = yangjiaxun</span><br><span class="line">email = yangjiaxun<span class="title">@longfor.com</span></span><br><span class="line">[<span class="keyword">alias</span>]</span><br><span class="line">lg = log --graph --pretty=format:'<span class="symbol">%Cred</span><span class="symbol">%h</span><span class="symbol">%Creset</span> -<span class="symbol">%C</span>(yellow)<span class="symbol">%d</span><span class="symbol">%Creset</span> <span class="symbol">%s</span> <span class="symbol">%Cgreen</span>(<span class="symbol">%cr</span>) <span class="symbol">%C</span>(bold blue)&lt;<span class="symbol">%an</span>&gt;<span class="symbol">%Creset</span>' --abbrev-commit --date=relative</span><br></pre></td></tr></table></figure></p><h3 id="gitlab-分支管理流程"><a href="#gitlab-分支管理流程" class="headerlink" title="gitlab 分支管理流程"></a>gitlab 分支管理流程</h3><h3 id="commit理解"><a href="#commit理解" class="headerlink" title="commit理解"></a>commit理解</h3><p>git 是由commit组成，commit 记录git每次操作，包括</p><ul><li>commitid（sha-1）</li><li>Author, </li><li>commiter, </li><li>Parent(父commit)，</li><li>child(多个下游commit),</li><li>Branches 当前被哪些分支引用</li></ul><p>每次commit操作会在当前commit上，添加一个下游commit，同时挪动相关引用。</p><h3 id="branch-理解"><a href="#branch-理解" class="headerlink" title="branch 理解"></a>branch 理解</h3><p>commit用commit标记，同时可以取一个别名，这个别名就是branch，branch指向某个commit。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch develop </span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d develop</span><br></pre></td></tr></table></figure></p><p>如果当前工作区是branch，commit时会挪动branch和HEAD到最新commit，如果当前是在commit上，只会挪动HEAD到最新commit</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>当前引用，始终指向当前工作区所在commit，可以用checkout来挪动。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前HEAD 挪动到develop 所指的commit上，并切换工作区</span></span><br><span class="line">git checkout develop</span><br><span class="line"><span class="comment"># 切换到349d1ddf的commit上，HEAD -&gt; 349d1ddf, 并切换工作区</span></span><br><span class="line">git checkout 349d1ddf</span><br></pre></td></tr></table></figure></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>分为两种情况，快速合并和新建合并</p><ul><li>快速合并是指要合并过来的分支commit树包含当前分支commit信息，这个时候直接挪动当前分支到要合并的分支</li><li>如果不包含，会自动在当前分支新建一个commit。这个commit包含两个分支的diff 信息，然后挪动当前分支到自动创建的commit。</li></ul><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>将分支和HEAD挪动位置<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挪动当前分支到HEAD所在commit</span></span><br><span class="line">git reset HEAD</span><br><span class="line"><span class="comment"># 挪动当前分支到HEAD父commit</span></span><br><span class="line">git reset HEAD^</span><br><span class="line"><span class="comment"># 挪动当前分支到3次父commit</span></span><br><span class="line">git reset HEAD~3</span><br></pre></td></tr></table></figure></p><ul><li>–soft 将差异内容保存到暂存区</li><li>–hard 清空当前工作区和暂存区内容</li><li>不加参数，将差异保存在工作区</li></ul><p>也可以对文件进行操作，删除暂存区内容</p><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p>针对文件时，是操作工作区内容和版本区一致</p><h3 id="工作区、暂存区和版本区"><a href="#工作区、暂存区和版本区" class="headerlink" title="工作区、暂存区和版本区"></a>工作区、暂存区和版本区</h3><ul><li>工作区 -&gt;当前文件系统所拥有的状态</li><li>暂存区 -&gt;add后添加到到内容</li><li>版本区 -&gt;commit后的区域 指针都指向版本区</li></ul><h3 id="pull和push"><a href="#pull和push" class="headerlink" title="pull和push"></a>pull和push</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;经验技巧原则记录&quot;&gt;&lt;a href=&quot;#经验技巧原则记录&quot; class=&quot;headerlink&quot; title=&quot;经验技巧原则记录&quot;&gt;&lt;/a&gt;经验技巧原则记录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;未推送的内容使用reset回退，已推送的内容使用revert回退&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谷歌浏览器开发者工具技巧</title>
    <link href="https://blog.xunserver.cn/archives/ea959a90.html"/>
    <id>https://blog.xunserver.cn/archives/ea959a90.html</id>
    <published>2021-11-15T09:39:15.000Z</published>
    <updated>2021-11-15T09:39:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="保存为全局变量"><a href="#保存为全局变量" class="headerlink" title="保存为全局变量"></a>保存为全局变量</h3><p>对打印的信息右键保存为全局变量</p><h3 id="复制dom-element-strng"><a href="#复制dom-element-strng" class="headerlink" title="复制dom element strng"></a>复制dom element strng</h3><p>点击直接ctrl+c</p><h3 id="element面板调整数字大小"><a href="#element面板调整数字大小" class="headerlink" title="element面板调整数字大小"></a>element面板调整数字大小</h3><p>上下箭头 + ctrl alt 或者shift一个一个试一下</p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><ul><li>ctrl + p 打开资源查找器，输入 &gt; 进入命令行。</li><li>直接ctrl + p + shift</li></ul><h3 id="和"><a href="#和" class="headerlink" title="$ 和 ?"></a>$ 和 ?</h3><ul><li>$ 是 document.querySelector()别名</li><li>? 是 document.querySelectorAll() 别名</li><li>$_ 表示上一次的执行结果,像是对上一次语句左边拼接 = </li></ul><h3 id="console一定是同步的吗？"><a href="#console一定是同步的吗？" class="headerlink" title="console一定是同步的吗？"></a>console一定是同步的吗？</h3><p>console打印需要时间，再打印出结果前，是以引用的方式保存的。所有有可能打印的结果不准确。所以应该尽量打印基本类型，或者使用断点。</p><h3 id="console控件台总是被async-包围"><a href="#console控件台总是被async-包围" class="headerlink" title="console控件台总是被async 包围"></a>console控件台总是被async 包围</h3><p>一些异步的方法可以直接使用await，比如fetch语句</p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>在断点语句添加判断语句， 不需要if，如果条件满足就会断点。条件语句总是会执行</p><h3 id="条件断点和console黑科技"><a href="#条件断点和console黑科技" class="headerlink" title="条件断点和console黑科技"></a>条件断点和console黑科技</h3><p>利用上面的特性，因为console总是返回undefined，所以可以添加一个条件语句console.log()</p><h3 id="条件和console"><a href="#条件和console" class="headerlink" title="条件和console"></a>条件和console</h3><p>console.assert()，第一个参数写语句，后面写打印</p><h3 id="log-多参数打印技巧"><a href="#log-多参数打印技巧" class="headerlink" title="log 多参数打印技巧"></a>log 多参数打印技巧</h3><p>console.log(x1, x2, x3) 修改改成 console.log({ x1, x2, x3 }) 就可以看到每个位置是什么参数，当然可能会出现值不准确的问题。</p><h3 id="打印数组和对象"><a href="#打印数组和对象" class="headerlink" title="打印数组和对象"></a>打印数组和对象</h3><p>console.table</p><h3 id="过滤请求"><a href="#过滤请求" class="headerlink" title="过滤请求"></a>过滤请求</h3><ul><li>filter 过滤框中添加 method:GET 就会仅显示GET请求，-method:GET 就会过滤GET请求只显示其他，也可以勾选invert选项</li><li>安装crtl 点击资源类型可以多选</li></ul><h3 id="勾选禁用缓存和硬性刷新浏览器的区别"><a href="#勾选禁用缓存和硬性刷新浏览器的区别" class="headerlink" title="勾选禁用缓存和硬性刷新浏览器的区别"></a>勾选禁用缓存和硬性刷新浏览器的区别</h3><p>禁用缓存会每个资源都不使用缓存，硬性刷新只会在dom初始化阶段的请求添加禁止缓存</p><h3 id="添加network展示的列"><a href="#添加network展示的列" class="headerlink" title="添加network展示的列"></a>添加network展示的列</h3><p>在表头右键，一般添加上method方法</p><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><p>命令行输入 create new snippet 新建代码片段，通过!加代码片段名称调用</p><h3 id="利用source-gt-filesystem-实现在浏览器中修改代码，并同步css"><a href="#利用source-gt-filesystem-实现在浏览器中修改代码，并同步css" class="headerlink" title="利用source -&gt; filesystem 实现在浏览器中修改代码，并同步css"></a>利用source -&gt; filesystem 实现在浏览器中修改代码，并同步css</h3><p>本地起一个服务，把代码目录拖到filesystem, 对变绿色的代码就可以直接修改，保存后隐射到本地</p><h3 id="page-filesystem-overrides-contentScript的使用"><a href="#page-filesystem-overrides-contentScript的使用" class="headerlink" title="page filesystem overrides contentScript的使用"></a>page filesystem overrides contentScript的使用</h3><ul><li>page 用于查看当前网页下面文件</li><li>filesystem 连接本地和浏览器，在浏览器中的修改会同步到本地代码。文件标志是绿色</li><li>overrides 不能和filesystem共用，修改文件时优先保存overrides。通过完全一致的url对应，包括查询参数。文件标志是紫色。浏览器加载时会本地替换这个资源</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;保存为全局变量&quot;&gt;&lt;a href=&quot;#保存为全局变量&quot; class=&quot;headerlink&quot; title=&quot;保存为全局变量&quot;&gt;&lt;/a&gt;保存为全局变量&lt;/h3&gt;&lt;p&gt;对打印的信息右键保存为全局变量&lt;/p&gt;
&lt;h3 id=&quot;复制dom-element-strng&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端缓存</title>
    <link href="https://blog.xunserver.cn/archives/97f0c4bf.html"/>
    <id>https://blog.xunserver.cn/archives/97f0c4bf.html</id>
    <published>2021-11-14T10:43:41.000Z</published>
    <updated>2021-11-14T10:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="请求报文和相应报文"><a href="#请求报文和相应报文" class="headerlink" title="请求报文和相应报文"></a>请求报文和相应报文</h3><p>报文中报头部分使用冒号分隔的键值对组成，称为首部字段。部分首部字段在响应和请求中均有，称为通用首部字段。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><h4 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h4><p>(响应首部字段)资源有效时间，表示在此事件前资源使用缓存。<code>Expires: Wed, 11 May 2022 03:50:47 GMT</code></p><h4 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h4><p>（通用首部字段）缓存控制，由以下字段组成</p><ul><li>max-age 缓存最大时间，是一个相对时间，同时可用于请求，表示希望获得一个max-age 不大于指定值的资源，单位是秒。max-age 会覆盖expires，一般expires和max-age需要同时存在，兼容性设置。</li><li>s-maxage  表示代理服务器最大缓存时间，公共服务器接受到这个参数后，会直接使用这个，忽略其他expires 和 max-age</li><li>public/private 表示资源是否能够被缓存服务器缓存， 不过一般缓存服务器不会处理这个字段，照样缓存。</li><li>no-cache/no store，no-cache在请求中时，表示不使用缓存服务器资源，使用源资源，同时也可以向源资源表示，使用最新资源。在响应中需要使用no-store 才表示真正的不缓存</li><li>no-cache 不进行强缓存（重要）</li><li>no-store 不强缓存，也不协商缓存。</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><h4 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h4><p>Last-Modified 资源最后修改时间，浏览器接收当前资源后，下次在请求头中添加If-Modified-Since 字段。服务器验证是否有效，有效返回304。无效返回200、最新资源和最新的Last-Modified</p><p>Last-Modified值实列如下，时间精度到秒<code>Last-Modified: Fri , 14 May 2021 17:23:13 GMT</code>。如果资源是毫秒级别的更新，可能会出现资源不是最新的情况。所以新出现了Etag和If-None-Match</p><h4 id="Etag-和-If-None-match"><a href="#Etag-和-If-None-match" class="headerlink" title="Etag 和 If-None-match"></a>Etag 和 If-None-match</h4><p>Etag在响应头中返回，用于标志资源的唯一性，资源每次变化时，Etag会重新生成。浏览器下次发送请求通过If-None-match发送。服务器对比处理逻辑同Last-Modified</p><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><ul><li>memory cache 内存缓存</li><li>disk cache</li></ul><h3 id="缓存时间如何计算"><a href="#缓存时间如何计算" class="headerlink" title="缓存时间如何计算"></a>缓存时间如何计算</h3><p>缓存新鲜度 = max-age || (expires - date)  date 表示响应头中的Date字段<br>缓存使用期 = 响应使用期 + 传输延迟时间 + 停留缓存时间</p><ul><li>响应使用期 = max(0, response_time - date_value)，然后再和响应头age（秒）max</li><li>传输延迟时间 = 响应时间 - 请求时间</li><li>停留缓存时间 = now - 响应时间   now表示电脑当前时间。修改电脑时间使缓存失效的关键点。</li></ul><p>当缓存使用期大于缓存新鲜度时，强缓存会失效，会启用缓存协商，如果无协商缓存，会重新请求。</p><h3 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h3><p>上述可见强缓存新鲜度 = max-age || (expires - date)。如果max-age、expires、date不存在。缓存新鲜度计算规则 max(0, date - Last-Modified ) * 10%</p><h3 id="开发模式下的刷新操作"><a href="#开发模式下的刷新操作" class="headerlink" title="开发模式下的刷新操作"></a>开发模式下的刷新操作</h3><ul><li>硬性重新加载：不使用本地缓存，同时请求时在请求中添加cache-control: no-cache, 告知服务器和代理服务器不使用缓存。</li></ul><p>使用硬性加载没有用的原因是，这两个请求头仅在页面渲染时添加，通过动态脚本添加的资源不会添加这个请求头，还是会走强缓存。</p><ul><li>清空缓存并强制加载：清空本地缓存并硬性加载</li></ul><h3 id="spa情况下如何配置缓存策略"><a href="#spa情况下如何配置缓存策略" class="headerlink" title="spa情况下如何配置缓存策略"></a>spa情况下如何配置缓存策略</h3><p>spa通过加载一个index.html,index.html中再加载相关文件完成界面。这里就有两个地方index.html 和 其他资源。</p><ul><li><p>index.html 文件名不会变化，需要使用协商缓存，服务端配置max-age = 0, 但是不能配置cache-control: no-store</p></li><li><p>其余资源，设置强缓存。根据文件内容变化文件名，保证每次引用都是新的，也不会走缓存。</p></li></ul><h3 id="webpack-如何使用强缓存"><a href="#webpack-如何使用强缓存" class="headerlink" title="webpack 如何使用强缓存"></a>webpack 如何使用强缓存</h3><ul><li>hash 项目级别的hash</li><li>chunkhash 根据 入口文件相关的依赖进行hash</li><li>contenthash，根据每个文件内容变化的hash</li></ul><h3 id="nginx-如何配置缓存"><a href="#nginx-如何配置缓存" class="headerlink" title="nginx 如何配置缓存"></a>nginx 如何配置缓存</h3><ul><li>针对静态资源设置</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;请求报文和相应报文&quot;&gt;&lt;a href=&quot;#请求报文和相应报文&quot; class=&quot;headerlink&quot; title=&quot;请求报文和相应报文&quot;&gt;&lt;/a&gt;请求报文和相应报文&lt;/h3&gt;&lt;p&gt;报文中报头部分使用冒号分隔的键值对组成，称为首部字段。部分首部字段在响应和请求中均有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ts随笔</title>
    <link href="https://blog.xunserver.cn/archives/d6023bbe.html"/>
    <id>https://blog.xunserver.cn/archives/d6023bbe.html</id>
    <published>2021-11-11T13:48:50.000Z</published>
    <updated>2021-11-11T13:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量申明空间和类型申明空间"><a href="#变量申明空间和类型申明空间" class="headerlink" title="变量申明空间和类型申明空间"></a>变量申明空间和类型申明空间</h3><p>类型申明空间不会编译到源码中，class会同时声明到变量声明空间和类型声明空间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量申明空间和类型申明空间&quot;&gt;&lt;a href=&quot;#变量申明空间和类型申明空间&quot; class=&quot;headerlink&quot; title=&quot;变量申明空间和类型申明空间&quot;&gt;&lt;/a&gt;变量申明空间和类型申明空间&lt;/h3&gt;&lt;p&gt;类型申明空间不会编译到源码中，class会同时声明到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ccna</title>
    <link href="https://blog.xunserver.cn/archives/838de56f.html"/>
    <id>https://blog.xunserver.cn/archives/838de56f.html</id>
    <published>2021-11-10T04:19:20.000Z</published>
    <updated>2021-11-10T04:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三种配置模式"><a href="#三种配置模式" class="headerlink" title="三种配置模式"></a>三种配置模式</h3><ol><li>用户模式 console登录上去默认   命令行标识符为 &gt; </li><li>特权模式 输入 en | enable进入， 标识符为 #</li><li>配置模式 输入 configrue terminal  标识符为(terminal)#</li></ol><h3 id="console-配置密码"><a href="#console-配置密码" class="headerlink" title="console 配置密码"></a>console 配置密码</h3><p>防止内鬼直接console进入设备<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">en  <span class="comment"># 特权模式</span></span><br><span class="line">configure t <span class="comment"># 配置模式</span></span><br><span class="line">line <span class="comment"># 线缆模式</span></span><br><span class="line">line console 0  <span class="comment"># 选择console 0</span></span><br><span class="line">password somepass  <span class="comment"># 设置密码</span></span><br><span class="line">login  <span class="comment"># 激活登录 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消密码</span></span><br><span class="line">no login  <span class="comment"># 不激活密码</span></span><br><span class="line">no password  <span class="comment"># 删除密码</span></span><br></pre></td></tr></table></figure></p><p>华为仅只有用户视图密码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">user-interface console 0</span><br><span class="line"><span class="comment"># 路由器</span></span><br><span class="line">authentication-mode password</span><br><span class="line"><span class="comment"># 交换机</span></span><br><span class="line"><span class="built_in">set</span> authentication password simple somepassword</span><br></pre></td></tr></table></figure></p><h3 id="特权模式设置密码"><a href="#特权模式设置密码" class="headerlink" title="特权模式设置密码"></a>特权模式设置密码</h3><p>需要在配置模式设置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">enable</span> password somepassword</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> <span class="builtin-name">enable</span> password 删除密码</span><br></pre></td></tr></table></figure></p><h3 id="查看线缆链接情况"><a href="#查看线缆链接情况" class="headerlink" title="查看线缆链接情况"></a>查看线缆链接情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enable</span></span><br><span class="line">show line </span><br><span class="line"></span><br><span class="line"><span class="comment"># 华为</span></span><br><span class="line">show user-interface</span><br></pre></td></tr></table></figure><p>星号表示当前正在使用的端口<br>vty: 虚拟tty<br>cty: console tty<br>aux: 不常用</p><h3 id="查看当前模式下所有配置"><a href="#查看当前模式下所有配置" class="headerlink" title="查看当前模式下所有配置"></a>查看当前模式下所有配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思科</span></span><br><span class="line">show running-config</span><br><span class="line"><span class="comment"># 华为</span></span><br><span class="line">display currenting-configure</span><br></pre></td></tr></table></figure><h3 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h3><p>不保存配置关机后之前的配置会消失<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enable</span></span><br><span class="line">write</span><br><span class="line"></span><br><span class="line"><span class="comment"># 华为只在用户模式保存</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;三种配置模式&quot;&gt;&lt;a href=&quot;#三种配置模式&quot; class=&quot;headerlink&quot; title=&quot;三种配置模式&quot;&gt;&lt;/a&gt;三种配置模式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;用户模式 console登录上去默认   命令行标识符为 &amp;gt; &lt;/li&gt;
&lt;li&gt;特权模式
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>umd,cmd,commonjs,esmodule学习教程</title>
    <link href="https://blog.xunserver.cn/archives/4986aa26.html"/>
    <id>https://blog.xunserver.cn/archives/4986aa26.html</id>
    <published>2021-11-04T02:56:36.000Z</published>
    <updated>2021-11-04T02:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="amd"><a href="#amd" class="headerlink" title="amd"></a>amd</h3><p>amd Asynchronous Module Definition 异步模块化定义, requirejs实现了这套规范，思想是前置依赖，主要包括以下几个方法</p><ul><li>require.config() 配置依赖</li><li>define([deps], callback)。定义模块</li><li>require([deps], callback)。引用模块<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependA.js</span></span><br><span class="line">define([</span><br><span class="line">    <span class="string">'dependB'</span></span><br><span class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">dependB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(dependB.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dependB.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'dependB'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseurl: <span class="string">'/static/umd'</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">"dependB"</span>: <span class="string">'dependB'</span>,</span><br><span class="line">        <span class="string">"dependA"</span>: <span class="string">'dependA'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'dependA'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dependA</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dependA)</span><br><span class="line">    dependA.start()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>查看<a href="/static/amd/amd.html">演示</a>。requirejs 需要预先配置好所有依赖。不能动态获取所有</p><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>cmd 通用模块定义（Common Module Definition）。seajs实现了这套规范，依赖是就近依赖，延迟执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">seajs.config(&#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        dependB: <span class="string">'./dependB.js'</span></span><br><span class="line">        dependA: <span class="string">'./dependA.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">seajs.use(<span class="string">'dependA'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dependA.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dependB = <span class="built_in">require</span>(<span class="string">'dependB'</span>);</span><br><span class="line">    dependB.start()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dependB.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    exports.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">'dependB'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>查看<a href="/static/cmd/cmd.html">演示</a>。seajs通过正则解析，预先将当前文件的require的module加载，所以require可以同步加载</p><h3 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h3><p>commonjs 是nodejs实现的一套模块化规范，和seajs类似。通过require、exports、module实现动态导入导出，不过不需要写define语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'A'</span>);</span><br><span class="line"></span><br><span class="line">exports.someA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'someA'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>commonjs下，为什么我们可以在文件中使用<strong>dirname,</strong>filename, require，module,exports等。 nodejs会将js文件进行包裹，类似下面这种。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports, require, module, __dirname, __filename,...</span>) </span>&#123;</span><br><span class="line">    exports.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>包装函数如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wraper</span>(<span class="params">functionStr</span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`function(exports, require, module, __dirname, __filename) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;functionStr&#125;</span></span></span><br><span class="line"><span class="string">    &#125;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> moduleFunction = wraper<span class="string">`</span></span><br><span class="line"><span class="string">    export.say = function() &#123;</span></span><br><span class="line"><span class="string">        console.log('say')</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">runInThisContext(moduleFunction)(exports, <span class="built_in">require</span>, <span class="built_in">module</span>, __dirname, __filename)</span><br></pre></td></tr></table></figure></p><p>runInThisContext 相当于eval或者new Function。实现动态申明函数的功能。读取文件内容 =&gt; 添加包裹 =&gt; eval生成函数 =&gt; 添加相应参数 =&gt; 执行，require整个流程。</p><p>在代码中可以打印require和module，查看具体详情。</p><h4 id="require加载流程"><a href="#require加载流程" class="headerlink" title="require加载流程"></a>require加载流程</h4><p>require加载模块有3类</p><ul><li>nodejs底层核心模块</li><li>工程中代码</li><li>npm 中的第三方代码</li></ul><p>require标志符指require时的参数，按照以下方式解析</p><ul><li>如果标识符是核心模块，加载核心模块。</li><li>如果标志符以<code>./</code> <code>/</code> <code>../</code>开头，视为项目代码，会解析成绝对路径，作为module标志</li><li>如果不满足上面，则认为是第三方模块。</li></ul><p>解析第三方模块规则如下</p><ul><li>从当前__dirname 开始，寻找是否存在node_modules, 在node_module 中查找标识符目录，如果查询到，检查package.json 中是否存在main字段，如果有根据main字段指向的js作为module入口，如果没有使用index.js ，index.json ，index.node。</li><li>如果未找到node_modules, 在父级目录查找，直到根目录。重复执行上述流程。</li></ul><p>!()[]</p><p>require 解析是按照深度优先的原则，按照代码执行顺序解析require。</p><h4 id="require-简单源码"><a href="#require-简单源码" class="headerlink" title="require 简单源码"></a>require 简单源码</h4><p>commomjs 将所有文件视为一个module，module包括文件解析相关信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cacheModule = Module._cache[id]</span><br><span class="line">    <span class="keyword">if</span>(cacheModule) &#123;</span><br><span class="line">         <span class="keyword">return</span> cacheModule.exports</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">        exports: &#123;&#125;,</span><br><span class="line">        loaded: <span class="literal">false</span>,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fileContent = getFileContent(id);</span><br><span class="line"></span><br><span class="line">    Module._cache[id] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">    runInThisContext(warper(fileContent))(<span class="built_in">module</span>, <span class="built_in">module</span>.exports, <span class="built_in">require</span>, __filename, __dirname)</span><br><span class="line">    <span class="built_in">module</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，相同标识符下，require只会加载一次，避免了循环引用问题。 delete require.cache[moduleName];  具体参考 <a href="https://www.cnblogs.com/cangqinglang/p/9528815.html" target="_blank" rel="noopener">commonjs 详解</a></p><h3 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h3><p>umd是兼容amd和commonjs的规范，对代码做相应包括可实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">context, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'是commonjs模块规范，nodejs环境'</span>)</span><br><span class="line">        <span class="built_in">module</span>.exports = factory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'是AMD模块规范，如require.js'</span>)</span><br><span class="line">        define(factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.cmd) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'是CMD模块规范，如sea.js'</span>)</span><br><span class="line">        define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">module</span>.exports = factory()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'没有模块环境，直接挂载在全局对象上'</span>)</span><br><span class="line">        root.umdModule = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// js 代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;amd&quot;&gt;&lt;a href=&quot;#amd&quot; class=&quot;headerlink&quot; title=&quot;amd&quot;&gt;&lt;/a&gt;amd&lt;/h3&gt;&lt;p&gt;amd Asynchronous Module Definition 异步模块化定义, requirejs实现了这套规范，思想是前置
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vercel白嫖教程</title>
    <link href="https://blog.xunserver.cn/archives/f79d6af9.html"/>
    <id>https://blog.xunserver.cn/archives/f79d6af9.html</id>
    <published>2021-09-07T09:00:02.000Z</published>
    <updated>2021-09-07T09:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>vercel 可以托管静态资源，ssr，和serverless 函数。官网地址 <a href="https://vercel.com，首次使用需要邮箱注册，建议绑定github" target="_blank" rel="noopener">https://vercel.com，首次使用需要邮箱注册，建议绑定github</a> 账号，方便登录。</p><h4 id="托管vue项目"><a href="#托管vue项目" class="headerlink" title="托管vue项目"></a>托管vue项目</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;vercel 可以托管静态资源，ssr，和serverless 函数。官网地址 &lt;a href=&quot;https://vercel.com，首次
      
    
    </summary>
    
    
  </entry>
  
</feed>
