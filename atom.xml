<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bang</title>
  
  <subtitle>生活总会有惊喜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xunserver.cn/"/>
  <updated>2022-11-23T03:26:05.000Z</updated>
  <id>https://blog.xunserver.cn/</id>
  
  <author>
    <name>yangmanman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>diff算法</title>
    <link href="https://blog.xunserver.cn/archives/3387ce12.html"/>
    <id>https://blog.xunserver.cn/archives/3387ce12.html</id>
    <published>2022-11-23T03:26:05.000Z</published>
    <updated>2022-11-23T03:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-的-diff"><a href="#react-的-diff" class="headerlink" title="react 的 diff"></a>react 的 diff</h3><p>a b c d<br>a b c d<br>a d c b<br>last 0<br>last 0 a d b c<br>last 0 a d c b<br>last 0 a</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;react-的-diff&quot;&gt;&lt;a href=&quot;#react-的-diff&quot; class=&quot;headerlink&quot; title=&quot;react 的 diff&quot;&gt;&lt;/a&gt;react 的 diff&lt;/h3&gt;&lt;p&gt;a b c d&lt;br&gt;a b c d&lt;br&gt;a d c b&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="https://blog.xunserver.cn/archives/6098be36.html"/>
    <id>https://blog.xunserver.cn/archives/6098be36.html</id>
    <published>2022-11-22T14:07:22.000Z</published>
    <updated>2022-11-22T14:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础中需要注意的点"><a href="#基础中需要注意的点" class="headerlink" title="基础中需要注意的点"></a>基础中需要注意的点</h3><ol><li><p>如果通过path导航，总是回匹配到子路由，如果只想展示父路由，通过name的形式导航</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    name: <span class="string">'parent'</span>,</span><br><span class="line">    path: <span class="string">'/foo'</span>,</span><br><span class="line">    component: ParentComponent,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        name: <span class="string">'child'</span>,</span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        component: ChildrenComponent</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">'/foo'</span>&#125;)   <span class="comment">// 会渲染parentComponent 和 ChildComponent</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'parent'</span>&#125;) <span class="comment">// 只会渲染parentComponent，刷新后</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套路由中子路由如果使用绝对路径代表路由不嵌套，只嵌套组件。</p></li><li><p>新版本vue-router 支持正则表达式的匹配。详情见文档</p></li><li><p>支持命令路由和命令视图, 大致意思是同一个url，可以渲染多个视图。<router-view name="slider"> ，路由配置中通过components: {default: xxx, slider: xxx} 形式配置</router-view></p></li><li><p>支持别名，即url显示一个地址，实际界面展示的是另一个路由url配置的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    url: <span class="string">'/'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    alias: <span class="string">'/home'</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="comment">// 直接浏览器导航到/home 也会展示/的界面</span></span><br></pre></td></tr></table></figure></li><li><p>支持相对重定向和动态重定向，相对重定向对于当前路由，绝对重定向通过传入一个函数实现</p></li></ol><h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础中需要注意的点&quot;&gt;&lt;a href=&quot;#基础中需要注意的点&quot; class=&quot;headerlink&quot; title=&quot;基础中需要注意的点&quot;&gt;&lt;/a&gt;基础中需要注意的点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果通过path导航，总是回匹配到子路由，如果只想展示父路由，通过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>状态管理进阶和实战</title>
    <link href="https://blog.xunserver.cn/archives/6e558469.html"/>
    <id>https://blog.xunserver.cn/archives/6e558469.html</id>
    <published>2022-11-21T13:31:11.000Z</published>
    <updated>2022-11-21T13:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex是vue2中首选的状态管理工具，包括state、mutation、action 三大马车，大致是组件触发dispatch()或者commit()来修改state中的数据</p><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>redux包括state，所有的state必须要通过dispatch(action) 来触发，redux内部通过事先注册号的的reducer来处理dispath(action) 的动作。reducer是一个接受action的函数，通过action来改变当前的state并返回新的state。<br>可以看到，vuex是在redux将action和reducer的功能简化。对于同步的场景，mutation 中定义的其实就是reducer，mutation的名字作为action。vuex中将并未将action统一化，也有将action统一管理的。比如可以用create_action 来生成标志。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> unSubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = store.getState()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>实现一个简易版本的redux<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">const</span> listeners = [];</span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)  <span class="comment">// 取消订阅</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        <span class="keyword">this</span>.listeners.forEach(<span class="function"><span class="params">listen</span> =&gt;</span> listen())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        getState,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h3><p>createStore第二个参数设置applyMiddleware，applyMiddleware 大致理解成核心是compose，会返回一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(a, b =&gt; <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">    (...args) =&gt; fn1(fn2(...args))</span><br><span class="line">    (...args) =&gt; fn1(fn2(fn3(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFunc = compose(fn1, fn2, fn3)</span><br><span class="line">newFunc(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// applyMiddle</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> thunk = <span class="function">(<span class="params">next</span>) =&gt;</span> (action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> log = <span class="function">(<span class="params">next</span>) =&gt;</span> (action) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.end(<span class="string">'end'</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dispatch = compose(thunk, log)(store.dispatch) <span class="comment">// log(thunk(store.dispatch)) =&gt; (action)</span></span><br><span class="line">dispatch(action)  =&gt; log(action) =&gt; thunk(action) =&gt; log(action)</span><br></pre></td></tr></table></figure></p><p>完整版本的redux<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> middlewareApply = <span class="function">(<span class="params">...middleWares</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> reducer =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">        middleWares = middleWares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleWares(&#123;</span><br><span class="line">            dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args),</span><br><span class="line">            getState: store.getState</span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">const</span> dispatch = compose(...middleWares)(store.dispatch)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, storeEnhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(storeEnhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> storeEnhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> state</span><br><span class="line">    <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subScribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(listener)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line">    dispatch(&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        subScribe,</span><br><span class="line">        getState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> () =&gt; <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// next 理解为传递到下一个action处理器，其中dispatch也是一个处理器。</span></span><br><span class="line">    <span class="comment">// 不执行next表示中间件停止</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> log = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>, getState())</span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>, getState());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, middlewareApply(thunk, log))</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: <span class="string">"ADD"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        store.dispatch(<span class="string">'ADD'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="vuex中的高级应用"><a href="#vuex中的高级应用" class="headerlink" title="vuex中的高级应用"></a>vuex中的高级应用</h3><ol><li><p>支持模块，默认情况下模块是全局注册的，在多个模块中同时注册相同的名字在触发时会被同时响应，添加namespace: true后会将所有的action 和 mutation添加模块前缀，触发时需要补上前缀(在命名空间下通过root: true 注册全局)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        foo: &#123;</span><br><span class="line">            namespace: <span class="literal">true</span></span><br><span class="line">            actions: &#123;  </span><br><span class="line">                add() &#123;  <span class="comment">// dispatch('foo/add', xxx)</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                del: &#123;   <span class="comment">// dispatch('del', xxx)</span></span><br><span class="line">                    root: <span class="literal">true</span>,</span><br><span class="line">                    handler() &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        boo: &#123;</span><br><span class="line">            actions: &#123;</span><br><span class="line">                del() &#123;&#125;  <span class="comment">// dispatch('del', xxx)  会同时触发两个模块</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>支持动态注册模块 registerModule()，适合于模块数据</p></li></ol><h3 id="vuex-插件机制和执行流程"><a href="#vuex-插件机制和执行流程" class="headerlink" title="vuex 插件机制和执行流程"></a>vuex 插件机制和执行流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> logPlugin = <span class="function">(<span class="params">pluginOptions</span>) =&gt;</span> &#123;  <span class="comment">// 日志组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">        store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;  <span class="comment">// 订阅每次mutation操作</span></span><br><span class="line">            <span class="built_in">console</span>.log(mutation.type, mutation.payload, state)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个持久化state的插件</span></span><br></pre></td></tr></table></figure><h3 id="vuex源码流程"><a href="#vuex源码流程" class="headerlink" title="vuex源码流程"></a>vuex源码流程</h3><ol><li><p>注册插件 Vue.use(Vuex)， 通过插件的形式在vue各个实例的beforeCreate前注入vuex.store 实例，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Vuex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> apply(Vue) &#123;</span><br><span class="line">        Vue.mixin(beforeCreate: VueInit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> VueInit = () &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.$parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$parent.$store   <span class="comment">// 如果当前是子节点，总是取父节点的，但是有个问题是如果当前节点还未挂载是没有$parent属性的，比如是new实例生成的的组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$options.store  <span class="comment">// 如果当前是根节点，取根节点传入的store</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行store构造函数，初始化各个state，各个mutation监听，各个action监听。生成dispatch函数和commit函数，再执行插件初始化，最后执行devtool</p><ol><li>installModule 安装当前module上的state和根state绑定(如果有),通过Vue.set() 添加新的子state到上级state上</li><li>forEachMutation， 将module中mutation绑定到根store中mutationMap上， 如果是命名空间还需要添加前缀。如果同名是推入数组</li><li>forEachAction 和 forEachGetter 同理</li><li>遍历子模块继续执行installModule</li></ol></li><li><p>初始响应式，将所有的state代理到new Vue({data: state})的实例上，getter代理到computed,这样获取state就会生成watcher进入dep，修改store中的state会触发所有的监听。</p></li></ol><p>插件的应用场景有如下几个。</p><ol><li>通过aop的方式处理action或者mutation的中执行错误，重写store.commit 或者 store.dispatch 函数实现</li><li>通过subscribe或者subscribeAction监听，实现日志或者持久化等操作，默认情况监听函数发生在action和mutation之前，通过参数prepend: true 添加到前面实现对state的再处理。</li><li>通过replaceState来初始化state，注意的是replace是替换根state，如果需要特殊的state，直接赋值即可</li><li>通过registerrModule 来注册一些业务外不关注的module</li></ol><h3 id="vuex-实例上需要关注的方法"><a href="#vuex-实例上需要关注的方法" class="headerlink" title="vuex 实例上需要关注的方法"></a>vuex 实例上需要关注的方法</h3><p>state, commit, dispatch, subscribe, subscribeAction, watch, registerModule, replaceState(storagePlugin中需要用到)</p><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h3&gt;&lt;p&gt;vuex是vue2中首选的状态管理工具，包括state、mutation、action 三大马车，大致是组件触发dispat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue中的高阶组件</title>
    <link href="https://blog.xunserver.cn/archives/f235dcea.html"/>
    <id>https://blog.xunserver.cn/archives/f235dcea.html</id>
    <published>2022-11-21T09:09:46.000Z</published>
    <updated>2022-11-21T09:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vue 中组件复用的方式有 mixin，extend，高阶组件和组合组件三种方式</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="如何创建一个全局单例组件"><a href="#如何创建一个全局单例组件" class="headerlink" title="如何创建一个全局单例组件"></a>如何创建一个全局单例组件</h4><p>const instance = new Vue(options), 通过这种方式能够实现部分命令方式调用组件。</p><h4 id="mixin-和-extend-的区别"><a href="#mixin-和-extend-的区别" class="headerlink" title="mixin 和 extend 的区别"></a>mixin 和 extend 的区别</h4><p>mixin 是对选项的混合，发生在生成 vue 实例之前，extend 是对 vue 实现继承，返回的是一个 vue 实例， 类似于 Object.create()</p><h4 id="HOC-实现一个-promise-组件"><a href="#HOC-实现一个-promise-组件" class="headerlink" title="HOC 实现一个 promise 组件"></a>HOC 实现一个 promise 组件</h4><p>代码中经常有请求一个 api，然后根据 api 显示不同逻辑的需求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-if=&quot;loading&quot;&gt;loading&lt;/div&gt;</span><br><span class="line">    &lt;div v-if=&quot;!loading&quot;&gt;</span><br><span class="line">      &#123;&#123; content &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content: &quot;&quot;,</span><br><span class="line">      loading: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getContent() &#123;</span><br><span class="line">      this.loading = true;</span><br><span class="line">      this.$api.get(&quot;/some&quot;).then((content) =&gt; &#123;</span><br><span class="line">        this.loading = false;</span><br><span class="line">        this.content = content;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过 HOC 将该组件的请求逻辑提取出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withPromise = <span class="function">(<span class="params">component, promiseFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        loading: <span class="literal">true</span>,</span><br><span class="line">        result: <span class="literal">null</span>,</span><br><span class="line">        error: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">      promiseFn()</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.result = data;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.error = error;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">const</span> loading = <span class="function"><span class="params">()</span> =&gt;</span> h();</span><br><span class="line">      <span class="keyword">const</span> error = <span class="function"><span class="params">()</span> =&gt;</span> h();</span><br><span class="line">      <span class="keyword">const</span> content = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        h(component, &#123;</span><br><span class="line">          loading: <span class="keyword">this</span>.loading,</span><br><span class="line">          content: <span class="keyword">this</span>.content,</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">"div"</span>, <span class="literal">null</span>, [</span><br><span class="line">        <span class="keyword">this</span>.loading ? loading() : <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">this</span>.error ? error() : <span class="literal">null</span>,</span><br><span class="line">        !<span class="keyword">this</span>.loading &amp;&amp; !<span class="keyword">this</span>.error ? content() : <span class="literal">null</span>,</span><br><span class="line">      ]);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newComponent = withPromise(view, getContent);</span><br></pre></td></tr></table></figure><p>上面实现还有几个问题没有解决</p><ol><li>请求函数的参数还没有，不能通过子组件自定义</li><li>子组件参数如果有变化，触发新的查询</li><li>外部组件对于子组件的 prop 等参数没有传递到子组件,包括插槽等</li></ol><p>第一个文件有两种方式拿到子组件的请求参数，第一个是静态的，通过在子组件选项或者定义上面绑定一个特殊的键值实现，或者将值绑定到子组件的实例上，通过 this.$refs 拿到子组件的实例后获取。</p><p>第二个问题需要在子组件上动态的添加 watch 函数，watch 函数监听子组件的查询参数并且触发的回调是父组件的请求函数</p><p>第三个问题，直接将 hoc 组件上的$attrs 和 $listeners 绑定到子组件的 props 和 $listeners 中，其中有个 v-bind 绑定的点，v-bind 总是会属性绑定到 props 中，对是否是 props 的处理，都是子组件的关心的，而不是父组件关心的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withPromise = <span class="function">(<span class="params">component, promiseFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        loading: <span class="literal">false</span>,</span><br><span class="line">        content: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(component, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...this.attrs,</span><br><span class="line">          loading: <span class="keyword">this</span>.loading,</span><br><span class="line">          content: <span class="keyword">this</span>.content,</span><br><span class="line">        &#125;,</span><br><span class="line">        on: <span class="keyword">this</span>.$listeners,</span><br><span class="line">        ref: <span class="string">"component"</span>, <span class="comment">// 用于在mounted时获取实例</span></span><br><span class="line">        scopedSlot: <span class="keyword">this</span>.$scopedSlot</span><br><span class="line">      &#125;, <span class="keyword">this</span>.$children);  <span class="comment">// 注意 $children 和 $slot的区别</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getContent() &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">        promiseFn(<span class="keyword">this</span>.$refs.component.requestParams)</span><br><span class="line">          .then(<span class="function">(<span class="params">content</span>) =&gt;</span> (<span class="keyword">this</span>.content = content))</span><br><span class="line">          .finally(<span class="function"><span class="params">()</span> =&gt;</span> (<span class="keyword">this</span>.loading = <span class="literal">false</span>));</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.getContent();</span><br><span class="line">      <span class="keyword">this</span>.$refs.component.$watch(<span class="string">'requestParams'</span>, <span class="keyword">this</span>.getContent())</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newComponent = withPromise(view, getContent)</span><br><span class="line"><span class="comment">// &lt;newComponent onClick="xxx"&gt;xxxx&lt;/newComponent&gt;</span></span><br></pre></td></tr></table></figure><p>其实还有个问题，发现没有，就是还是没法将ref进行传递。 要想获取到子组件需要一直ref来使用。</p><h3 id="新增props处理"><a href="#新增props处理" class="headerlink" title="新增props处理"></a>新增props处理</h3><p>上面代码中对于props处理在每个HOC组件中都差不多类似。简单一点通过<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalProps = <span class="function">(<span class="params">vm</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        attrs: <span class="keyword">this</span>.vm.$attrs,</span><br><span class="line">        on: <span class="keyword">this</span>.vm.$listeners,</span><br><span class="line">        slotScopeds: <span class="keyword">this</span>.vm.$slotScopeds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h(compoennt, &#123;...normalProps(<span class="keyword">this</span>), <span class="attr">props</span>: &#123;&#125;&#125;, <span class="keyword">this</span>.$children)</span><br></pre></td></tr></table></figure></p><h2 id="组合优于HOC"><a href="#组合优于HOC" class="headerlink" title="组合优于HOC"></a>组合优于HOC</h2><p>组合的意识是通过compose的方式将原有的HOC  fn3(fn2(fn1))的方式变成compose(fn1, fn2, fn3)，将组件作为传递。如果withPromise没有参数，都不需要包装<br>compose(() =&gt; withPromise(), withLog)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vue 中组件复用的方式有 mixin，extend，高阶组件和组合组件三种方式&lt;/p&gt;
&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="https://blog.xunserver.cn/archives/e919cac4.html"/>
    <id>https://blog.xunserver.cn/archives/e919cac4.html</id>
    <published>2022-11-21T02:48:53.000Z</published>
    <updated>2022-11-21T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="axios-中间件"><a href="#axios-中间件" class="headerlink" title="axios 中间件"></a>axios 中间件</h3><p>axios将拦截函数处理成pormise的resolve和reject函数，通过promise链来完成中间件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        name: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        error: error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.use = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.interceptorsData.push(&#123;</span><br><span class="line">        resolve, reject</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    axios.interceptorsData.reduce(<span class="function">(<span class="params">promise, current</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(current.resolve).catch(current.reject)</span><br><span class="line">    &#125;)  <span class="comment">// 通过一次性构建promise链实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="vuex中间件"><a href="#vuex中间件" class="headerlink" title="vuex中间件"></a>vuex中间件</h3><p>vuex 中间通过aop的方式添加中间件，在原有处理逻辑上增加前置或者后置操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vuex.plugin = <span class="function">(<span class="params">&#123;before, after&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    vuex.dispatch.before(before)</span><br><span class="line">    vuex.dispatch.before(after)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        beforeFn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(thism, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="reduce中间件"><a href="#reduce中间件" class="headerlink" title="reduce中间件"></a>reduce中间件</h3><p>通过组合函数的形式，将函数的结果传入下一个函数，compose(fn1, fn2, fn3) = fn3(fn2(fn1()))，见store篇章</p><h3 id="koa中间件"><a href="#koa中间件" class="headerlink" title="koa中间件"></a>koa中间件</h3><p>有点像yeild的方式，每次调用中间件，都是把下一个中间的传入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">middleware.use(<span class="function">(<span class="params">ctx, next</span>)=&gt;</span> &#123;</span><br><span class="line">    ctx.xxx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.xxx)</span><br><span class="line">&#125;)</span><br><span class="line">middleware.run = <span class="function">(<span class="params">i=<span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = middleware.data[i]   <span class="comment">// 保存的所有中间件</span></span><br><span class="line">    <span class="keyword">if</span>(!current[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, middleware.run(i + <span class="number">1</span>)))  <span class="comment">// 通过这种方式实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本质上中间件是一个按照既定模板来实现流式编程的工具，通过这种方式，外部的代码可以侵入到内部实现去耦合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;axios-中间件&quot;&gt;&lt;a href=&quot;#axios-中间件&quot; class=&quot;headerlink&quot; title=&quot;axios 中间件&quot;&gt;&lt;/a&gt;axios 中间件&lt;/h3&gt;&lt;p&gt;axios将拦截函数处理成pormise的resolve和reject函数，通过pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>axios</title>
    <link href="https://blog.xunserver.cn/archives/a09486d2.html"/>
    <id>https://blog.xunserver.cn/archives/a09486d2.html</id>
    <published>2022-11-21T02:27:06.000Z</published>
    <updated>2022-11-21T02:27:06.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack hook体系</title>
    <link href="https://blog.xunserver.cn/archives/390d2d6d.html"/>
    <id>https://blog.xunserver.cn/archives/390d2d6d.html</id>
    <published>2022-11-18T13:11:38.000Z</published>
    <updated>2022-11-18T13:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>webpack 在执行流程中通过大量的hook对外暴露出当前的执行流程，并允许外界程序通过hook修改或者自定义程序行为。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SyncHook &#125; <span class="keyword">from</span> <span class="string">'tapable'</span>;</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> SyncHook;</span><br><span class="line"></span><br><span class="line">sleep.tap(<span class="string">'test-name'</span>, (webpackContext) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(webpackContext);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test-name callback'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sleep.call(some)</span><br></pre></td></tr></table></figure></p><p>由上面可以看到，webpack hook 机制就是新建hook, 插件订阅hook，webpack内部触发hook、<br>针对这三个流程，又做了详细的扩充</p><h3 id="创建hook"><a href="#创建hook" class="headerlink" title="创建hook"></a>创建hook</h3><p>webpack 有不同的hook,不同hook表示内部的回调如何执行。<br>按照回调逻辑区分</p><ul><li>正常依次执行回调</li><li>waterfall:前一个回调的值会带入下一个回调</li><li>bail 依次调用回调，如果有任何一个回调的值返回undefined，后续的回调值取消</li><li>loop 循环执行回调， 直到有一个回调返回undefined</li></ul><p>按照执行回调的方式区分</p><ul><li>sync 同步的执行回调，通过return 返回回调的结果</li><li>async 异步的执行的回调，通过return promies 结果或者callback结果。异步的钩子通过同步的方式执行没有意义拿不到结果，当然不需要结果的除外。</li></ul><h3 id="订阅hook"><a href="#订阅hook" class="headerlink" title="订阅hook"></a>订阅hook</h3><p>有tap(同步订阅),tapAsync(异步订阅)和tapPromise(返回一个promise订阅的方式)</p><h3 id="执行hook"><a href="#执行hook" class="headerlink" title="执行hook"></a>执行hook</h3><p>执行回调的方式有call(依次执行回调函数，会等回调函数执行完), callAsync(异步的依次执行函数，不会等待)，promise(返回一个promise来表示回调的执行结果)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;webpack 在执行流程中通过大量的hook对外暴露出当前的执行流程，并允许外界程序通过hook修改或者自定义程序行为。&lt;br&gt;&lt;figu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macos安装笔记</title>
    <link href="https://blog.xunserver.cn/archives/772650a1.html"/>
    <id>https://blog.xunserver.cn/archives/772650a1.html</id>
    <published>2022-11-15T07:21:53.000Z</published>
    <updated>2022-11-15T07:21:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><ol><li>谷歌浏览器，国内网络使用Safri下载有问题，通过</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;必备软件&quot;&gt;&lt;a href=&quot;#必备软件&quot; class=&quot;headerlink&quot; title=&quot;必备软件&quot;&gt;&lt;/a&gt;必备软件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;谷歌浏览器，国内网络使用Safri下载有问题，通过&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack 配置优化通用步骤</title>
    <link href="https://blog.xunserver.cn/archives/4525b971.html"/>
    <id>https://blog.xunserver.cn/archives/4525b971.html</id>
    <published>2022-11-06T14:19:53.000Z</published>
    <updated>2022-11-06T14:19:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>webpack优化指的两个方便，第一个是打包过程优化，提高打包效率，缩小打包时间。第二个是上线项目的优化，通过配置优化chunk，提高线上加载速度。</p><h3 id="优化打包流程"><a href="#优化打包流程" class="headerlink" title="优化打包流程"></a>优化打包流程</h3><h4 id="resolve-modules-resolve-extensions"><a href="#resolve-modules-resolve-extensions" class="headerlink" title="resolve.modules, resolve.extensions"></a>resolve.modules, resolve.extensions</h4><p>. resovle.modules 用于限定node_module查找范围，默认情况下是从会遍历到文件系统根目录，通过配置指定的node_module 减少查找范围,配置到项目的node_module即可<br>. resolve.extensions 当解析模块时，模块无后缀名时查找顺序，使用正确的扩展名方便查询。如果是ts项目，将ts排列在最前面，如果是vue项目，添加vue到最前面(不过一般来说不同，vue项目要求需要将.vue在代码中补全，以获得编辑器的补全功能)</p><h4 id="module-noParse"><a href="#module-noParse" class="headerlink" title="module.noParse"></a>module.noParse</h4><p>当引入第三方模块时，一般第三方已经编译过，没必要webpack再次编译处理。使用noParse让webpack停止对模块的继续解析。</p><h4 id="module-rule-loader、resolveLoader"><a href="#module-rule-loader、resolveLoader" class="headerlink" title="module.rule.loader、resolveLoader"></a>module.rule.loader、resolveLoader</h4><p>在配置loader时，loader使用的require(‘xxx-loader’)来加载，也会遍历到根模块，使用一个绝对路径来配置。<br>resolveLoader 配置loader的查找目录</p><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;webpack优化指的两个方便，第一个是打包过程优化，提高打包效率，缩小打包时间。第二个是上线项目的优化，通过配置优化chunk，提高线上加
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>家庭wifi组件方案</title>
    <link href="https://blog.xunserver.cn/archives/e77ca00e.html"/>
    <id>https://blog.xunserver.cn/archives/e77ca00e.html</id>
    <published>2022-10-31T02:39:11.000Z</published>
    <updated>2022-10-31T02:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近搭建家庭wifi，目前屋里的wifi客厅放一个，在房间信号不是很好。需要搭建一个支持漫游的wifi方案，爱快、高恪等方案太贵，开源的padavan漫游效果又太差。综合下来集客的AC + Ap方案性价比比较高。在房间和客厅任意走动，wifi不会出现断的情况。</p><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>集客方案需要AC一个和多个AP，AC主要是起一个控制调度作用，AP负责信号的发送，AC需要设备配置不用多高，而且不需要网络，我的设备如下<br>AC: 小米路由器mini * 1   闲鱼、PDD 大概30内包邮<br>AP1: JCG Q20/q10 pro（支持wifi6，书房给mac用）   闲鱼 大概 70 一个<br>AP2：红米 AC2100（作为客厅主力AP）     闲鱼85包邮<br>AP3: 小米路由器pro（备用机器，刷了padavan随时接管屋里wifi）   闲鱼85包邮<br>AP4：vs010（ax3000）   闲鱼90包邮<br>AP5：rax3000Q（ax3000）   闲鱼100包邮<br>AP6：大麦 dw33d （ac 1750） 闲鱼45包邮<br>AP7: 华硕arch17             闲鱼120包邮<br>AP8: 小米R3G (ac 1200， 最能造的机器)    闲鱼 50包邮<br>上面的方案中小米路由器不支持集客AP方案，刷了246ND能正常开机和只能打开2.4G wifi，只能降级作为备用机器，不参与家庭AP。其他设备都可以选择，都是自己折腾过能用的设备。</p><h3 id="小米路由器mini-刷入-AC"><a href="#小米路由器mini-刷入-AC" class="headerlink" title="小米路由器mini 刷入 AC"></a>小米路由器mini 刷入 AC</h3><h4 id="breed"><a href="#breed" class="headerlink" title="breed"></a>breed</h4><ol><li><a href="http://miwifi.com/miwifi_download.html" target="_blank" rel="noopener">官方固件</a>去下载自己的型号的开发版固件</li><li>电脑网页登录路由器后台管理页面，一般是<a href="http://192.168.31.1/" target="_blank" rel="noopener">192.168.31.1</a>。右上角找到固件升级，上传开发版固件升级。</li><li>升级完后，手机小米wifi app绑定路由器</li><li>官方查看SSH密码， <a href="https://d.miwifi.com/rom/ssh" target="_blank" rel="noopener">https://d.miwifi.com/rom/ssh</a>，并按照提示刷入解锁固件（注意，如果下载工具失败，浏览器控制台找到报错的文件，直接下载），U盘除了放入解锁固件外，还需要把breed的固件也同时放入，在<a href="https://breed.hackpascal.net/" target="_blank" rel="noopener">https://breed.hackpascal.net/</a>中找到xiaomini的breed固件，下载放入U盘即可。</li><li>按照官方提示解锁固件后，登录路由器后台SSH（直接 ssh <a href="mailto:root@192.168.31.1" target="_blank" rel="noopener">root@192.168.31.1</a>或者使用putty等工具）。首先备份固件 cat /proc/mtd 查看分区，然后使用 dd if=/dev/mdt0 of=/extdisks/sda4/xxx.bin 挨着备份固件到U盘。备份完成后使用 mtd_write write breed.bin Bootloader 刷入 breed。刷入后等10S拔电即可。</li></ol><h4 id="刷入集客AC"><a href="#刷入集客AC" class="headerlink" title="刷入集客AC"></a>刷入集客AC</h4><ol><li><a href="http://file.cnrouter.com/" target="_blank" rel="noopener">集客官方</a>网页下载 企业路由X1 固件。</li><li>连接好网线，先捅reset不放 ，再开机，10S后松开</li><li>电脑浏览器192.168.1.1 进入控制台。固件更新页面，选择固件X1固件上传。等待刷机后即可。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>集客AC目前是旁AC模式，简单的将原有网络插入wan口即可，不会对原有网络侵扰，如果不使用小米路由器mini，也可以使用虚拟机安装一个x86的集客AC控制器</p><h3 id="小米R3G-刷入集客AP"><a href="#小米R3G-刷入集客AP" class="headerlink" title="小米R3G 刷入集客AP"></a>小米R3G 刷入集客AP</h3><p>小米R3G首先刷入breed，方法同上面小米mini。同样是breed控制台刷入集客AP246ND固件（集客选择MKT AP就能找到），刷入好网线接入到wan口</p><h3 id="AC管理"><a href="#AC管理" class="headerlink" title="AC管理"></a>AC管理</h3><p>AC和AP通电后都接入同一个局域网，等待1分钟后，AP会自动发现AC。到路由器的管理页面查看是否有新设备（有GECOO开头的就是），一个IP一个IP的试，有输入的用户名和密码的就是AC控制器。AC控制器的默认密码是changemeplease。进入后修改各种参数集客，5G射频2不用管，配置了也没得用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近搭建家庭wifi，目前屋里的wifi客厅放一个，在房间信号不是很好。需要搭建一个支持漫游的wifi方案，爱快、高恪等方案太贵，开源的pa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>qiankun</title>
    <link href="https://blog.xunserver.cn/archives/3be36193.html"/>
    <id>https://blog.xunserver.cn/archives/3be36193.html</id>
    <published>2022-10-29T03:26:33.000Z</published>
    <updated>2022-10-29T03:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>qiankun有自动加载和手动加载。自动预先注册微应用，当微应用的activeRule和浏览器url匹配时（可以同时匹配多个），执行挂载逻辑。手动加载，按需的将某个子应用挂载到特定容器上。</p><p>qiankun的entry可以是html（会按照下文import-html-entry解析），也能一个是style、js和html 字符串地址组成的对象。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>子应用需要将publicPath动态的设置为全局变量 window.<strong>INJECTED_PUBLIC_PATH_BY_QIANKUN</strong>，webpack的动态配置需要在入口文件中配置，而且如果esm，还需要新建一个文件来配置</li><li>子应用挂载时，需要避免挂载到主应用的root元素上。使用props.container.querySelector(‘#root’)</li><li>通过window.<strong>POWERED_BY_QIANKUN</strong> 来判断当前应用是否被当做了子应用</li><li>子应用需要配置跨域，因为主应用加载资源都是通过fetch函数进行加载（fetch 有跨域问题）</li><li>entryjs需要放在html中的最后一个脚本，或者通过script entry属性标记出来</li><li>如果子应用是在懒挂载在路由页面，主应用的路由配置需要在子路由之前，因为主应用的路由也是监听的popState的变化来渲染对应的页面，qiankun也是监听的同样，按照先注册监听函数先执行。</li><li>只有手动挂载的子应用才有update声明周期</li><li>如果资源的请求需要额外的自定义属性，需要自定义fetch方法，比如静态资源请求需要cookie等情况</li><li>最好给入口文件的文件类型修改成text/plain，避免运营商搞操作</li><li>不要qiankun处理的js，添加ignore属性即可</li></ol><h3 id="import-html-entry"><a href="#import-html-entry" class="headerlink" title="import-html-entry"></a>import-html-entry</h3><p>微服务实现的核心，通过解析入口文件获取子应用的html、css和js。同时对解析出的部分进行处理以方便加载</p><h4 id="获取html并处理"><a href="#获取html并处理" class="headerlink" title="获取html并处理"></a>获取html并处理</h4><p>通过fetch加载入口对应的html文件字符串（fetch 下来都是字符串）。然后对html字符串进行正则匹配处理，大致包括以下内容。</p><ol><li>去掉所有注释</li><li>注释所有的js引用语句，注释所有的内联js代码。（当然是先保存了）</li><li>注释掉所有的css引用语句，但是保留了内联css语句</li></ol><h4 id="处理css引用"><a href="#处理css引用" class="headerlink" title="处理css引用"></a>处理css引用</h4><p>在上一步中也不是完全是注释所有的css引用语句，而是在同一个地方使用fetch语句拉取对应的外部css，处理后再通过style标签在原地方引用。</p><h3 id="路由挂载子应用"><a href="#路由挂载子应用" class="headerlink" title="路由挂载子应用"></a>路由挂载子应用</h3><p>如果部分子应用是挂载到部分路由页面的，有可能出现子应用挂载时找不到容器的情况，原因是这个容器还在主应用中懒加载。有两个解决方法，第一个是在主应用路由页面手动loadApp。需要保证加载子应用时，存在container容器</p><h3 id="子应用卸载"><a href="#子应用卸载" class="headerlink" title="子应用卸载"></a>子应用卸载</h3><p>在自动模式下，切换路由时，qiankun会自动调用子应用的unmount方法将子应用卸载，但是在手动模式下，loadMicroApp()会返回子应用实例，实例上有unmount方法。</p><p>还有个问题，子应用的副作用需要自行清理吗？比如settimeout setinteral等副作用。答案是否，当然也可以自行清理。qiankun在挂载子应用时通过沙箱的形式重写了全局变量，并且劫持了setInterval 等副作用函数。对于addeventlistener，也是重写了函数，额外添加了收集逻辑，在卸载时会一一取消绑定</p><p>新的问题是，子应用卸载后再次挂载时会默认加载之前的状态，子应用修改的全局变量会加载，子应用动态添加的style会恢复。但是样式的解析始终是根据style在文档的位置来决定，如果再次挂载的子应用style添加在第一次后面，可能会出现一些意外情况。</p><ol><li>子应用卸载时，子应用的fakeWindow不会消失，再次挂载继续使用。</li><li>基于上面的理论，因为子应用通过umd打包，导出了一个挂载的window上面的全局变量。再次加载子应用时，重复的<strong>webpack_require</strong>.d 不会重复执行（参考cjs或则esm），也会导致动态创建的style不会再次挂载。</li><li>针对上面的情况，qiankun在自用调用documen.head.appendchild时会劫持该方法。把动态创建的style保存到起来，当子应用再次挂载时会添加到子应用之前对应的位置中，所以需要保证子应用的style是通过该方法添加的才能劫持。</li></ol><h3 id="子应用动态的style是怎样添加的，为什么没有添加到主应用上的head中"><a href="#子应用动态的style是怎样添加的，为什么没有添加到主应用上的head中" class="headerlink" title="子应用动态的style是怎样添加的，为什么没有添加到主应用上的head中"></a>子应用动态的style是怎样添加的，为什么没有添加到主应用上的head中</h3><p>上文了解到，在html entry中style和css link能够被收集处理，但是webpack打包后的css基本都是动态加载,webpack本身是无法判断该style插入到子应用还是主应用。qiankun通过fakeWindow实现了对appenchild，insertBefore方法的劫持，在调用时判断是主应用还是子应用调用，从而插入到相应位置，同理对应的svg处理逻辑叶鸿昌</p><h3 id="样式沙箱"><a href="#样式沙箱" class="headerlink" title="样式沙箱"></a>样式沙箱</h3><p>样式沙箱包括上面的动态加载style，link和对样式的隔离。如果开启了严格沙箱模式，在静态的css字符串被fetch回来时，出对每一个样式添加添加唯一前缀，对于动态加载的样式，在拦截中添加唯一前缀</p><h3 id="子应用资源加载路径问题"><a href="#子应用资源加载路径问题" class="headerlink" title="子应用资源加载路径问题"></a>子应用资源加载路径问题</h3><p>之前我们一直推崇是publicPath为相对路径，通过文档的base来查找资源（为了方便多级部署），在qiankun中，因为一个文档只有拥有一个base，子应用会使用主应用的base导致出错，所以子应用必须要使用绝对路径，这个路劲要么是在编译时配置，要么是在设置为动态地址。不过有一点css中对资源的引用是在编译时确定的，而且不管相对绝对都是根据主应用来确定的</p><p>如果说非要用动态地址，那么子应用的中css的资源必须是完整路径，或者将对应的资源编译成base 64，改行内应用。</p><h3 id="js沙箱"><a href="#js沙箱" class="headerlink" title="js沙箱"></a>js沙箱</h3><p>qiankun又名sandbox + html entry + single-spa。核心就是沙箱模式，通过沙箱默认子应用可以随意的造，不用担心影响主应用或者其他子应用<br>qiankun目前有三种沙箱模式，快照沙箱（snapshot），高级沙箱(legacy)和代理沙箱(proxy)。</p><p>快照沙箱，当沙箱激活时给当前的window拍摄一个照片，把当前window的拷贝给快照。然后将改动的沙箱赋值给window，当沙箱取消时，将快照还原，保存沙箱激活期间所有的操作，带下次激活时恢复。实现起来比较简单，就是深拷贝window即可。缺点是window属性众多，激活和失活时都要做全量拷贝，同时是在windows变量本身做操作会污染window变量。</p><p>高级沙箱，也叫单例代理沙箱，快照沙箱的升级版本，通过this.fakeWindow代理Proxy记录属性的删除新增和更新。只记录变化的属性，在激活和失活时也只用操作部分属性，但是属性的还是会操作到window上。性能变高，但是还是没有解决单例问题，只能在一个微应用的场景使用</p><p>代理沙箱，在高级沙箱的基础上，升级了到多例模式，而且不会对window进行操作。所有操作都代理到了fakeWindow上。</p><h3 id="应用间通信"><a href="#应用间通信" class="headerlink" title="应用间通信"></a>应用间通信</h3><p>qiankun自带应用通信方案，主应用会暴露出一个发布订阅的组件。子应用之间、主应用相互订阅发布。如果主应用声明了全局变量，子应用会默认在mount的props添加对应的方法。</p><p>需要注意的是，初始化全局state需要在注册子应用之后，调用start之前。</p><p>不过官方提供的应用间通信属实捡漏，基本只适用于demo，在开发中需要通过注册组件时提供props的形式注入。vue中可以使用ref和reactive来当做发布订阅，前提条件是主子应用同一个Vue(vue依赖是在另一个dep存放的，不在变量上)。</p><p>社区中有shared方案，大致逻辑是主应用和子应用同时维护一份store，子应用初始化时监听主应用的变化，并触发自己的action。同时子应用也有主应用的dispatch。也能触发主应用store。这个方案有如下问题未解决</p><ol><li>主应用中对于怎么样按照模块划分，如何结合现有状态管理技术栈</li><li>子应用会无脑监听主应用状态变化，出现回调地狱，需要增加子应用的判断指定监听的逻辑</li></ol><p>还有种方案是单例全局状态，将主应用的状态管理通过props传递到子应用。</p><h3 id="应用间共享依赖"><a href="#应用间共享依赖" class="headerlink" title="应用间共享依赖"></a>应用间共享依赖</h3><p>qiankun不推荐运行时共享，不过在生产中势必会出现共享代码的情况。比如公共的vue，react，react-dom等依赖。qiankun不推崇原因是应用应该被视为一个独立的个体，如果有运行时依赖，应用单独运行会有问题<br>我目前只推荐使用externals的形式共享，将externals的变量挂载到全局中实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">        <span class="string">'vue'</span>: <span class="string">'vue'</span>   <span class="comment">// 编译后代码是 export default = vue   相当于在全局空间查找vue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有种方案是通过props共享，这种方法的弊端是子应用没法获得补全等功能，同时子应用也独立运行时<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; component, utils, config &#125; <span class="keyword">from</span> <span class="string">'./lib'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    name: <span class="string">'app1'</span>,</span><br><span class="line">    entry: <span class="string">'http://localhost:8081'</span>,</span><br><span class="line">    container: <span class="string">'#app-container'</span>,</span><br><span class="line">    activeRule: <span class="string">'#/app1'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        component,   <span class="comment">// 共享主应用的组件</span></span><br><span class="line">        utils,       <span class="comment">// 共享主应用的方法</span></span><br><span class="line">        config       <span class="comment">// 主应用的配置等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>应用之前还存在共享依赖，比如应用A，应用B都打包了某个依赖，如果应用A先加载了依赖，应用B就直接使用依赖，不需要再加载自身打包的依赖。<br>也是通过全局的变量共享实现，如果在全局空间找到有相同的依赖，则不加载。其实这个也能作为externals</p><h3 id="路由规划指南"><a href="#路由规划指南" class="headerlink" title="路由规划指南"></a>路由规划指南</h3><p>保持一致是最佳选择。主应用切记不要*管理路由404路由，通过添加全局路由钩子(beforeEach，判断当前跳转的路径是否是404), 子应用需要配置base前缀来保持路由。</p><p>子应用通过history.pushState来实现对主应用的跳转或则通过主应用提供的方法来实现。</p><h3 id="动态添加子应用"><a href="#动态添加子应用" class="headerlink" title="动态添加子应用"></a>动态添加子应用</h3><p>除了手动的加载子应用外，qiankun还支持动态添加，重复执行registerMircoApp()会动态的添加， 相同name的忽略。</p><h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><p>qiankun中子应用的publicPath自动设置为entry的根路径，通过start的参数getPublicPath设置 <strong>INJECTED_PUBLIC_PATH_BY_QIANKUN</strong><br>常见于子应用是二级部署的情况。</p><h3 id="工程化探索实践"><a href="#工程化探索实践" class="headerlink" title="工程化探索实践"></a>工程化探索实践</h3><ul><li>主应用通过全局的生命周期钩子，beforeLoad和afterLoad添加加载进度条。</li><li>请务必将配置集中化，比如子应用的base交给主应用管理。子应用不要写死。</li></ul><p>参考文章</p><ul><li><a href="https://juejin.cn/post/6993233221173542926#heading-7" target="_blank" rel="noopener">微前端学习系列(三)</a></li><li><a href="https://juejin.cn/post/7070032850237521956" target="_blank" rel="noopener">微前端01 : 乾坤的Js隔离机制原理剖析（快照沙箱、两种代理沙箱）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;qiankun有自动加载和手动加载。自动预先注册微应用，当微应用的activeRule和浏览器url匹配时（可以同时匹配多个），执行挂载逻辑
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模块联邦</title>
    <link href="https://blog.xunserver.cn/archives/eb9216b6.html"/>
    <id>https://blog.xunserver.cn/archives/eb9216b6.html</id>
    <published>2022-10-27T03:01:53.000Z</published>
    <updated>2022-10-27T03:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>模块联邦提供了一种运行时的加载其他服务下模块的能力,通过下面几个问题来解决生产中模块联邦的问题</p><ol><li>模块联邦在项目源码中并不会体现，如果packageA引入了packageB，如何保证自动补全、ts类型等功能</li><li>项目工程化如何设计，单仓库还是多仓库，项目如何启动</li><li>开发环境和线上环境如何设计</li><li>和微服务框架如何结合</li></ol><h3 id="webpack中的模块联邦"><a href="#webpack中的模块联邦" class="headerlink" title="webpack中的模块联邦"></a>webpack中的模块联邦</h3><p>webpack中通过MF插件提供了简单配置容器和加载容器的功能<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    plugins: [<span class="keyword">new</span> webpack.ModuleFederationPlugin(&#123;</span><br><span class="line">        name: <span class="string">"main_app"</span>, <span class="comment">// 本身对外暴露出的入口</span></span><br><span class="line">        filename: <span class="string">"remoteEntry.js"</span>,  <span class="comment">// 入口文件</span></span><br><span class="line">        exposes: &#123;</span><br><span class="line">            <span class="string">'./functionA'</span>: <span class="string">'./src/xxx/a.js'</span>  <span class="comment">// 暴露出的文件</span></span><br><span class="line">        &#125;,</span><br><span class="line">        share: [<span class="string">'vue'</span>], <span class="comment">// 共享的模块， 不会重复打包</span></span><br><span class="line">        remote: &#123;  <span class="comment">// 需要加载的远程package</span></span><br><span class="line">            <span class="string">'packageB'</span>: <span class="string">'packageB@http://localhost:3001/remoteEntry.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在packageA中使用packageB的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functionA <span class="keyword">from</span> <span class="string">"packageB/functionA"</span></span><br><span class="line"><span class="built_in">console</span>.log(functionA)</span><br></pre></td></tr></table></figure></p><h2 id="模块联邦"><a href="#模块联邦" class="headerlink" title="模块联邦"></a>模块联邦</h2><p>模块联邦提供了加载其他模块的能力，可以用于跨项目共享chunk。</p><ul><li>本地模块指的是入口文件构建的模块，远程模块是MF定义出的。相当于共享配置的两个入口文件。</li><li>每个构建都是一个容器，容器可以加载远程模块。</li><li>远程模块需要使用异步的方式加载。</li><li>远程模块也可以作为容器加载其他远程模块。</li><li>远程模块中，因为publicPath是简单的拼接，如果设置了publicPath会出现加载宿主域的问题。需要将publicPath设置为auto或则动态设置。</li><li>远程模块至少会生成runtime、remote和module 3种chunk文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MF = webpack.container.ModuleFederationPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 打包逻辑 runtime -&gt; remote.js -&gt; ./componentA</span></span><br><span class="line">    <span class="keyword">new</span> MF(&#123;</span><br><span class="line">      name: <span class="string">'remote'</span>,  <span class="comment">// 远程模块名称</span></span><br><span class="line">      filename: <span class="string">'remote.js'</span>, <span class="comment">// 生成的远程模块文件，用于宿主容器加载</span></span><br><span class="line">      runtime: <span class="string">'remote.runtime.js'</span>, <span class="comment">// 默认情况下runtime文件生成在filename 定义的文件中，可以单独抽离出来。</span></span><br><span class="line">      exposes: [&#123;</span><br><span class="line">        <span class="string">'./componentA'</span>: <span class="string">'./src/componentA.vue'</span>  <span class="comment">// 需要使用./前缀，host 通过 import('remote/componentA')</span></span><br><span class="line">        <span class="string">'.'</span>: <span class="string">'src/componentA/index.js'</span>  <span class="comment">// import('remote')</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态设置publicPath"><a href="#动态设置publicPath" class="headerlink" title="动态设置publicPath"></a>动态设置publicPath</h3><p>因为runtime.js 需要加载remote.js和module.js 所以需要提前设置publicPath。MF在打包时如果container chunk和入口chunk同名，会合并。所以需要将name设置为一个入口name相同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./index.js'</span>,</span><br><span class="line">    remote: <span class="string">'./public-path.js'</span> <span class="comment">// 在入口文件中配置动态的js。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MF(&#123;</span><br><span class="line">      name: <span class="string">'remote'</span>,  <span class="comment">// 远程模块名称</span></span><br><span class="line">      filename: <span class="string">'remote.js'</span>, <span class="comment">// 生成的远程模块文件，用于宿主容器加载</span></span><br><span class="line">      runtime: <span class="string">'remote.runtime.js'</span>, <span class="comment">// 默认情况下runtime文件生成在filename 定义的文件中，可以单独抽离出来。</span></span><br><span class="line">      exposes: [&#123;</span><br><span class="line">        <span class="string">'./componentA'</span>: <span class="string">'./src/componentA.vue'</span></span><br><span class="line">        <span class="string">'.'</span>: <span class="string">'src/componentA/index.js'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态加载远程模块"><a href="#动态加载远程模块" class="headerlink" title="动态加载远程模块"></a>动态加载远程模块</h3><p>正常情况下远程模块是在webpack配置中制定的，可以手动实现远程模块的加载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadModule = <span class="keyword">async</span> (url, containerName, <span class="built_in">module</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> loadScript(url);   <span class="comment">// 加载remoteEntry js 脚本。</span></span><br><span class="line">  <span class="keyword">const</span> container = <span class="built_in">window</span>[containerName];  <span class="comment">// 默认情况下remoteEntry 按照var 导出。 通过window containerName 可以获取到container。</span></span><br><span class="line">  <span class="keyword">const</span> factory = <span class="keyword">await</span> container.get(<span class="built_in">module</span>)  <span class="comment">// get方法是一个异步的方法，获取的是modules里的value。</span></span><br><span class="line">  <span class="keyword">return</span> factory()  <span class="comment">// 执行一次相当于执行了module文件。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码不够完整，缺少共享模块的加载以及重复引用下module不是单例问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> remoteModuleCache = <span class="keyword">new</span> <span class="keyword">set</span>();</span><br><span class="line">let loadModule = async (url, containerName, module) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(hasCache(container, <span class="built_in">module</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getCache()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> loadScript(url);   <span class="comment">// 加载remoteEntry js 脚本</span></span><br><span class="line">  <span class="keyword">await</span> __webpack_init_sharing__(<span class="string">'default'</span>)  <span class="comment">// 全局初始化共享模块</span></span><br><span class="line">  <span class="keyword">const</span> container = <span class="built_in">window</span>[containerName];  <span class="comment">// 默认情况下remoteEntry library 按照var 导出。 通过window containerName 可以获取到container。</span></span><br><span class="line">  container.init(__webpack_share_scoped__.default)</span><br><span class="line">  <span class="keyword">const</span> factory = <span class="keyword">await</span> container.get(<span class="built_in">module</span>)  <span class="comment">// get方法是一个异步的方法，获取的是modules里的value。</span></span><br><span class="line">  <span class="keyword">return</span> factory()  <span class="comment">// 执行一次相当于执行了module文件。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="远程模块加载流程"><a href="#远程模块加载流程" class="headerlink" title="远程模块加载流程"></a>远程模块加载流程</h3><ol><li><strong>webpack_modules</strong> 声明了remoteEntry入口文件。</li><li>通过<strong>webpack_require</strong>.e 调用 <strong>webpack</strong>require.f.remote 中间件加载入口js文件。</li><li>入口js文件加载好后，在全局暴露remote变量</li><li>host中加载远程模块的module会固定编译成 一个chunkid，</li><li>host 会调用remote去获取这个chunkId对应的js文件，</li><li>加载完成后回调在remote中，然后host执行这个remote中的回调函数得到module。</li></ol><h3 id="远程模块踩坑"><a href="#远程模块踩坑" class="headerlink" title="远程模块踩坑"></a>远程模块踩坑</h3><ol><li>远程模块的异步chunk加载方式务必不要和host应用雷同，会出现覆盖host modules问题。大坑，使用 output.chunkLoadingGlobal、output.uniquename修改</li><li>目前自动加载远程模块的方式仅默认方式能生效，即把远程模块绑定到全局变量上。其他的方式均需要自行加载远程模块</li></ol><h3 id="在vite中使用模块联邦"><a href="#在vite中使用模块联邦" class="headerlink" title="在vite中使用模块联邦"></a>在vite中使用模块联邦</h3><p>vite社区已经实现@originjs/vite-plugin-federation, 配置方式和webpack差不多</p><h3 id="如何保证packageB的自动补全"><a href="#如何保证packageB的自动补全" class="headerlink" title="如何保证packageB的自动补全"></a>如何保证packageB的自动补全</h3><p>有如下两种场景，一是packageB和packageA使用了pnpm的monorepo的方案，一种是packageB在另一个地方。第一种场景比较简单，直接在pnpm add packageB作为packageA为依赖，编辑器中就能获得所有补全，但是需要引入的packageB和源码结构类似。虽然在packageA中引用了packageB，但是并不会真正打包，这种情况存在路径映射的问题（通过package新特性支持，通过exports指明对应文件的type,这种方式需要在tsconfig中指定moduleRelution为我为Node16 或者nodenext）。第二种情况是packageB不和packageA在同一个仓库，需要对packageB进行申明文件构建，申明文件选择一个新的目录，在packageA的tsconfig中正常添加这个申明文件的引用，通过typeRoot添加一个。通过设置rootDir还能实现对第一种方案中路径映射的调整</p><h3 id="单仓库还是多仓库"><a href="#单仓库还是多仓库" class="headerlink" title="单仓库还是多仓库"></a>单仓库还是多仓库</h3><p>新项目无脑单仓库，自带补全功能美滋滋。</p><p>但是模块联邦目前不能很好的和monorepo结合，比如monorepo引用的是packageB的dist后的代码，但是模块联邦需要的是源码方便调试（也可以只把申明文件输出到dist目录中），两者存在冲突。模块联邦的这种黑科技方式对项目也是破坏性，所以还是推荐自行添加types到packageA的依赖中（生成声明文件时，声明文件也可以添加resouremap选项也能重定向到源代码，这个特性重要重要重要，需要珍藏）</p><h3 id="开发环境和线上环境的结合"><a href="#开发环境和线上环境的结合" class="headerlink" title="开发环境和线上环境的结合"></a>开发环境和线上环境的结合</h3><p>模块联邦主要的组件和复用，非应用的复用。在monorepo开发环境中，删除对模块联邦的使用，使用packageA打包packageB依赖（因为已经申明了packageB，可以放心大胆的删除），这个好处是不用启用多个服务，一个服务解决。</p><h3 id="和微服务框架如何结合"><a href="#和微服务框架如何结合" class="headerlink" title="和微服务框架如何结合"></a>和微服务框架如何结合</h3><p>微服务框架主要是对应用的复用和嵌套，模块联邦目前未能做到样式隔离等功能，只做到了加载器的功能。同时微服务对monorepo本地线上双模式支持也较弱。目前不考虑强行将微服务转换为模块联邦（一定不要）</p><h3 id="模块联邦如何动态设置publicPath"><a href="#模块联邦如何动态设置publicPath" class="headerlink" title="模块联邦如何动态设置publicPath"></a>模块联邦如何动态设置publicPath</h3><p>模块联邦中，如果子应用简单的设置了publicPath，不管是相对还是绝对路径都是对于主应用而言，这种情况下需要动态的配置publicPath使子应用正常。第一个方法是设置子应用的publicPath为auto。或者通过__webpack_public_path 动态设置，具体看webpack那篇博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;模块联邦提供了一种运行时的加载其他服务下模块的能力,通过下面几个问题来解决生产中模块联邦的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块联邦在项目源码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>all-in-boom</title>
    <link href="https://blog.xunserver.cn/archives/ff614c6c.html"/>
    <id>https://blog.xunserver.cn/archives/ff614c6c.html</id>
    <published>2022-10-22T01:49:50.000Z</published>
    <updated>2022-10-22T01:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近在折腾家里的网路设备，原因娃要出生了， 搞一个好点的存储设备来保存娃的照片视频等，顺便把屋里的设备升级一下。<br>先介绍下现在屋里的网络布局<br><img src="/post-images/all-in-boom/家庭网络拓扑.drawio.png" alt="家庭网络拓扑图"></p><h3 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h3><p>光猫买的是华为的B610-4E替换了运营商送的光猫，比较稳定而且可以自由改桥接。该光猫有4个千兆口，规划如下</p><ul><li>eth0: 网络桥接端口，桥接光猫和软路由(二层端口)</li><li>eth1: 光猫管理端口，192.168.2.4（三层端口）</li><li>eth2: 备用端口，如果路由器故障，通过光猫拨号</li><li>eth3: 电视桥接端口，同网络桥接端口</li></ul><p>需要注意的是，华为的三层lan不是桥接接口， 不能勾选多个三层lan。路由器配置页面的使能啥啥的，就是是否启用。<br>wan口配置三个接口</p><ol><li>桥接模式lan1，路由器拨号</li><li>桥接模式lan4，电视拨号</li><li>路由模式lan3，但是不启用</li></ol><h3 id="软路由"><a href="#软路由" class="headerlink" title="软路由"></a>软路由</h3><p>接下来是软路由的选购。i255 2.5G网口虽然更便宜，但是有断流问题，二来屋里交换机都是千兆，用不上。N5105发热过大，不适合放在弱电箱。单内存的机器在esxi下，装两个虚拟机内存就不够。没法all-in-boom。</p><p>选了倍控家的j4125 4*i211千兆 双内存的这款机器两个内存累计最多16G，j4125 4C4T 2.0Ghz。还支持一个2.5寸的硬盘，刚好能够满足路由器 + homeassistant + nas的需求。网口刚好做以下规划</p><ul><li>eth0: esxi 虚拟路由器的接口 （上面桥接了hass 和 esxi 的管理端口）</li><li>eth1: 连接光猫桥接的lan1，作为路由器的wan口</li><li>eth2: 路由器的lan口</li><li>eth3: 直通给nas</li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>弱电箱: 里面有7个通向客厅房间的网口，电视柜两个，客厅电话线（被我替换成了网线）1个，三个房间4个（主卧两个）。光猫3个（除了光猫的桥接口连接到软路由上）， nas和esxi加起来一个，电视桥接口一个。需要一个16口的交换机。把三个设备塞到一起还是需要费点时间。</p><p>书房: 有个双路的x99机器，一共6个网口。安转的esxi虚拟了三个虚拟机，作为平常生产工具用。直通了3个网口。由于书房只有一个网口，也需要一个交换机来扩展网口，其实可以用路由器的ap模式来扩展，但是我只有三个网口的小米路由器R3G。搞了一个8口千兆交换机</p><p>客厅中电视柜: 机顶盒 <em> 1、switch </em> 1、摄像头 <em> 2、小米AX 6000 </em> 1。之前电视柜还有个做nas的主机(升级后不需要)。 也是需要一个8口千兆交换机</p><h3 id="AP部分"><a href="#AP部分" class="headerlink" title="AP部分"></a>AP部分</h3><ul><li>客厅AX6000使用的小米默认固件开启AP模式，5G网络满足几个笔记本和手机打游戏需求。2.4G 网络用于物联网设备的接入、包括窗帘、客厅灯、电脑开机卡、万能红外遥控器、小米多模网关、小爱音响、斐讯音响、门锁、客厅空调、斐讯空气净化器、厨房的冰箱、电饭煲、洗衣机、加湿器还有各种涂鸦智能的开关（设备就是这么多）</li><li>卧室中关门信号就弱，两个卧室各安转了一个小米R3G（便宜而且体积不占地方），刷了breed安装了H大固件，开启AP模式，同时将发射功率调整到原来的20%。卧室中路由器通过交换机模式满足电视的上网，通过2.4G支持卧室中的物联网设备(遥控器、床头小爱音响、房间灯、空调等)，5G用于平常上网。</li></ul><p>全屋漫游问题，由于小米的固件是在太垃圾，而且试用过小米的漫游方案，确实效果一般，bug还多。采用了弱信号剔除和一致性SSID的方案，把全屋各个WIFI名字设置成一致。各个AP降低放射功率，开启弱信号替换。弱信号的方案成本较低。</p><h3 id="NAS-和-HomeAssistant"><a href="#NAS-和-HomeAssistant" class="headerlink" title="NAS 和 HomeAssistant"></a>NAS 和 HomeAssistant</h3><p>NAS采用的群晖方案，对于小白来说比较简单。j4125中直接虚拟一个，然后RDM直通硬盘<br>HomeAssistant使用官方提供的虚拟机镜像，直接安装。</p><h3 id="各种物联网设备"><a href="#各种物联网设备" class="headerlink" title="各种物联网设备"></a>各种物联网设备</h3><ul><li>小米系列<ul><li>小米触屏音响必须要买，家里的语音交互、TTS、主动问询等功能都依赖该设备。主卧放一个小个、客厅放一个打的当电子相框用。</li><li>小米多模网关、小米系的传感器依赖</li><li>小米传感器: 光照传感器（配合窗帘自动开关），人体传感器、米家蓝牙夜灯（带人体传感器和光照传感器）、门窗传感器，温湿度传感器</li><li>小米家电: 小米空调、小米电视、小米洗衣机、小米冰箱、小米扫地机器人、小米门锁。</li></ul></li><li>涂鸦系<ul><li>涂鸦系的红外万能遥控器，PDD 19块钱包邮，多买几个、控制老电视和其他牌子的空调必备。</li><li>涂鸦系的wifi开关 19包邮，多买几个</li><li>涂鸦系的射频遥控器  淘宝69一个</li></ul></li><li>HomeAssistant论坛<ul><li>窗帘电机 298，支持mqtt、html、tcp等多个协议、通过巴法云可以接入小爱。</li><li>各种开关，把墙上的开关内都置换上。也是支持ha接入。 </li></ul></li><li>其他<ul><li>斐讯N1，刷YYF看电视</li><li>斐讯R1，安转DLAN 放会儿歌</li><li>斐讯m1，空气质量检测，配置ha使用</li><li>各类摄像头，摄像头推荐雄迈（记得关闭外网访问），能够接入ha，小米系的没法接入。</li><li>开机卡，用于打开电脑和关闭电脑。</li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="j4125-安装esxi"><a href="#j4125-安装esxi" class="headerlink" title="j4125 安装esxi"></a>j4125 安装esxi</h3><p>倍控家j4125 + 4 * i211网卡+双内存版本准系统670R。如果对断流能够忍耐的也可选2.5G，准系统550R。准系统需要笔记本内存条DDR4L，最高2666MHZ，单个内存最多支持8G。闲鱼买大概120一根，建议买三星。还需要一个msata的硬盘，最小准备一个64G的盘。</p><p>需要直通的硬盘记得先在PE上面把分区表删除掉保存，修改分区表格式和msata盘一致。</p><p>硬件安装步骤如下</p><ol><li>拆开主机外壳，找到内存插槽，内存条上有个缺口，缺口左右一长一短。斜向上对准主板插口，擦入后，按一下，听见咔一声即可。拆内存时，先把两边的卡扣向外拉一下，内存就自动弹出来了。</li><li>主板上有两个接口和msata硬盘的接口长得一样，注意看有一个写了个WIFI，安装到没写wifi的接口上，先把接口上的固定硬盘的螺丝取下来。插入硬盘后安装螺丝固定。</li><li>安装机械硬盘，先使用送的sata转接线连接硬盘，这个比较简单，然后找主板上的sata接口和供电接口，供电接口是4针的，sata接口长的和硬盘的上接口一致。连接好后，把硬盘固定到主机的背板上。背板是要扣回主机的，硬盘要安装在背板里面，塞进主机。</li></ol><p>系统安装esxi比较稳定，我连续100天没关机。自行官网下载esxi镜像，或者在恩山论坛x86专区下载别人编译好的镜像。</p><ol><li>找一个U盘，最好16G，usb3.0。使用软碟通写入镜像到U盘，或者使用balenaEtcher软件写盘</li><li>U盘插入倍控，连接好键盘。插上电源线后狂按F11进入bios界面。先恢bios到默认设置，检查下VT-D是否开启。选择U盘启动</li><li>进入esxi加载页面后，会有5S等待时间，5S内按下shift + o 键编辑安转设置，输入空格autoPartitionOSDataSize=8192（这一步必要的，用于调整虚拟闪存大小，错过了关机重来）。然后回车进入安装界面，然后根据提示一路默认，系统记得安装到msata盘上。</li><li>系统安装好会需要在控制台调整管理端口，开机进入系统后，按F2进入网络配置，选择network adaptor，用一根网线连接电脑和主机的eth0口，观察哪个控制台哪个是connect的，选择这个网口作为管理端口。ESC退出后会重启网络端口，在进入ipv4配置页面，将管理端口的IP设置为192.168.2.16，网管设置为192.168.2.2 掩码 255.255.255.0，保存后退出。</li><li>电脑网线连接eth0的网口，电脑设置静态IP为192.168.2.21 掩码 255.255.255.0 网关192.168.2.2。</li><li>设置好电脑IP后，登录<a href="https://192.168.2.16进入esxi管理页。" target="_blank" rel="noopener">https://192.168.2.16进入esxi管理页。</a></li></ol><h3 id="esxi-直通切换"><a href="#esxi-直通切换" class="headerlink" title="esxi 直通切换"></a>esxi 直通切换</h3><p>安装好esxi系统后，首先规划好网口，按照先前介绍的来规划，将eth1 eth2 eth3 切换成直通。按照下图来切换</p><h3 id="安装openwrt"><a href="#安装openwrt" class="headerlink" title="安装openwrt"></a>安装openwrt</h3><ol><li>恩山下载任意的x86镜像。一般镜像都有EFI和不带EFI的进项，选择带有EFI字样镜像。下载后解压成.img格式为止</li><li>安装写盘工具写虚拟硬盘，百度<code>starwindconverter官网</code>, 随意填写些信息开始下载。根据提示开始转换，local file =&gt; localfile =&gt; vmdk =&gt; esxi server img =&gt; preallocat。一定要选择预分配，没必要选灵活增长。</li><li>esxi创建openwrt虚拟机，兼容性选择最新的那个(7.0 U2)，系统类型选择linux, linux5.x 64位 或则更高。</li><li>储存选择默认，在下一步都要删除的。</li><li>下一步硬件配置中把所有的设备删除干净，存储、usb和控制器都不要。删除后保存创建虚拟机，路由器CPU 2核心，单插槽两个2核心，内存选2G。不要开机</li><li>重新编辑刚才创建好的虚拟机添加硬盘，选择已有的硬盘，在弹出页中将刚才在用starwindconverter转换好的两个vmdk文件上传，并选择。</li><li>添加直通的两个网口，点击添加其他设备，添加PCI设备，选择需要直通的网卡。保存后退出，不要开机</li><li>开启esxi的ssh访问，然后电脑上ssh <a href="mailto:root@192.168.2.16ssh" target="_blank" rel="noopener">root@192.168.2.16ssh</a>连接上esxi宿主机。使用vmkfstools 对vmdk文件进行扩容 vmkdstools -X 2G /vmfs/volumns/datastore1/router/xxxx.vmdk，一般2G足够应付后面的需求了。</li><li>再到网页编辑虚拟机选择，引导默认取消安全引导，使用EFI引导。</li><li>开机，进入到正常的跑代码openwrt安装完成</li></ol><h3 id="x86路由器-系统配置"><a href="#x86路由器-系统配置" class="headerlink" title="x86路由器 系统配置"></a>x86路由器 系统配置</h3><ol><li>系统安装完成后，电脑网线在eth1、eth2刚才直通给openwrt网口上来回试，如果哪个网口能正常分配IP，表示这个网口是lan口（注意先把网口静态地址设置为DHCP）。</li><li>连接上lan口，根据网关地址找到openwrt的管理地址。根据自己的喜好调整lan配置，我一般习惯把lan口管理地址设置为192.168.2.2，同时设置DHCP 地址为192.168.2.100 ~ 192.168.2.240。192.168.2.100 之前作为屋里设备的静态地址，后面作为那些无关设备的动态地址。</li><li>配置wan口拨号，找运营商要个拨号账密，前提是光猫改了桥接才能使用。光猫改桥接找安装宽带的师傅要个超级密码，登录光猫后删除TR69端口，然后每个页面的都拍照备份一次就可以随意折腾了。</li><li>配置好wan口，lan口就可以替换原有的上网设备了。 光猫桥接口连接wan口，openwrtlan口连接原来的路由器的lan（使原有的路由变成一个AP交换机），先临时这么用</li></ol><p>安装x86路由器的原因是里面有很多固件，可以自由折腾，比如我的就是fast.com测试就有1.2GBPS，还安转了DDNSTO，在外面随时网页连接屋里的设备，还有NPS和zerotier。有了这个路由器，屋里的ATV随时随地可以看YouTube，检索内容也更快。</p><h3 id="安装DSM"><a href="#安装DSM" class="headerlink" title="安装DSM"></a>安装DSM</h3><p>DSM大致和上面的openwrt差不多，把网上下载的好的img镜像转换成vmdk，网上img镜像也只是一个引导镜像，不需要扩容，nas需要的大流量传输，配置好直通网卡。同样是删除所有其他的设备，只添加一个sata控制器。硬盘的话添加转换的镜像，然后需要到ssh中配置RDM直通，到设备管理器中查询需要直通的硬盘ID，vmkfstools -Z /vmfs/disks/xxxx /vmfs/volunms/datastore1/xxx.vmdk。再在虚拟配置中添加这个vmdk硬盘。<br>需要注意的是添加的vmdk文件都需要放在sata控制器上，同时添加引导文件在前，直通硬盘在后。同时也别忘了取消EFI安全引导。</p><p>正常开机后，注意选择sata引导，等1分钟后，到路由器的设备列表中查找是否存在dsm设备的获取到IP。浏览器输入http://获取到的IP:5000 进入dsm安装页面。按照提示上传pat文件，按照提示格式化第二个硬盘，等待10分钟后DSM安装完成。</p><h3 id="安装HomeAssistant"><a href="#安装HomeAssistant" class="headerlink" title="安装HomeAssistant"></a>安装HomeAssistant</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;最近在折腾家里的网路设备，原因娃要出生了， 搞一个好点的存储设备来保存娃的照片视频等，顺便把屋里的设备升级一下。&lt;br&gt;先介绍下现在屋里的网
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>chrome调试通关笔记</title>
    <link href="https://blog.xunserver.cn/archives/a6025488.html"/>
    <id>https://blog.xunserver.cn/archives/a6025488.html</id>
    <published>2022-10-09T01:21:41.000Z</published>
    <updated>2022-10-09T01:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>代码在平台运行时会通过backend对外通过调式协议暴露出运行时各种状态，各种调试工具通过解析调试协议实现UI界面（frontend）。chrome使用的是CDP(chrome devtools protocol)。</p><p>谷歌浏览器中有些devtool插件，比如vue devtools 和 react devtool。浏览器插件分为两个部分，一个是可以注入到当前页面的content script，一个是常驻的background部分。此外如果是扩展的devtool部分，还可以有一个devtool page部分。devtool插件通过content script向当前页面注入backend.js（负责收集运行时数据）,页面的backend.js 通过background通道暴露调试协议，devtool page解析调试协议形成页面。</p><p>vscode也可以调试chrome和nodejs中运行时代码，同理vscode也实现了一个frontend，只不过vscode在解析协议上还做了一层adapter，因为vscode不止可以调试js代码。</p><h3 id="chrome-devtool-protocol"><a href="#chrome-devtool-protocol" class="headerlink" title="chrome devtool protocol"></a>chrome devtool protocol</h3><p>chrome通过ws暴露协议，vscode中配置文件如下,主要有两种方式启动chrome调试，request: “launch” 表示启动一个新的chrome示例，默认配置好ws端口。 request: “attach”表示关联到现有的浏览器示例，这个需要在启动浏览器时指定参数（–remote-debugging-port=9222 –user-data-dir=你自己创建的某个目录）</p><p>需要注意的是如果我们手动启动浏览器需要指定–user-data-dir，这个目录保存了当前浏览器的所有配置缓存插件等,而且一个浏览器实例只能同时使用一个数据目录。所以我们在使用launch模式时需要注意，useDataDir的指定，false 表示使用默认（如果已经开了其他实例，启动会失败）,true使用临时目录(默认值)或者指定一个目录</p><p>通过下载金丝雀版本的chrome可以解决这个问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// .vscode/launch.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Launch Chrome"</span>,</span><br><span class="line">            "request": "launch",  // attach</span><br><span class="line">            "type": "chrome",</span><br><span class="line">            "url": "http://localhost:3000",</span><br><span class="line">            "webRoot": "$&#123;workspaceFolder&#125;",  // 相当于指定pathMapping: &#123;"/":"$&#123;workspaceFolder&#125;/"&#125;</span><br><span class="line">            "port": 9222, // 如果type: attach需要指定</span><br><span class="line">            "runtimeExecutable": "canary",  // type修改成 pwd-chrome</span><br><span class="line">            "useDatadir": false,  // 使用默认用户目录</span><br><span class="line">            // "type": "pwd-chrome" </span><br><span class="line">            "runtimeArgs": "--auto-open-devtools-for-tabs", // 额外的启动参数   --auto-open-devtools-for-tabs 自动打开控制台 --incognito 匿名启动</span><br><span class="line">            // 某些情况下sourcemap解析的文件地址和本地目录结构不一致，需要重新修正</span><br><span class="line">            "sourceMapPathOverrides": &#123;  // bunld.js =&gt; source  =&gt; localfile</span><br><span class="line">                "webpack://?:*/*": "$&#123;workspaceFolder&#125;/*" // ?:* 表示匹配不映射， * 表示匹配并映射。 该规则表示</span><br><span class="line">            &#125;,</span><br><span class="line">            // 针对静态文件重新调整</span><br><span class="line">            "pathMapping": &#123;</span><br><span class="line">                "static/js/": "src/js/"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><p>sourcemap是对源码的描述，大部分dev tool都实现了sourcemap的解析，格式如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    version : <span class="number">3</span>,  <span class="comment">// 版本</span></span><br><span class="line">    file: <span class="string">"out.js"</span>,</span><br><span class="line">    sourceRoot : <span class="string">""</span>,</span><br><span class="line">    sources: [<span class="string">"foo.js"</span>, <span class="string">"bar.js"</span>],  <span class="comment">// 多个源文件</span></span><br><span class="line">    names: [<span class="string">"a"</span>, <span class="string">"b"</span>],</span><br><span class="line">    mappings: <span class="string">"AAgBC,SAAQ,CAAEA;AAAEA"</span>, <span class="comment">// 最重要的描述文件</span></span><br><span class="line">    sourcesContent: [<span class="string">'const a = 1; console.log(a)'</span>, <span class="string">'const b = 2; console.log(b)'</span>] <span class="comment">// 原始代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存在一个问题，webpack中开发环境可能会使用eval函数模拟require，eval函数中无法针对字符串实现断点。如果在eval中添加sourceUrl=xxx，会直接添加eval函数的内容到根目录下的xxx，可以实现对eval执行断点。<br>同时，sourceMap可以递归，eval映射出的文件还可以再次指定sourceMapUrl映射到其他目录。</p><p>针对线上环境，打包时生成sourceMap文件，但是放在本地，在浏览器调试时使用filesystem将对线上的sourcemap映射到本地，实现本地调试线上环境(待实验),或者重定向到本地代码</p><p>sourceMap配置参考这个正则表达式<br>/^(eval-|inline-|hidden-)?(noresources-)?(cheap-(module-)?)?source-map?$/<br>eval：在eval函数中添加sourceUrl在调试环境中添加文件。<br>inline：在bundle.js 中sourceMapUrl直接跟sourceMap内容。<br>hidden: 表示不在bundle在关联sourceMap，但是要生成。<br>noresource: 不在sourcemap中包含原始代码<br>cheap: sourcemap只定位到行错误，不到列错误<br>module: sourcemap生成时会包含每个loader处理的sourceMap（关键配置）</p><h3 id="vue中sourceMap存在hash问题"><a href="#vue中sourceMap存在hash问题" class="headerlink" title="vue中sourceMap存在hash问题"></a>vue中sourceMap存在hash问题</h3><p>使用eval会使映射添加hash后缀，最好的办法是不使用hash, 修改devtool: ‘source-map’，或者使用sourceMapPathOverrides重新映射（未成功实现）</p><h3 id="线上问题如何调试"><a href="#线上问题如何调试" class="headerlink" title="线上问题如何调试"></a>线上问题如何调试</h3><p>目前有几种方案解决</p><ol><li><p>线上环境使用noresources构建sourcemap，通过vscode的detools连接到浏览器实现调试</p></li><li><p>把本地的sourcemap文件添加到filesystem，然后对出错的代码文件右键添加sourcemap，选择filesystem中对应sourcemap文件。这种方式不要设置hidden-source-map</p></li><li><p>打包后服务器手动删除所有sourcemap文件，本地保留一份。这样请求map时总是会404， 然后把本地的sourcemap文件添加到filesystem</p></li><li><p>生产环境正常打包sourcemap，但是在请求.map文件时无权限人员加载404，有权限人员能请求，这样既可以在vscode调试，也能在浏览器调试。不过也有问题，每个bundle中会存在sourceUrl，会增大一点包的体积</p></li><li><p>在打包时对每个chunk和map生成一个映射表（hidden方案），在请求chunk时，通过代理对每个chunk后面添加sourcemap语句，sourcemap指向对应的服务（本地或者远端，或者filesystem），这种方式可以在vscode和浏览器。</p></li><li><p>每次打包时总是生成两份dist,一份配置（hidden方案）,另一份正常配置sourcemap(输出目录配置成线上域地址)，通过overrides将线上的请求代理到本地，这样请求的bundle文件就是本地的带有sourcemap的文件，filesystem添加带有sourcemap的文件夹到调试环境中。这种方式不能在vscode中实现调试</p></li><li><p>针对客户浏览器出现的问题，搜集客户代码报错的行和列，通过sourcemap文件反向查找出错误地址，如果sourcemap配置了sourceContent，还可以直接定位具体的文件。</p></li></ol><p>目前最优的方案还是针对不同的用户，展示不同bundle文件。</p><h3 id="pathMapping-和-sourceMapPathOverrides的区别"><a href="#pathMapping-和-sourceMapPathOverrides的区别" class="headerlink" title="pathMapping 和 sourceMapPathOverrides的区别"></a>pathMapping 和 sourceMapPathOverrides的区别</h3><p>前者是对network中是在的请求资源的映射（会自动忽略查询参数），后者是对sourcemap生成的源文件的映射(sourcemap生成文件在请求中是不存在的)。</p><h3 id="filesystem-和-overrides区别"><a href="#filesystem-和-overrides区别" class="headerlink" title="filesystem 和 overrides区别"></a>filesystem 和 overrides区别</h3><p>浏览器请求时总是先对overrides进行查找，然后是服务端，再对filesystem查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;代码在平台运行时会通过backend对外通过调式协议暴露出运行时各种状态，各种调试工具通过解析调试协议实现UI界面（frontend）。ch
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sass-less</title>
    <link href="https://blog.xunserver.cn/archives/a8f35e34.html"/>
    <id>https://blog.xunserver.cn/archives/a8f35e34.html</id>
    <published>2022-08-02T00:58:37.000Z</published>
    <updated>2022-08-02T00:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h2><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>支持webpack导入，如果导入的文件是_开头，则导入内容不会编译，只会引用变量</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>约定$name: value 形式的为变量。支持字符串（带有空格需要引号包裹），数字，数组（逗号或者空格分隔），对象（(key: value, key2: value2)），boolean。</p><p>变量区分为代码块内变量和代码块外变量。默认情况下，后申明的变量会覆盖前置变量（同作用域），通过$var: xxx !default 这种方式可以前置变量覆盖后置。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: green;</span><br><span class="line"><span class="variable">$color</span>: red !default;  <span class="comment">// 不添加!default red 会覆盖前面，添加!default 后面声明的不会覆盖green</span></span><br></pre></td></tr></table></figure></p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>在嵌套中选择父元素，使用后会忽略当前嵌套</p><h3 id="mixin和-include"><a href="#mixin和-include" class="headerlink" title="@mixin和@include"></a>@mixin和@include</h3><p>通过@mixin 定义代码片段，通过@include引入片段实现复用。@mixin相当于代码片段的生成器，支持参数和默认参数。</p><h3 id="extend"><a href="#extend" class="headerlink" title="@extend"></a>@extend</h3><p>如果需要对某个类实现继承，使用@extend .classname 实现，会继承该类所有实现。该功能唯一用处是在该类实现比较多的场景。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.c .a &#123;</span><br><span class="line">    color: xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">    @<span class="keyword">extend</span> .a;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red; </span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.c</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="xxx-插值表达式"><a href="#xxx-插值表达式" class="headerlink" title="#{xxx}插值表达式"></a>#{xxx}插值表达式</h3><p>前面变量都是用在属性值上，#{}可以用在选择器或者属性名上面，实现动态生成类或者属性。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less解析时区大概两个步骤</p><ol><li>按照层级确定变量</li><li>根据变量赋值<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3>@name: value 形式声明变量，变量用在css属性值、属性、类定义包括动态变量中<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@error:</span> red;</span><br><span class="line"><span class="variable">@color:</span> color;</span><br><span class="line"><span class="variable">@red:</span> blue;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@error</span>;  <span class="comment">// 属性值</span></span><br><span class="line">    <span class="selector-tag">background-</span><span class="variable">@&#123;color&#125;</span>: @<span class="variable">@&#123;error&#125;</span>; <span class="comment">// 作为属性时需要@&#123;&#125;包裹，作为动态变量需要@@</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>less支持在块中将属性作为变量名，规则同变量。总是先变量整个快作用域确定变量，然后再赋值。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.success</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">        background-color: $color </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>less 支持lazy load，先使用变量再声明变量，这种特性总是后声明的覆盖前面。</p><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>less编译时会将所有的类视为可混合，mixin特性如下</p><ol><li><p>支持函数、函数重写和具名参数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span>(<span class="variable">@color</span>) &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span>(<span class="variable">@color</span>, <span class="variable">@padding</span>: <span class="number">2px</span>;) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="variable">@padding</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.someError</span> &#123;</span><br><span class="line">    <span class="selector-class">.error</span>(green)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.otherError</span> &#123;</span><br><span class="line">    <span class="selector-class">.error</span>(<span class="variable">@color</span>: yellow); <span class="comment">// 具名参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成以下，会执行所有满足条件的函数</span></span><br><span class="line"><span class="selector-class">.someError</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持嵌套和部分mixin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: green;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-class">.text</span>(),  &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.someError</span> &#123;</span><br><span class="line">    <span class="selector-class">.error</span><span class="selector-class">.text</span>()  <span class="comment">// 不管是.text 前面添加哪种选择器，不考虑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>混合不考虑选择符, 同一个作用域下存在多个相同引用的时不会重复渲染。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> + <span class="selector-class">.b</span> , <span class="selector-class">.a</span> ~ <span class="selector-class">.b</span> ,<span class="selector-class">.a</span><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面3个变量视为一个引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.c</span> &#123;</span><br><span class="line">    <span class="selector-class">.a</span><span class="selector-class">.b</span>()</span><br><span class="line">    <span class="selector-class">.a</span> <span class="selector-class">.b</span> ()</span><br><span class="line">    <span class="selector-class">.a</span> &gt; <span class="selector-class">.b</span> ()</span><br><span class="line">    <span class="comment">// 上面3种方式都会被下面3种方式匹配，因为引用相同的原因只会渲染一次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持变量直接绑定片段或者另一个mixin结果。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@test:</span> .error();</span><br><span class="line"><span class="variable">@test2:</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br><span class="line"></span><br><span class="line">.info &#123;</span><br><span class="line">    <span class="variable">@test</span>();</span><br><span class="line">    <span class="variable">@test1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="amp-父选择器"><a href="#amp-父选择器" class="headerlink" title="&amp;父选择器"></a>&amp;父选择器</h3><p>使用父选择器后会忽略当前默认的嵌套关系。less的父选择器是一个简单替换，比sass功能多。</p><ol><li>反向选择器 .a &amp;。同sass相同</li><li>贴贴选择器 &amp;b =&gt; .ab &amp;&amp; =&gt; .a.a(sass不支持)  .b&amp; =&gt; .b.a(sass不支持这种方式)</li></ol><h3 id="extend继承"><a href="#extend继承" class="headerlink" title=":extend继承"></a>:extend继承</h3><p>.a:extend(.b) 会继承.b less查找器查询到的内容(按照mixin的规则查询)。通过.a:extend(.b all)表现和sass相同</p><ol><li>extend过程在一次编译，所以不能匹配动态变量。<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@variable:</span> .bucket;</span><br><span class="line"><span class="variable">@&#123;variable&#125;</span> &#123; <span class="comment">// interpolated selector</span></span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.some-class</span><span class="selector-pseudo">:extend(.bucket)</span> &#123;&#125; <span class="comment">// does nothing, no match is found</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="函数和编程能力"><a href="#函数和编程能力" class="headerlink" title="函数和编程能力"></a>函数和编程能力</h3><ol><li>if((@text or @test2), trueReturn, falseReturn) </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scss&quot;&gt;&lt;a href=&quot;#scss&quot; class=&quot;headerlink&quot; title=&quot;scss&quot;&gt;&lt;/a&gt;scss&lt;/h2&gt;&lt;h3 id=&quot;import&quot;&gt;&lt;a href=&quot;#import&quot; class=&quot;headerlink&quot; title=&quot;@impo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端大文件上传</title>
    <link href="https://blog.xunserver.cn/archives/cbd08800.html"/>
    <id>https://blog.xunserver.cn/archives/cbd08800.html</id>
    <published>2022-07-29T07:52:50.000Z</published>
    <updated>2022-07-29T07:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近弄公司的大文件上传，实现了分片、暂停、继续、断点续传和秒传，记录一些过程中的细节。</p><h3 id="buffer、blob和arrayBuffer"><a href="#buffer、blob和arrayBuffer" class="headerlink" title="buffer、blob和arrayBuffer"></a>buffer、blob和arrayBuffer</h3><p>所有文件都可以按照二进制解析，js宿主环境提供了对二进制的处理。</p><ul><li>buffer  nodejs提供的二进制缓冲区</li><li>blob和file   浏览器提供的二进制对象，通过操作对象来操作二进制</li><li>arrayBuffer  浏览器提供的一个具有窗口的二进制对象。</li></ul><p>file完全继承了blob所有的特性并添加了部分特性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob()</span><br></pre></td></tr></table></figure></p><p>TODO:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近弄公司的大文件上传，实现了分片、暂停、继续、断点续传和秒传，记录一些过程中的细节。&lt;/p&gt;
&lt;h3 id=&quot;buffer、blob和ar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统样式设计</title>
    <link href="https://blog.xunserver.cn/archives/60273c5f.html"/>
    <id>https://blog.xunserver.cn/archives/60273c5f.html</id>
    <published>2022-07-28T01:15:24.000Z</published>
    <updated>2022-07-28T01:15:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>规范团队项目</title>
    <link href="https://blog.xunserver.cn/archives/95508531.html"/>
    <id>https://blog.xunserver.cn/archives/95508531.html</id>
    <published>2022-07-22T06:48:30.000Z</published>
    <updated>2022-07-22T06:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="几个角度规范项目开发"><a href="#几个角度规范项目开发" class="headerlink" title="几个角度规范项目开发"></a>几个角度规范项目开发</h2><ol><li>eslint 对js、ts以及在vue项目中的js代码进行质量和风格的检查。</li><li>stylelint 对css代码，包括sass，less等代码的风格和质量进行检查。</li><li>prettier 专注于对代码风格的修复，可以结果上面两个插件对代码进行自动修复。</li><li>editorconfig用于编辑器的默认行为，比如新建一个文件、新起一行、一个tab键的默认格式等。</li><li>.gitconfig 用于配置当前项目git的默认行为，比如下载的代码是lf还是crlf（mac和windows同学最对碰到的问题）,如果使用个人电脑，需要不同的项目对应不同user.name 等需要配置。.git/config文件。</li><li>cz工具能够对commit信息进行编辑。</li><li>husky通过对git add、commit和publish过程的介入，对项目本地化规范。</li></ol><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>eslint通过在项目根目录配置eslintrc.*文件。通过parse选项对文件进行分析。eslint 会从当前文件依次向上检查配置文件，直到文件系统根目录或则碰到一个root: true 的配置文件，利用这个可以给mono配置不同的配置检查，配置文件主要包含一下内容</p><ul><li>env 和 globals 针对全局变量中的检查，比如window变量，document变量等，nodejs的__dirname等等。env 相当于globals的合集。</li><li>parse 和 parseOptions 解析器和解析器选项。 默认是esprima,可以配置成@babel/eslint-parser的 ，支持ts @typescript-eslint/parser 和 支持vue的eslint-plugin-vue。</li><li>rule 配置不同归的规则，key、value形式的对象。value 0 1 2 表示禁用，警告和错误。支持数组的形式调用。数组第二项是rule的参数。</li><li>extends，返回一个有config属性的对象。config属性对应的是配置文件，见后文如何提供一个eslint-plugin。extends都是由插件导入。</li><li>plugins 提供rules的解析，和extends的区别是plugin 提供的是rule规则，但是还未配置。所以一般使用plugin后需要配置相应的extend。plugin 还提供了processor 能力。</li><li>processor 是由plugin 提供，能对非js文件中的js片段提取进行eslint检查。一般都是对应Plugin的extend配置提供。</li><li>overrides 可以覆盖默认的配置，会和全局的定义的配置进行合并</li></ul><p>eslint-plugin-vue <a href="https://eslint.vuejs.org/rules/" target="_blank" rel="noopener">https://eslint.vuejs.org/rules/</a></p><p>下面配置vue3 eslint为例</p><blockquote><p>npm i -D eslint-plugin-vue<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">        node: <span class="literal">true</span>,</span><br><span class="line">        browser: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    globals: [</span><br><span class="line">        <span class="string">'__webpack_public__path__'</span>, <span class="comment">// 忽略代码中webpack相关变量</span></span><br><span class="line">    ]</span><br><span class="line">    parse: <span class="string">'vue-eslint-parse'</span>,  <span class="comment">// 解析vue中template</span></span><br><span class="line">    parseOptions: &#123;</span><br><span class="line">        parse: <span class="string">'@typescript-eslint/parse'</span>,</span><br><span class="line">        sourceType: <span class="string">'module'</span></span><br><span class="line">        <span class="comment">// ... 其余@typescript-eslint/parse parseOptions</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="string">'vue'</span>  <span class="comment">// eslint会默认添加eslint-plugin-vue</span></span><br><span class="line">        <span class="string">'@juqery/test'</span>,  <span class="comment">// @juqery/eslint-plugin-test</span></span><br><span class="line">        <span class="string">'@test'</span>  <span class="comment">// @test/eslint-plugin  @开头总是会处理成组织名</span></span><br><span class="line">    ],</span><br><span class="line">    extends: [</span><br><span class="line">        <span class="string">'plugin:vue'</span>  <span class="comment">// 去eslint-plugin-vue 包中导入config对象</span></span><br><span class="line">        <span class="string">'test'</span>,  <span class="comment">// eslint-config-test包中导入   // 默认前缀是eslint-config</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="plugin浅解析"><a href="#plugin浅解析" class="headerlink" title="plugin浅解析"></a>plugin浅解析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包 eslint-plugin-xunserver</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">'xxxx'</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// rule 定义</span></span><br><span class="line">            create() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            meta() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    config: &#123;</span><br><span class="line">        vue3: &#123; <span class="comment">// 使用时先在plugin中添加rule定义  plugins: ['xunserver'], 然后extends: ['eslint-plugin-xunserver/vue3 或者eslint-plugin-xunserver/vue2']</span></span><br><span class="line">            env: &#123;</span><br><span class="line">                node: <span class="literal">true</span>,</span><br><span class="line">                browser: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            extends: [</span><br><span class="line">                <span class="string">'other config'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        vue2: &#123;</span><br><span class="line">            <span class="comment">// 大致同上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    processor: &#123;</span><br><span class="line">        <span class="comment">// processor 对象</span></span><br><span class="line">        <span class="string">'xxx'</span>: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h3><p>stylelint 配置上同eslint类似。从当前文件开始依次向上寻找.stylelintrc.js配置文件，直到找到为止。同eslint区别是默认都是root配置。大致配置如下</p><ul><li>customSynax，定义解析器，比如在vue和html中使用就需要配置，一般和override搭配使用</li><li>extends, 继承其他配置，可以实现插件和customSynax的引入，和eslint有区别，extends大部分时候还用来配置插件。配置在后面的覆盖前面的，extends引入的会被覆盖。</li><li>plugins，通过插件提供新的规则，一般插件只提供了规则，但是未配置，需要extends配置或者自行配置。</li><li>overrides 能针对不能的文件类型使用不同的配置规则。比如stylelint-config-html/vue 实现了vue的特殊处理。</li><li>rules 对不同的规则配置，null表示规则不生效，其余需要参考rule的实现，数组形式如果第二项是对象，则认为是第二参数。通用的参数有disableFix，message两个关注的。一个可以不处理fix，一个可以自定义报错信息。</li><li>ignoreFiles 忽略文件。第三库不使用stylelint</li></ul><h4 id="recss"><a href="#recss" class="headerlink" title="recss"></a>recss</h4><p>Reasonable System css， 通过style-config-recss 实现规范</p><h4 id="less-sass-和-stylus-的解析"><a href="#less-sass-和-stylus-的解析" class="headerlink" title="less sass 和 stylus 的解析"></a>less sass 和 stylus 的解析</h4><p>使用别人配置好的stylelint-config-standard、stylelint-config-standard-xx 实现，其中stylelint-config-standard是在 stylelint-config-recommend 基础上实现。</p><p>如果是自行配置需要，overrides 对应的less、scss和stylus文件，解析器是postcss-less postcss-scss 和 postcss-styl</p><p>vue需要安装postcss-html 和对应的postcss-less postcss-scss 等</p><h4 id="解决prettier冲突"><a href="#解决prettier冲突" class="headerlink" title="解决prettier冲突"></a>解决prettier冲突</h4><p>同理stylelint不解决格式上的问题，需要关闭和prettier冲突的rules。</p><h4 id="实现一个extend"><a href="#实现一个extend" class="headerlink" title="实现一个extend"></a>实现一个extend</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">    extends: [<span class="string">'others extends'</span>],</span><br><span class="line">    overrides: [</span><br><span class="line">        &#123;</span><br><span class="line">            file: [<span class="string">'*.vue'</span>, <span class="string">'**/*.vue'</span>],</span><br><span class="line">            customSynax: <span class="string">'postcss-html'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h3><p>prettier 是一个format工具，eslint和stylelint同时具有lint和format功能，执行顺序是eslint =&gt; prettier 或者stylelint =&gt; prettier。<br>prettier 的配置文件比较简单，一共就10多个选项，使用时指定需要使用的文件即可，prettier在项目中使用意义不大，主要是不能在codeActionSave中使用。目前prettier对css 和 js的格式化都交给对应的格式化工具，不够prettier 对其他语法的格式化还是比较好用，还是建议在编辑保留。<br>prettier还会使用editorconfig中的配置来初始化配置，如果新建文件总是报错飘红，建议检查editorconfig 和 prettier中冲突的部分。</p><h3 id="vscode中引入格式化工具"><a href="#vscode中引入格式化工具" class="headerlink" title="vscode中引入格式化工具"></a>vscode中引入格式化工具</h3><p>vscode 区分为工作区和用户区配置（本地和全局），vscode提供了两种format方式，一种是codeActionOnSave，表示保存时调用格式化工具。另一个是defaultEditor: ‘xxx’, 表示使用快捷键格式化时调用的工具。</p><ul><li>codeActionOnSave和formatOnSave， formateOnSave是defaultEditor在保存时调用的方式，现在基本启用。codeActionOnSave支持多个格式化程序依次调用。vscode插件在初始化时会向vscode注册format功能</li></ul><p>vscode针对不同类型的文件能够采用不同的配置，”[html]”为html类型的文件采用特定的配置。</p><h3 id="vue中template如何格式化"><a href="#vue中template如何格式化" class="headerlink" title="vue中template如何格式化"></a>vue中template如何格式化</h3><p>vue中template中规范prop能够保证良好的编码思路。建议加上vue/attributes-order。</p><h3 id="husky、lint-stage、commitizen和cz-customizable"><a href="#husky、lint-stage、commitizen和cz-customizable" class="headerlink" title="husky、lint-stage、commitizen和cz-customizable"></a>husky、lint-stage、commitizen和cz-customizable</h3><ul><li>husky 用于在git的各种阶段执行脚本，如果脚本返回错误，停止流程。</li><li>list-stage 用于只校验暂存区文件，提高lint速度，在校验文件时，会从文件的当前的目录开始查找最近的配置，在根目录配置baseconfig，子目录继承。</li><li>commitizen是一个检查commit message的工具。支持各种adapter。cz-customizable 是对应的adapter。安装好后使用git-cz代替git commit。该方案不能很好的和vscode结合，不采用。</li><li>commitlint 检查commit msg是否合规，结合husky实现commit信息的校验。</li></ul><h4 id="husky安装配置"><a href="#husky安装配置" class="headerlink" title="husky安装配置"></a>husky安装配置</h4><blockquote><p>pnpm add husky -Dw  // 项目安装在根目录<br>pnpm set-script prepare “husky install”  配置package.json script.prepare 脚本<br>pnpm husky install   // 初始化husky<br>pnpm add ‘./husky/pre-commit’ ‘lint-stage’  // 不同包调用自身的lint-stage 方法<br>pnpm add ‘./husky/pre-push’ ‘pnpm -F “./packages/**” run lint’  // 全局校验</p></blockquote><h4 id="list-stage"><a href="#list-stage" class="headerlink" title="list-stage"></a>list-stage</h4><p>在子项目中单独配置.lintstagedrc.js文件,文件内容如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .lintstagedrc.js</span></span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'../../.lintstagedrc.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...baseConfig,</span><br><span class="line">    <span class="string">'*.&#123;js,jsx,ts,tsx.vue,html&#125;'</span>: [<span class="string">'eslint --config .eslintrc.js'</span>],</span><br><span class="line">    <span class="string">'*.&#123;css,scss,sass,less,styl,vue,html&#125;'</span>: [<span class="string">'stylelint --config .stylelintrc.js'</span>]</span><br><span class="line">    <span class="string">'*.&#123;ts,tsx,js,jsx,json,html,yml,css,less,scss,md,sass&#125;'</span>: [<span class="string">'prettier --write'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h4><blockquote><p>pnpm add commitlint  -Dw<br>pnpm husky add ‘./hasky/commit-msg’ ‘pnpm commitlint –config .commitlintrc.js –edit $1’<br>添加.commitlintrc.js文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * build : 改变了build工具 如 webpack</span></span><br><span class="line"><span class="comment"> * ci : 持续集成新增</span></span><br><span class="line"><span class="comment"> * chore : 构建过程或辅助工具的变动</span></span><br><span class="line"><span class="comment"> * feat : 新功能</span></span><br><span class="line"><span class="comment"> * docs : 文档改变</span></span><br><span class="line"><span class="comment"> * fix : 修复bug</span></span><br><span class="line"><span class="comment"> * perf : 性能优化</span></span><br><span class="line"><span class="comment"> * refactor : 某个已有功能重构</span></span><br><span class="line"><span class="comment"> * revert : 撤销上一次的 commit</span></span><br><span class="line"><span class="comment"> * style : 代码格式改变</span></span><br><span class="line"><span class="comment"> * test : 增加测试</span></span><br><span class="line"><span class="comment"> * anno: 增加注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">'always'</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'build'</span>,</span><br><span class="line">        <span class="string">'ci'</span>,</span><br><span class="line">        <span class="string">'chore'</span>,</span><br><span class="line">        <span class="string">'docs'</span>,</span><br><span class="line">        <span class="string">'feat'</span>,</span><br><span class="line">        <span class="string">'fix'</span>,</span><br><span class="line">        <span class="string">'perf'</span>,</span><br><span class="line">        <span class="string">'refactor'</span>,</span><br><span class="line">        <span class="string">'revert'</span>,</span><br><span class="line">        <span class="string">'style'</span>,</span><br><span class="line">        <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'anno'</span>,</span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="eslintrc-js和eslintignore-文件"><a href="#eslintrc-js和eslintignore-文件" class="headerlink" title="eslintrc.js和eslintignore 文件"></a>eslintrc.js和eslintignore 文件</h3><p>eslint（stylelint）在执行时，按照如下执行。</p><ol><li>确定当前使用的eslint文件位置，确定执行的上下文。</li><li>确定需要处理的全部文件</li><li>根据上下文中中的.eslitingnore、命令中的–no-ignore、–ext 确定需要处理的最终文件合集</li><li>一个一个文件的查找eslintrc配置，找到配置后执行eslint。配置的查找规则从当前需要检查的配置往上级目录查找，知道文件系统的根目录或者碰到一个root:true的配置文件，这种方式相当于变相实现了继承（stylelint在查找到第一个配置文件后停止，意味着需要自行实现继承）。</li></ol><h3 id="vscode中eslint和stylelint"><a href="#vscode中eslint和stylelint" class="headerlink" title="vscode中eslint和stylelint"></a>vscode中eslint和stylelint</h3><p>vscode执行逻辑大致同上，只是确定文件的方式有所不同。</p><ol><li>vscode打开时加载项目根目录下的ignore文件</li><li>根据vscode中的no-ignore 和插件配置的生效文件确定最终文件。</li></ol><h3 id="lint-staged-如何实现只检查部分文件"><a href="#lint-staged-如何实现只检查部分文件" class="headerlink" title="lint-staged 如何实现只检查部分文件"></a>lint-staged 如何实现只检查部分文件</h3><p>eslint，styllint和prettier均支持stdin方式确定输入文件。lint-staged把需要检查的文件和配置一一对比，确定出需要执行命令的文件，添加在命令后。<br>lintstagedrc的查找方式从被检查的文件开始向上查找，lintstagedrc中指令执行的上下和本身相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lintstagedrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"*.(vue,ts,tsx,js,jsx)"</span>: <span class="string">"eslint"</span>   <span class="comment">// 相当于执行在.lintstagedrc.js所在目录下执行eslint xx.js命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="monorepo格式化解决方案"><a href="#monorepo格式化解决方案" class="headerlink" title="monorepo格式化解决方案"></a>monorepo格式化解决方案</h3><p>monorepo仓库有如下难点需要解决。</p><ol><li>不同项目使用不同技术栈，采用的规范不一致。</li><li>CI和lint-staged中的校验是全局的。</li><li>vscode编辑器总是从项目根目录读取工具并加载ignore文件。<br>针对以上问题，解决方案如下</li><li>不同的子项目在编码时，建议到对应的子目录下编写，目的是为了匹配vscode的格式化功能。</li><li>不同子项目在配置时，通通引用公共的配置</li><li>ci和git 校验时采用调用各子项目中的lint工具。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;几个角度规范项目开发&quot;&gt;&lt;a href=&quot;#几个角度规范项目开发&quot; class=&quot;headerlink&quot; title=&quot;几个角度规范项目开发&quot;&gt;&lt;/a&gt;几个角度规范项目开发&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;eslint 对js、ts以及在vue项目中的js代码进行质量和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>browlist</title>
    <link href="https://blog.xunserver.cn/archives/5bc71ff9.html"/>
    <id>https://blog.xunserver.cn/archives/5bc71ff9.html</id>
    <published>2022-07-21T01:39:49.000Z</published>
    <updated>2022-07-21T01:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>配置当前项目面向的平台，可以帮助babel、postcss识别出当前内容中哪些是需要转换</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>支持字符串和对象的配置防范，对于字符串的配置可以使用npx browserlist string 检查字符串配置是否有效。<br>“,” 表示并集 and表示交集</p><h3 id="browserslist-webpack插件"><a href="#browserslist-webpack插件" class="headerlink" title="browserslist webpack插件"></a>browserslist webpack插件</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol><li>页面加载时判断当前浏览器是否在兼容列表中，如果不存在，提示浏览器版本过低</li><li>离线判断，判断编译到代码中</li><li>打包时如果使用的浏览器是低版本，用户的浏览器高于高于这个版本处理。</li><li>如果webpack打包的环境不具备联网功能，需要支持手动上传查询文件功能</li></ol><h4 id="技术预研"><a href="#技术预研" class="headerlink" title="技术预研"></a>技术预研</h4><ol><li>离线判断需要编写webpack 插件，在生产打包时动态的查询然后将结果编译成chunk吗，并在入口文件中引用并提示。</li><li>不能在每个页面都做判断逻辑，能不能只判断依次，然后将结果缓存起来。</li></ol><p>基于上面的逻辑找到了一个好东西 <a href="https://github.com/browserslist/browserslist-useragent-regexp，这个库可以根据配置生成" target="_blank" rel="noopener">https://github.com/browserslist/browserslist-useragent-regexp，这个库可以根据配置生成</a> js 正则表达式，不过这个库的查询逻辑是自行实现的，不支持用户实现查询好浏览器后手动添加。</p><h4 id="解决-browserslist-useragent-regexp-缺少的离线查询功能"><a href="#解决-browserslist-useragent-regexp-缺少的离线查询功能" class="headerlink" title="解决 browserslist-useragent-regexp 缺少的离线查询功能"></a>解决 browserslist-useragent-regexp 缺少的离线查询功能</h4><p>原作者一直的更新，我们需要改动的只是 /src/browsers/browserslist.ts 中的getBrowsersList代码，新增从本地获取的逻辑。使用git action 每天定期的从原仓库拉取代码，如果有新的tag，将原始代码和本地代码混合， 重新打包发布新的。</p><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;p&gt;配置当前项目面向的平台，可以帮助babel、postcss识别出当前内容中哪些是需要转换&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>babel</title>
    <link href="https://blog.xunserver.cn/archives/b197ee89.html"/>
    <id>https://blog.xunserver.cn/archives/b197ee89.html</id>
    <published>2022-07-21T00:32:32.000Z</published>
    <updated>2022-07-21T00:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>babel能把es6+转换成es5代码，有两方面转换，一是对语法的转换，比如箭头函数class语法、async语法等。二是对新的api比如数组和字符串上新添加的方法。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>babel是由@babel/core 为主，通过一系列plugin来完成转换。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>babel通过项目根目录下的配置文件处理一般都用babel.config.js 或 .bebelrc，两个区别是js需要按照js文件格式导出，rc文件只用写一个对象即可。</p><h3 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h3><p>一系列已经配置好的插件合集，通过对外暴露options来对内部plugin进行配置。presets的是由后往前解析的，意味申明在后面的preset会先执行，每一个preset其实就是一个返回bable配置对象的函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.myCustomPreset = <span class="function">(<span class="params">presetOptions</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        presets: [<span class="string">"@babel/preset-xxx"</span>],</span><br><span class="line">        plugins: [<span class="string">"@babel/plugin-xx"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>对于同一段代码的解析，由前往后。配置方式和presets一样，plugin总优先于presets中的插件先执行。</p><p>###<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        [<span class="string">'@babel/plugin-runtime-transform'</span>, &#123;</span><br><span class="line">            xx: xx</span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h3><ul><li>targets 直接配置target属性，默认使用项目下browserlist文件（建议使用）</li><li>useBuiltIns: ‘entry’,引入浏览器不支持的全部polyfill，即使未在代码中使用。 ‘usage’，在各个使用的地方应用，可能会存在重复的情况</li><li>corejs: 3</li></ul><h3 id="bebel-preset-env-和-bebel-plugin-transform-runtime"><a href="#bebel-preset-env-和-bebel-plugin-transform-runtime" class="headerlink" title="bebel/preset-env 和 @bebel/plugin-transform-runtime"></a>bebel/preset-env 和 @bebel/plugin-transform-runtime</h3><p>配置targets后，preset-env查询targets所支持的特性，过滤出生效的插件，每个插件在声明时需要指定能够生效的浏览器</p><p>polyfil主要包含3个方面的内容</p><ul><li>corejs，对高级api的支持，比如Object.defineProperty 这一类的api。或者在原型添加某些方法，比如数组新增的那些方法</li><li>各种helper函数，比如箭头函数和class语法，生成各种helper函数。</li><li>regenerator，对async语法糖进行转换</li></ul><p>preset-env对polyfill的处理是，corejs和regenerator全局注入，helper在模块注入（在模块现场申明一个helper，和transform-runtime区别在transform-runtime的helper是由corejs导出的，每个地方都可以复用），这样会污染全局环境。</p><p>@bebel/plugin-transform-runtime 将全局的注入全部改成模块的注入。缺点是不支持target，总是会做polyfill操作。</p><p>得到一个最终的版本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        [<span class="string">'transform-runtime'</span>, &#123;</span><br><span class="line">            corejs: <span class="number">3</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    presets: [</span><br><span class="line">        [<span class="string">'env'</span>, &#123;</span><br><span class="line">            corejs: <span class="number">3</span>,</span><br><span class="line">            useBuiltIns: <span class="string">'usage'</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="执行实现配置文件"><a href="#执行实现配置文件" class="headerlink" title="执行实现配置文件"></a>执行实现配置文件</h3><p>导出配置文件即可，在需要引用的地方extends合并。需要注意的时，preset文件中不能包含extends</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;babel能把es6+转换成es5代码，有两方面转换，一是对语法的转换，比如箭头函数class语法、async语法等。二是对新的api比如数
      
    
    </summary>
    
    
  </entry>
  
</feed>
