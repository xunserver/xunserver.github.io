<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bang</title>
  
  <subtitle>生活总会有惊喜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xunserver.cn/"/>
  <updated>2022-12-06T08:18:35.000Z</updated>
  <id>https://blog.xunserver.cn/</id>
  
  <author>
    <name>yangmanman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通配符</title>
    <link href="https://blog.xunserver.cn/archives/aecba7e5.html"/>
    <id>https://blog.xunserver.cn/archives/aecba7e5.html</id>
    <published>2022-12-06T08:18:35.000Z</published>
    <updated>2022-12-06T08:18:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发中常用到各种通配符，目前通配符规范较多，有linux通配符，也有nodejs通配符。简单记录一下区别和各自的使用场景，</p><h1 id="linux通配符"><a href="#linux通配符" class="headerlink" title="linux通配符"></a>linux通配符</h1><ul><li>* 匹配零个或者多个字符，但是不匹配”.”开头的文件, 也不会匹配/之外的内容（限制在单个路径）</li><li>? 匹配任何单个字符</li><li>~yang 用户杨根目录</li><li>[0-9] 匹配0-9 一次</li><li>[!0-9] 不匹配0-9一次</li></ul><p>linux是先匹配再执行。比如touch *.txt。先匹配发现没有则不执行。</p><p>touch {1..9}.txt 先解开大括号创建1到9的txt</p><p>后来bash又在这个基础上扩展了几个语法</p><ul><li><strong> 跨目录匹配，也是先按照目录展开模式再匹配    ls <em>/</em>.* 和 ls </strong>/<em>.</em> 有区别</li><li>{a,b,c} 重复执行匹配模式，先展开大括号再执行*等匹配</li><li>{a..c} 重复执行a到c之间的匹配模式</li><li>?(parttern-list) 匹配一次括号里面的模式</li><li>*(parttern-list) 匹配0次或者多次</li><li>+(parttern-list) 匹配一次或者多次</li><li>@(parttern-list) 匹配一次</li><li>!(parttern-list) 不匹配</li></ul><p>回到开头node中大部分都使用的是扩展后的语法，而且是自行实现，不和平台挂钩。但是我们在命令行中执行命令时根据使用shell的版本，有可能没有实现一些扩展语法</p><p>比如在rimraf中删除东西 rimraf *<em>/node_modules 有可能就不会删除，因为没有实现\</em>* 语法。</p><p>还有一个坑是npm中执行脚本，npm执行脚本不一定会在当前的shell执行，有可能会在其他的shell。就会出现glob语法和在命令行执行不一致的情况，比如上面的rimraf。<br>大部分工具目前都是用的自定义的glob，通过将glob用引号包裹起来可以避免shell的glob模式</p><p><a href="https://medium.com/@jakubsynowiec/you-should-always-quote-your-globs-in-npm-scripts-621887a2a784" target="_blank" rel="noopener">npm 中一定要用引号包裹</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;开发中常用到各种通配符，目前通配符规范较多，有linux通配符，也有nodejs通配符。简单记录一下区别和各自的使用场景，&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://blog.xunserver.cn/archives/f255ffad.html"/>
    <id>https://blog.xunserver.cn/archives/f255ffad.html</id>
    <published>2022-12-05T13:56:44.000Z</published>
    <updated>2022-12-05T13:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经常用docker，但是从来没有系统性的总结过docker满足生产力需要掌握的内容</p><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>docker可以理解为一个具有初始操作的快照模版，docker通过运行一个镜像生成容器。</p><ul><li>docker pull nodejs 拉取镜像</li><li>docker images 或者 docker ls 查看本地镜像</li><li>docker image rm xx-image</li></ul><h4 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"&#123;</span></span><br><span class="line"><span class="string">  "</span>registry-mirrors<span class="string">": [</span></span><br><span class="line"><span class="string">    "</span>https://hub-mirror.c.163.com<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>https://mirror.baidubce.com<span class="string">"</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;"</span> &gt;&gt; /etc/daemon.json</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器相当于镜像的实例化，每个容器都是一个进程，如果想让容器一直存在需要容器的启动进程一直存在。</p><ul><li>docker container ls 查看当前系统的容器</li><li>docker run –name somename -it –rm -p -v –mount –link -d –restart。<ul><li>-p 本地端口:容器内端口；</li><li>-v 本地本地路径（绝对路劲）|数据卷:容器内路径</li><li>–mount source=some-volumn,target=/var/xxx  绑定本地目录或者数据卷</li><li>-it 绑定本地的输入输出</li><li>–rm 容器终止后删除容器</li><li>–restart always 容器总是重启</li><li>–link 添加另一个容器来组成网络(总是或默认创建一个容器网络)</li></ul></li><li>docker container inspect xxx 查看容器具体信息</li><li>docker container exec  xx -it sh 容器执行某个新命令，常用于进入容器查看信息</li></ul><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>docker 数据卷（相当于一个目录）可用在多个容器之前共享，不会随着容器终止而清空内容，通过–mount 或者-v 绑定到容器中</p><ul><li>docker volume xxxname</li><li>docker volume inspect xxx 查看某个数据卷，主要查看存放位置等。</li></ul><h3 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h3><ul><li>docker network ls 查看所有的网络</li><li>docker network create -d bridge xxx 创建一个桥接网络（一个新的网络，桥接在原host上面的）</li></ul><p>docker 在安装时默认会生成host和bridge两个网络。重点是bridge网络，通过虚拟网桥docker0和容器的网口连接，虚拟网桥又通过宿主机的iptable进行转发。</p><p>我们每创建一个网络就相当于开了一个子网，可以自定义网关和子网范围</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>docker 能够从Dockerfile文件创建镜像，一般社区中的镜像大部分都是Dockerfile创建，Dockerfile是由一系列指令构成，每一个指令都会构建一层，指令不要太多，功能类似的指令尽量放到一层</p><ul><li>FROM 镜像基础来源，可以是另一个镜像</li><li>RUN 执行命令， 尽量将多个指令合并 &amp;&amp; \</li><li>COPY 复制目录或者文件到镜像中，支持linux通配符 COPY home* /user/src/home, 会自动创建目录，而且会保留文件的元数据（权限等）</li><li>ADD 如果是URL，会直接下载文件（权限600），如果是压缩包会解压。ADD指令不会缓存， 每次都会重新构建。总是使用COPY，需要解压时才使用ADD</li><li>CMD 容器的启动命令，容器总是需要一个默认启动命令 CMD [“nginx”, “-g”, “xx”]</li><li>ENTRYPOINT 如果指明了该项，CMD会作为ENTRYPOINT的参数拼接在后面，常用实现一个命令行工具，比如ENTRYPOINT实现指令 CMD实现参数</li><li>ENV配置镜像默认环境变量，</li><li>ARG 配置在构建过程中的环境变量，而且只在FROM后生效用于辅助构建。但是不会存在到镜像中。比如声明一些变量</li><li>VOLUME 定义匿名卷，VOLUME /data 将/data挂载到匿名卷中，如果容器启动时没有指明卷，就会匿名生成一个，所以不是很关注的卷不需要自己再挂载目录</li><li>EXPOSE 声明容器内部暴露的端口</li><li>WORKDIR 声明每个指令镜像内的工作目录（和build时分开），注意在dockerfile中下面不会工作，因为每条指令是单独的，不会共享<br>  RUN cd /app<br>  RUN echo “sdf” &gt; xx.txt </li><li>USER 指定当前指令之后所有的指令的user，同样也是要在FROM后，而且系统中必须要先创建这个角色</li><li>SHELL 指定RUN ENTRYPOINT CMD指令在哪个shell下运行。默认是[“/bin/sh”, “-c”]</li></ul><h4 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h4><p>如果不用多阶段构建，需要将上一个容器的内容拷贝(docker cp)到宿主机，再用COPY拷贝到下一个阶段的容器中去<br>FROM ubuntu:lasted as builder<br>WORKDIR /app/data<br>COPY ./test ./test<br>RUN npm build<br>FROM ubuntu:lasted as builder  // 需要和上面一个FROM相同<br>RUN npm run deploy</p><p>docker build -f xxxdockerfile -t nginx:tag ./xxx –target builder<br>注意最后一个./xx 表示构建过程中的上下文，比如COPY ./local/xxx /app 表示的是.local的相对位置， docker会将上下文目录中所有内容拷贝到镜像中，通过.dockerignore忽略部分文件</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h3><p>docker compose文件主要由两部分组成，公共部分和容器部分。公共部分指明当前compose需要创建的网络，数据卷等。容器部分和启动容器类似</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;经常用docker，但是从来没有系统性的总结过docker满足生产力需要掌握的内容&lt;/p&gt;
&lt;h3 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>脚本大全</title>
    <link href="https://blog.xunserver.cn/archives/b7b7cac5.html"/>
    <id>https://blog.xunserver.cn/archives/b7b7cac5.html</id>
    <published>2022-12-05T13:46:16.000Z</published>
    <updated>2022-12-05T13:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "registry-mirrors": [</span></span><br><span class="line"><span class="string">    "https://hub-mirror.c.163.com",</span></span><br><span class="line"><span class="string">    "https://mirror.baidubce.com"</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;'</span> &gt;&gt; /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">DOCKER_CONFIG=/usr/<span class="built_in">local</span>/lib/docker/cli-plugins</span><br><span class="line">sudo mkdir -p <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">sudo curl -SL https://download.fastgit.org/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span class="variable">$DOCKER_CONFIG</span>/cli-plugins/docker-compose</span><br><span class="line">chmod +x <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker compose"></a>安装docker compose</h3><h3 id="部署jenkins"><a href="#部署jenkins" class="headerlink" title="部署jenkins"></a>部署jenkins</h3><p>命令行部署<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir jenkins</span><br><span class="line">chmod 777 jenkins</span><br><span class="line">cd jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录下面的密码</span></span><br><span class="line">docker run --name jenkins -p 8080:8080 -p 50000:50000 -v $PWD:/var/jenkins_home --rm -it jenkins/jenkins:lts-jdk11</span><br><span class="line">docker run --name jenkins -p 8080:8080 -p 50000:50000 -v $PWD:/var/jenkins_home -d --restart always jenkins/jenkins:lts-jdk11</span><br></pre></td></tr></table></figure></p><p>使用docker compose部署<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">    jenkins_home:</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    jenkins:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">jenkins/jenkins:lts-jdk11</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"50000:50000"</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="attr">            - jenkins_home:</span><span class="string">/var/jenkins_home</span></span><br></pre></td></tr></table></figure></p><h3 id="部署snoar"><a href="#部署snoar" class="headerlink" title="部署snoar"></a>部署snoar</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  sonarqube:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">sonarqube:community</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">sonarqube</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">sonarqube</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      SONAR_JDBC_URL:</span> <span class="attr">jdbc:postgresql://db:5432/sonar</span></span><br><span class="line"><span class="attr">      SONAR_JDBC_USERNAME:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">      SONAR_JDBC_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - sonarqube_data:</span><span class="string">/opt/sonarqube/data</span></span><br><span class="line"><span class="attr">      - sonarqube_extensions:</span><span class="string">/opt/sonarqube/extensions</span></span><br><span class="line"><span class="attr">      - sonarqube_logs:</span><span class="string">/opt/sonarqube/logs</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9000:9000"</span></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">postgres:12</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      POSTGRES_USER:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">      POSTGRES_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">      POSTGRES_DB:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - postgresql:</span><span class="string">/var/lib/postgresql</span></span><br><span class="line"><span class="attr">      - postgresql_data:</span><span class="string">/var/lib/postgresql/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  jenkins:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">jenkins/jenkins:lts-jdk11</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"50000:50000"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">        - jenkins_home:</span><span class="string">/var/jenkins_home</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  sonarqube_data:</span></span><br><span class="line"><span class="attr">  sonarqube_extensions:</span></span><br><span class="line"><span class="attr">  sonarqube_logs:</span></span><br><span class="line"><span class="attr">  postgresql:</span></span><br><span class="line"><span class="attr">  postgresql_data:</span></span><br><span class="line"><span class="attr">  jenkins_home:</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">docker compose up </span><br><span class="line">docker compose start</span><br></pre></td></tr></table></figure><h3 id="搭建内网测速服务器"><a href="#搭建内网测速服务器" class="headerlink" title="搭建内网测速服务器"></a>搭建内网测速服务器</h3><pre><code>docker run -it --rm --name speedtest -p 9100:80 adolfintel/speedtestdocker run --name speedtest -p 9100:80 --restart always -d adolfintel/speedtest</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装docker&quot;&gt;&lt;a href=&quot;#安装docker&quot; class=&quot;headerlink&quot; title=&quot;安装docker&quot;&gt;&lt;/a&gt;安装docker&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>doc 和 git submodule</title>
    <link href="https://blog.xunserver.cn/archives/7bf438f9.html"/>
    <id>https://blog.xunserver.cn/archives/7bf438f9.html</id>
    <published>2022-12-02T09:31:02.000Z</published>
    <updated>2022-12-02T09:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于搞了一些开源工具，需要一个统一的文档管理，入了vitepress写文档的坑。目前的开源内容有一系列的config文件，集中在@xunserver/config 这个仓库中，通过pnpm管理，每个包都有自己的reameme.md 和changelog.md。<br>还有个仓库存放了icon,style和vui的代码，目前有下面的痛点。</p><ol><li>doc是一个单独仓库只存放文档，文档中还需要引入各个包的readme.md已经changelog。</li><li>除了changelog外，对vui的还需要进行组件的引入，对于style还需要样式的引入。</li><li>目前的doc和vui存放在一起通过pnpm的方式引入。</li></ol><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><p>git submodule 相当于将某个仓库的某个commit作为模块添加项目中，而且对项目透明，项目本身不能去修改。</p><h4 id="git-submodule-add"><a href="#git-submodule-add" class="headerlink" title="git submodule add"></a>git submodule add</h4><p>添加submodule到项目中，执行后git 会下载子模块到项目中。同时生成.gitmodule文件来记录关系</p><h4 id="git-submodule-init"><a href="#git-submodule-init" class="headerlink" title="git submodule init"></a>git submodule init</h4><p>根据.gitmodule文件下载子项目，通常用来父项目第一次拉取后</p><h4 id="git-submodule-deinit"><a href="#git-submodule-deinit" class="headerlink" title="git submodule deinit"></a>git submodule deinit</h4><p>清空子项目代码但是不删除.gitmodule中的关系</p><h4 id="git-submodule-update"><a href="#git-submodule-update" class="headerlink" title="git submodule update"></a>git submodule update</h4><p>根据.gitmodule 中记录的子项目的commit下载子项目的代码，通过git submodule update –remote 总是根据远端的来下载。通常情况下如果子项目更新后，父项目能够感知到子项目的最新commit，并且会生成一个差异文件，如果差异文件被提交。另一个合作伙伴需要根据最新的commit的下载代码</p><h4 id="git-submodule-foreach"><a href="#git-submodule-foreach" class="headerlink" title="git submodule foreach"></a>git submodule foreach</h4><p>批量操作子项目，git submodule foreach “echo $name”</p><h4 id="git-rm-path"><a href="#git-rm-path" class="headerlink" title="git rm path"></a>git rm path</h4><p>删除子项目</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>doc文档有两种情况是需要更新的</p><ol><li>相关的readme或者组件变更，doc本身无需变更。这种情况doc设置一个每天自动重新构建即可。</li><li>doc本身需要变更，变更部分内容。这种需要doc发布后触发重新构建</li><li>手动更新</li></ol><h3 id="doc文档"><a href="#doc文档" class="headerlink" title="doc文档"></a>doc文档</h3><p>doc文档使用的vitepress, 可以在文档中直接引入vue3代码，同时还支持markdown引用。这两个可以引入其他的包的说明文档和vui组件的文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于搞了一些开源工具，需要一个统一的文档管理，入了vitepress写文档的坑。目前的开源内容有一系列的config文件，集中在@xunse
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rollup</title>
    <link href="https://blog.xunserver.cn/archives/de3a6b85.html"/>
    <id>https://blog.xunserver.cn/archives/de3a6b85.html</id>
    <published>2022-12-02T09:04:00.000Z</published>
    <updated>2022-12-02T09:04:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>child_process</title>
    <link href="https://blog.xunserver.cn/archives/e4a9508d.html"/>
    <id>https://blog.xunserver.cn/archives/e4a9508d.html</id>
    <published>2022-12-02T02:20:01.000Z</published>
    <updated>2022-12-02T02:20:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>nodejs 提供创建操作子进程的能力，通过spawn exec fork execFile四个api。后面三个均是spawn的衍生。</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>shell是一个快捷启动进程的壳子，当我们在shell中敲命令（外部命令）时，实际是通过shell作为父进程创建了一个子进程比如 node xxx.js。所以当我们关闭shell窗口时，对应的命令也会kill。没登录一次shell窗口就会产生一个shell进程。具体是哪个shell使用用户自行配置的。</p><p>有时候我们写shell脚本会指定该脚本由哪个shell执行，流程是先打开对应的进程，对应的进程对脚本内容进行处理。</p><h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>nodejs本身在执行时也是一个进程，如果是被shell直接调用，则是shell的衍生进程。当nodejs通过child_process 创建子进程时，如果有些子进程还需要通过shell来启动，所以还能指定是否启动shell。 主进程关闭后子进程也会关闭。进程需要关注的是以下几个点</p><ol><li>stdout，stdin，stderr 表示进程输入，输出和错误。由于当前的默认情况子进程的stdout,stdin,stderr是pipe，意思是通过管道向外发射。也可以设置为和父进程共享，借助父进程来输入输出</li><li>还有一种IPC子进程，父子进程通过IPC通信，nodejs中是on(‘message’)和send。通过fork创建或者执行std是IPC。 IPC只能用都是node进程的情况下</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> child_process <span class="keyword">from</span> <span class="string">'child_process'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shelljs = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> child = child_process.spawn(<span class="string">'ls'</span>, &#123;</span><br><span class="line">        shell: <span class="literal">true</span></span><br><span class="line">    &#125;, (err, stdin, stdout) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程追加"><a href="#进程追加" class="headerlink" title="进程追加"></a>进程追加</h3><p>很多情况子进程都是启动后执行完毕就会自动关闭，每次执行上下文不共享。但是也可以启动一个常驻的进程，比如直接启动一个shell。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; spawn, spawnSync &#125; <span class="keyword">from</span> <span class="string">"child_process"</span>;</span><br><span class="line"><span class="keyword">const</span> mergeShellOptions = <span class="function">(<span class="params">...options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...options);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getGlobalShell = <span class="function">(<span class="params">(shell</span>) =&gt;</span> (option, config) =&gt; &#123;</span><br><span class="line">  shell = shell || Shell.createShell(option, config);</span><br><span class="line">  <span class="keyword">return</span> shell;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> getDefaultOption = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  shell: <span class="literal">true</span>,</span><br><span class="line">  stdio: [<span class="string">"pipe"</span>, <span class="string">"inherit"</span>, <span class="string">"inherit"</span>],</span><br><span class="line">  timeout: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> getBash = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">"win32"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">cmd</span>: <span class="string">"cmd"</span>, <span class="attr">arg</span>: <span class="string">"/C"</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">cmd</span>: <span class="string">"sh"</span>, <span class="attr">arg</span>: <span class="string">"-c"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultOption = getDefaultOption();</span><br><span class="line">  <span class="keyword">static</span> createShell(option, config) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Shell(option, config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> exec(cwd, option, config) &#123;</span><br><span class="line">    <span class="keyword">const</span> shell = getGlobalShell(option, config);</span><br><span class="line">    shell.exec(cwd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * shell示例的选项</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  shellOption;</span><br><span class="line">  shell;</span><br><span class="line">  <span class="keyword">constructor</span>(option, config) &#123;</span><br><span class="line">    <span class="keyword">this</span>.shellOption = mergeShellOptions(Shell.defaultOption, option);</span><br><span class="line">    <span class="keyword">this</span>.shell = spawn(getBash().cmd, <span class="keyword">this</span>.shellOption);</span><br><span class="line">  &#125;</span><br><span class="line">  exec(cwd) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cwd);</span><br><span class="line">    <span class="keyword">this</span>.shell.stdin.write(cwd + <span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close() &#123;</span><br><span class="line">    <span class="keyword">this</span>.shell.kill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Shell;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;nodejs 提供创建操作子进程的能力，通过spawn exec fork execFile四个api。后面三个均是spawn的衍生。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>npm包的CI和changeset</title>
    <link href="https://blog.xunserver.cn/archives/69a9cdfe.html"/>
    <id>https://blog.xunserver.cn/archives/69a9cdfe.html</id>
    <published>2022-11-30T03:28:44.000Z</published>
    <updated>2022-11-30T03:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前的config仓库按照monorepo的方式存放的，里面有完全不同种类的的config包，大部分包的依赖的都是独立的,也有部分公共的包比如typescript和prettier。同时各个仓库的发布阶段都是交给github-action在做CI如何设计。</p><h3 id="changeset"><a href="#changeset" class="headerlink" title="changeset"></a>changeset</h3><p>changeset生成能够被消耗的changeset描述文件, 开发自行调整描述文件， changeset version消耗描述文件，调整需要发布的包， changeset publish到各个包发布，流程很简单。<br>按照下面步骤描述下细节</p><ol><li><p>changeset init 初始化changeset配置</p></li><li><p>changeset add 对当前更改新增描述文件，changeset add 会自动的查找到当前的修改的包，前提是没有commit的情况下</p></li><li><p>选择包进入命令式的交互填写，主要写需要更新那些包。通过patch minor 或者major的方式更新包。</p></li><li><p>changeset version消耗刚才描述文件来对包进行version的更新。</p></li><li><p>changeset publish 会到各个包下面进行npm publish，这个步骤也可以通过自行publish实现</p></li></ol><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ol><li>本地修改代码，运行changeset add 生成消耗文件，可以不修改文件，强行生成changeset文件。</li><li>正常上传代码，github action 根据存在pub来决定是否打包</li><li>github action 运行 changeset version 消耗文件同时修改版本号</li><li>运行pnpm -F “[origin/xx]”… run build 来分别执行相关的包的build</li><li>运行pnpm publish -F “[origin/xxx]” 发布包或者[HEAD]…（当前分支比较）</li><li>使用<code>git add -A</code> git commit -m “” git push 推送包， 也可以通过merge来推送包避免多人修改时的问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;目前的config仓库按照monorepo的方式存放的，里面有完全不同种类的的config包，大部分包的依赖的都是独立的,也有部分公共的包比
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重绘回流</title>
    <link href="https://blog.xunserver.cn/archives/f9860ccd.html"/>
    <id>https://blog.xunserver.cn/archives/f9860ccd.html</id>
    <published>2022-11-29T05:10:59.000Z</published>
    <updated>2022-11-29T05:10:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="渲染层-renderLayer"><a href="#渲染层-renderLayer" class="headerlink" title="渲染层 renderLayer"></a>渲染层 renderLayer</h3><p>每一个DOM都会对应一渲染对象(renderObject)，每一个渲染对象在处于不同相同的坐标空间时，就会形成一个RenderLayers渲染层。下面的元素都会生成渲染层。不能开启渲染层的renderObject和其最近一个有渲染层的父节点共享。</p><ol><li>根元素</li><li>有明确定位的属性 position不为static</li><li>opacity &lt; 1</li><li>transform 存在</li><li>overflow 不为visible<h3 id="合成层"><a href="#合成层" class="headerlink" title="合成层"></a>合成层</h3>对于某些符合条件的渲染层会自动处理成合成层，每一个合成层都有一个独立的GraphicsLayer, 不满足和最近一个拥有图形层的共享。<br>下面这些条件能开启图形层</li><li>3D transforms</li><li>video canvas iframe // 即使video没有单独的渲染层，但是video在根元素下，也满足</li><li>css 实现的opacity 动画</li><li>will-change 属性</li><li>position:fixed</li><li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</li></ol><p>除了显示生成合成层外，还有部分隐式的情况，通过谷歌开发者工具render 和 layers可以看到图层的详细信息</p><p>隐式场景会导致合成层过多的情况下，浏览器出自动层压缩，会将能够合并的合成层压缩到一个图形层中</p><h3 id="图形层-GraphicsLayer"><a href="#图形层-GraphicsLayer" class="headerlink" title="图形层 GraphicsLayer"></a>图形层 GraphicsLayer</h3><p>图形层是最终输出到界面的布局，</p><h3 id="合成层的好处"><a href="#合成层的好处" class="headerlink" title="合成层的好处"></a>合成层的好处</h3><ol><li>合成层是GPU渲染，比较快</li><li>重绘时只会绘制合成层本身</li><li>transform 和 opacity 不会发出重绘</li></ol><h3 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h3><p>回流指的是layer的重新生成，有以下几种情况会导致回流，注意的回流都是对当前的合成层进行，不会影响到其他的</p><ol><li>首次渲染</li><li>浏览器窗口改变</li><li>元素的位置或者尺寸发生变化</li><li>新增删除可见元素</li><li>元素内容变换</li><li>元素的字体大小发生变化</li><li>激活伪类</li><li>设置style值    // 尽力改css类</li><li>查询元素边界大写</li></ol><p>重绘是指改变visible,outline，背景色等，不会影响的到元素位置的变化。</p><p>我们平常的说的重绘和回流都是针对某一个图形层来说的。 所以优化的思路从两个角度出发。</p><ol><li>尽可能避免回流操作，比如减少style直接js写值，减少对offset的读取。多个新增删除操作合并等。</li><li>如果没办法避免回流操作，尽量将回流的范围缩小，比如将改动的元素提升到合成层中，注意的合成层的条件是现有渲染层，合成层是从渲染层中来的。常见的生成合成的操作有transform: translate，对</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;渲染层-renderLayer&quot;&gt;&lt;a href=&quot;#渲染层-renderLayer&quot; class=&quot;headerlink&quot; title=&quot;渲染层 renderLayer&quot;&gt;&lt;/a&gt;渲染层 renderLayer&lt;/h3&gt;&lt;p&gt;每一个DOM都会对应一渲染对象(re
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>keep-alive</title>
    <link href="https://blog.xunserver.cn/archives/c5319648.html"/>
    <id>https://blog.xunserver.cn/archives/c5319648.html</id>
    <published>2022-11-28T08:26:36.000Z</published>
    <updated>2022-11-28T08:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>根据组件的tag和keys来生成具有LRU的缓存的map，通过添加abstract属性，避免出现在$parent链中，每次渲染时总是检查缓存是否存在，如果存在render函数直接返回之前的vnode并添加缓存。返回新的vnode后在keep-alive的patch阶段又会重新走createComponent子组件的操作，就会进入之前的缓存逻辑</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>组件的源码比较简单，有两个需要主要的点吗，设置abstract:true 还是能通过parent属性获取到keep-alive组件示例，对于手动的修改缓存队列或者在自定义缓存时有用。keep-alive的render实际是返回一个vnode，如果能够根据key查到缓存则返回之前的vnode。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> slot = <span class="keyword">this</span>.$slots.default</span><br><span class="line">  <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot) <span class="comment">// 找到第一个子组件对象</span></span><br><span class="line">  <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">  <span class="keyword">if</span> (componentOptions) &#123; <span class="comment">// 存在组件参数</span></span><br><span class="line">    <span class="comment">// check pattern</span></span><br><span class="line">    <span class="keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="comment">// 组件名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// 条件匹配</span></span><br><span class="line">      <span class="comment">// not included</span></span><br><span class="line">      (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">      <span class="comment">// excluded</span></span><br><span class="line">      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span> <span class="comment">// 定义组件的缓存key</span></span><br><span class="line">      <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">      <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">      ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">      : vnode.key</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123; <span class="comment">// 已经缓存过该组件</span></span><br><span class="line">      vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">      <span class="comment">// make current key freshest</span></span><br><span class="line">      remove(keys, key)</span><br><span class="line">      keys.push(key) <span class="comment">// 调整key排序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache[key] = vnode <span class="comment">// 缓存组件对象</span></span><br><span class="line">      keys.push(key)</span><br><span class="line">      <span class="comment">// prune oldest entry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="keyword">this</span>.max)) &#123; <span class="comment">// 超过缓存数限制，将第一个删除</span></span><br><span class="line">        pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="keyword">this</span>._vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnode.data.keepAlive = <span class="literal">true</span> <span class="comment">// 渲染和执行被包裹组件的钩子函数需要用到</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心在下面的createComponent中，针对keepAlive包裹的组件，在重新渲染时vnode因为是之前的vnode，会触发init额外的流程。进而直接到prepatch阶段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vnode指的是根据keep-alive render函数得到的包裹组件的vnode，拿到vnode。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> i = vnode.data;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">        <span class="comment">// isReactivated用来判断组件是否缓存。</span></span><br><span class="line">        <span class="keyword">var</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive;</span><br><span class="line">        <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">            <span class="comment">// 执行组件初始化的内部钩子 init，下面的componentVNodeHooks.init</span></span><br><span class="line">          i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">          <span class="comment">// 其中一个作用是保留真实dom到vnode中</span></span><br><span class="line">          initComponent(vnode, insertedVnodeQueue);</span><br><span class="line">          insert(parentElm, vnode.elm, refElm);</span><br><span class="line">          <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> componentVNodeHooks = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        vnode.componentInstance &amp;&amp;</span><br><span class="line">        !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">        vnode.data.keepAlive</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">        <span class="keyword">var</span> mountedNode = vnode; <span class="comment">// work around flow</span></span><br><span class="line">        componentVNodeHooks.prepatch(mountedNode, mountedNode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 将组件实例赋值给vnode的componentInstance属性</span></span><br><span class="line">        <span class="keyword">var</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">          vnode,</span><br><span class="line">          activeInstance</span><br><span class="line">        );</span><br><span class="line">        child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 后面分析</span></span><br><span class="line">    prepatch: <span class="function"><span class="keyword">function</span> <span class="title">prepatch</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 新组件实例</span></span><br><span class="line">        <span class="keyword">var</span> options = vnode.componentOptions;</span><br><span class="line">        <span class="comment">// 旧组件实例</span></span><br><span class="line">        <span class="keyword">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">        updateChildComponent(</span><br><span class="line">            child,</span><br><span class="line">            options.propsData, <span class="comment">// updated props</span></span><br><span class="line">            options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">            vnode, <span class="comment">// new parent vnode</span></span><br><span class="line">            options.children <span class="comment">// new children</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;根据组件的tag和keys来生成具有LRU的缓存的map，通过添加abstract属性，避免出现在$parent链中，每次渲染时总是检查缓存
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>form-data的故事</title>
    <link href="https://blog.xunserver.cn/archives/ff59502f.html"/>
    <id>https://blog.xunserver.cn/archives/ff59502f.html</id>
    <published>2022-11-28T02:42:02.000Z</published>
    <updated>2022-11-28T02:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>前端请求中经常碰到content-type，主要需要关注的是以下几种<br>application/json 请求以json的形式上传，后端需要按照的json的方式解析body<br>application/x-www-form-urlencoded 按照key=name&amp;key=name的形式将参数拼接在body中。其中key和name需要用URLSearchParams处理(不能用urlEncodeComponent是历史遗留原因，application/x-www-form-urlencoded 需要将空格转义成+，urlEncodeComponent将空格转义成%20)<br>multipart/form-data boundary=xxxx 将请求按照xxxx分隔包围，每一段包括一个字段.<br>其中每一个keyvalue 也需要转义（空格转+）,这一块比较奇怪</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;前端请求中经常碰到content-type，主要需要关注的是以下几种&lt;br&gt;application/json 请求以json的形式上传，后端
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>diff算法</title>
    <link href="https://blog.xunserver.cn/archives/3387ce12.html"/>
    <id>https://blog.xunserver.cn/archives/3387ce12.html</id>
    <published>2022-11-23T03:26:05.000Z</published>
    <updated>2022-11-23T03:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单diff"><a href="#简单diff" class="headerlink" title="简单diff"></a>简单diff</h3><p>简单diff的思路是判断新列表的节点是否是递增的，如果不是递增的旧列表中的节点移动到新列表中节点的前一位的后面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactDiff = <span class="function">(<span class="params">prevVnodeList, newVnodeList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newVnodeList.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newVnode = newVnodeList[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newVnodeList.length; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevVnode = prevVnodeList[j];</span><br><span class="line">            <span class="keyword">if</span>(newVnode.key === prevVnode.key) &#123;</span><br><span class="line">                patchDom(prevVnode, newVnode)</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= lastIndex) &#123;</span><br><span class="line">                    lastIndex = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.insertBefore(newVnode.el, newChildren[i<span class="number">-1</span>].el.nextSibling)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双端diff"><a href="#双端diff" class="headerlink" title="双端diff"></a>双端diff</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单diff&quot;&gt;&lt;a href=&quot;#简单diff&quot; class=&quot;headerlink&quot; title=&quot;简单diff&quot;&gt;&lt;/a&gt;简单diff&lt;/h3&gt;&lt;p&gt;简单diff的思路是判断新列表的节点是否是递增的，如果不是递增的旧列表中的节点移动到新列表中节点的前一位的后
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="https://blog.xunserver.cn/archives/6098be36.html"/>
    <id>https://blog.xunserver.cn/archives/6098be36.html</id>
    <published>2022-11-22T14:07:22.000Z</published>
    <updated>2022-11-22T14:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础中需要注意的点"><a href="#基础中需要注意的点" class="headerlink" title="基础中需要注意的点"></a>基础中需要注意的点</h3><ol><li><p>如果通过path导航，总是回匹配到子路由，如果只想展示父路由，通过name的形式导航</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    name: <span class="string">'parent'</span>,</span><br><span class="line">    path: <span class="string">'/foo'</span>,</span><br><span class="line">    component: ParentComponent,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        name: <span class="string">'child'</span>,</span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        component: ChildrenComponent</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">'/foo'</span>&#125;)   <span class="comment">// 会渲染parentComponent 和 ChildComponent</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'parent'</span>&#125;) <span class="comment">// 只会渲染parentComponent，刷新后</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套路由中子路由如果使用绝对路径代表路由不嵌套，只嵌套组件。</p></li><li><p>新版本vue-router 支持正则表达式的匹配，同时取消了*匹配符，404页面使用正则来匹配</p></li><li><p>支持命令路由和命令视图, 大致意思是同一个url，可以渲染多个视图。<router-view name="slider"> ，路由配置中通过components: {default: xxx, slider: xxx} 形式配置</router-view></p></li><li><p>支持别名，即url显示一个地址，实际界面展示的是另一个路由url配置的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    url: <span class="string">'/'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    alias: <span class="string">'/home'</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="comment">// 直接浏览器导航到/home 也会展示/的界面</span></span><br></pre></td></tr></table></figure></li><li><p>支持相对重定向和动态重定向，相对重定向对于当前路由，绝对重定向通过传入一个函数实现</p></li><li><p>router-link 支持v-slot，将跳转能力自自定义。</p></li><li><p>同时router-view 也支持v-slot，能将路由页面进行包裹</p></li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li>组件内beforeRouterLeave</li><li>全局的beforeEach</li><li>路由的beforeEach</li><li>组件内的beforeEnter</li><li>全局的beforeResolve</li><li>全局的afterEach</li><li>新路由的beforeCreated到beforeMounted</li><li>老路由组件的销毁</li><li>新路由mounted</li></ol><h3 id="几个关键概念-RouterRecord-和-RouterLocation"><a href="#几个关键概念-RouterRecord-和-RouterLocation" class="headerlink" title="几个关键概念 RouterRecord 和 RouterLocation"></a>几个关键概念 RouterRecord 和 RouterLocation</h3><p>RouterRecord 表示路由表，指的是用户在配置路由时的定义，用户配置时RouterRecordRaw，vue-router内部补全成RouterRecordNormalized。理解成路由实例的构造器选项</p><p>RouterLocation是实际生效的路由，理解成路由的实例化。其中RouterLocationRaw用于push的参数，相当于根据RouterLocationRaw查找到具体的路由。在to和from以及matched中$route均是这个对象</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><ol><li>通过mixin添加在beforeCreated中添加绑定_currentRoot._router和_currentRoot._route 属性，在Vue.prototype中将两个$route和$router代理到上面两个属性上.</li><li>注册两个全局组件router-link 和 router-view</li><li>同时还添加了防止重复安装的判断</li></ol><h4 id="new-VueRouter-Routes"><a href="#new-VueRouter-Routes" class="headerlink" title="new VueRouter(Routes)"></a>new VueRouter(Routes)</h4><p>大致过程就是递归的根据的传入的RouteRecordRaw 生成路由记录表，并生成nameMap和pathMap，同时生成match函数，通过调用match函数获取当前匹配的路由表</p><h4 id="router-init"><a href="#router-init" class="headerlink" title="router.init()"></a>router.init()</h4><p>在安装插件时根据是否是根路由，对不同的路由模式添加监听，监听函数主要对url变化时，调整当前激活的路由写入到全局$route中</p><h4 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h4><p>router总是监听当前$route的变化并喧嚷路由对应的界面。通过添加$dataView参数标记自身，查找自身的深度来渲染matched数组的第几项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础中需要注意的点&quot;&gt;&lt;a href=&quot;#基础中需要注意的点&quot; class=&quot;headerlink&quot; title=&quot;基础中需要注意的点&quot;&gt;&lt;/a&gt;基础中需要注意的点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果通过path导航，总是回匹配到子路由，如果只想展示父路由，通过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>状态管理进阶和实战</title>
    <link href="https://blog.xunserver.cn/archives/6e558469.html"/>
    <id>https://blog.xunserver.cn/archives/6e558469.html</id>
    <published>2022-11-21T13:31:11.000Z</published>
    <updated>2022-11-21T13:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex是vue2中首选的状态管理工具，包括state、mutation、action 三大马车，大致是组件触发dispatch()或者commit()来修改state中的数据</p><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>redux包括state，所有的state必须要通过dispatch(action) 来触发，redux内部通过事先注册号的的reducer来处理dispath(action) 的动作。reducer是一个接受action的函数，通过action来改变当前的state并返回新的state。<br>可以看到，vuex是在redux将action和reducer的功能简化。对于同步的场景，mutation 中定义的其实就是reducer，mutation的名字作为action。vuex中将并未将action统一化，也有将action统一管理的。比如可以用create_action 来生成标志。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> unSubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = store.getState()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>实现一个简易版本的redux<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">const</span> listeners = [];</span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)  <span class="comment">// 取消订阅</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        <span class="keyword">this</span>.listeners.forEach(<span class="function"><span class="params">listen</span> =&gt;</span> listen())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        getState,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h3><p>createStore第二个参数设置applyMiddleware，applyMiddleware 大致理解成核心是compose，会返回一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(a, b =&gt; <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">    (...args) =&gt; fn1(fn2(...args))</span><br><span class="line">    (...args) =&gt; fn1(fn2(fn3(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFunc = compose(fn1, fn2, fn3)</span><br><span class="line">newFunc(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// applyMiddle</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> thunk = <span class="function">(<span class="params">next</span>) =&gt;</span> (action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> log = <span class="function">(<span class="params">next</span>) =&gt;</span> (action) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.end(<span class="string">'end'</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dispatch = compose(thunk, log)(store.dispatch) <span class="comment">// log(thunk(store.dispatch)) =&gt; (action)</span></span><br><span class="line">dispatch(action)  =&gt; log(action) =&gt; thunk(action) =&gt; log(action)</span><br></pre></td></tr></table></figure></p><p>完整版本的redux<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> middlewareApply = <span class="function">(<span class="params">...middleWares</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> reducer =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">        middleWares = middleWares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleWares(&#123;</span><br><span class="line">            dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args),</span><br><span class="line">            getState: store.getState</span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">const</span> dispatch = compose(...middleWares)(store.dispatch)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, storeEnhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(storeEnhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> storeEnhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> state</span><br><span class="line">    <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subScribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(listener)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line">    dispatch(&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        subScribe,</span><br><span class="line">        getState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> () =&gt; <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// next 理解为传递到下一个action处理器，其中dispatch也是一个处理器。</span></span><br><span class="line">    <span class="comment">// 不执行next表示中间件停止</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> log = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>, getState())</span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>, getState());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, middlewareApply(thunk, log))</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: <span class="string">"ADD"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        store.dispatch(<span class="string">'ADD'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="vuex中的高级应用"><a href="#vuex中的高级应用" class="headerlink" title="vuex中的高级应用"></a>vuex中的高级应用</h3><ol><li><p>支持模块，默认情况下模块是全局注册的，在多个模块中同时注册相同的名字在触发时会被同时响应，添加namespace: true后会将所有的action 和 mutation添加模块前缀，触发时需要补上前缀(在命名空间下通过root: true 注册全局)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        foo: &#123;</span><br><span class="line">            namespace: <span class="literal">true</span></span><br><span class="line">            actions: &#123;  </span><br><span class="line">                add() &#123;  <span class="comment">// dispatch('foo/add', xxx)</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                del: &#123;   <span class="comment">// dispatch('del', xxx)</span></span><br><span class="line">                    root: <span class="literal">true</span>,</span><br><span class="line">                    handler() &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        boo: &#123;</span><br><span class="line">            actions: &#123;</span><br><span class="line">                del() &#123;&#125;  <span class="comment">// dispatch('del', xxx)  会同时触发两个模块</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>支持动态注册模块 registerModule()，适合于模块数据</p></li></ol><h3 id="vuex-插件机制和执行流程"><a href="#vuex-插件机制和执行流程" class="headerlink" title="vuex 插件机制和执行流程"></a>vuex 插件机制和执行流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> logPlugin = <span class="function">(<span class="params">pluginOptions</span>) =&gt;</span> &#123;  <span class="comment">// 日志组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">        store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;  <span class="comment">// 订阅每次mutation操作</span></span><br><span class="line">            <span class="built_in">console</span>.log(mutation.type, mutation.payload, state)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个持久化state的插件</span></span><br></pre></td></tr></table></figure><h3 id="vuex源码流程"><a href="#vuex源码流程" class="headerlink" title="vuex源码流程"></a>vuex源码流程</h3><ol><li><p>注册插件 Vue.use(Vuex)， 通过插件的形式在vue各个实例的beforeCreate前注入vuex.store 实例，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Vuex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> apply(Vue) &#123;</span><br><span class="line">        Vue.mixin(beforeCreate: VueInit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> VueInit = () &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.$parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$parent.$store   <span class="comment">// 如果当前是子节点，总是取父节点的，但是有个问题是如果当前节点还未挂载是没有$parent属性的，比如是new实例生成的的组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$options.store  <span class="comment">// 如果当前是根节点，取根节点传入的store</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行store构造函数，初始化各个state，各个mutation监听，各个action监听。生成dispatch函数和commit函数，再执行插件初始化，最后执行devtool</p><ol><li>installModule 安装当前module上的state和根state绑定(如果有),通过Vue.set() 添加新的子state到上级state上</li><li>forEachMutation， 将module中mutation绑定到根store中mutationMap上， 如果是命名空间还需要添加前缀。如果同名是推入数组</li><li>forEachAction 和 forEachGetter 同理</li><li>遍历子模块继续执行installModule</li></ol></li><li><p>初始响应式，将所有的state代理到new Vue({data: state})的实例上，getter代理到computed,这样获取state就会生成watcher进入dep，修改store中的state会触发所有的监听。</p></li></ol><p>插件的应用场景有如下几个。</p><ol><li>通过aop的方式处理action或者mutation的中执行错误，重写store.commit 或者 store.dispatch 函数实现</li><li>通过subscribe或者subscribeAction监听，实现日志或者持久化等操作，默认情况监听函数发生在action和mutation之前，通过参数prepend: true 添加到前面实现对state的再处理。</li><li>通过replaceState来初始化state，注意的是replace是替换根state，如果需要特殊的state，直接赋值即可</li><li>通过registerrModule 来注册一些业务外不关注的module</li></ol><h3 id="vuex-实例上需要关注的方法"><a href="#vuex-实例上需要关注的方法" class="headerlink" title="vuex 实例上需要关注的方法"></a>vuex 实例上需要关注的方法</h3><p>state, commit, dispatch, subscribe, subscribeAction, watch, registerModule, replaceState(storagePlugin中需要用到)</p><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h3&gt;&lt;p&gt;vuex是vue2中首选的状态管理工具，包括state、mutation、action 三大马车，大致是组件触发dispat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue中的高阶组件</title>
    <link href="https://blog.xunserver.cn/archives/f235dcea.html"/>
    <id>https://blog.xunserver.cn/archives/f235dcea.html</id>
    <published>2022-11-21T09:09:46.000Z</published>
    <updated>2022-11-21T09:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vue 中组件复用的方式有 mixin，extend，高阶组件和组合组件三种方式</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="如何创建一个全局单例组件"><a href="#如何创建一个全局单例组件" class="headerlink" title="如何创建一个全局单例组件"></a>如何创建一个全局单例组件</h4><p>const instance = new Vue(options), 通过这种方式能够实现部分命令方式调用组件。</p><h4 id="mixin-和-extend-的区别"><a href="#mixin-和-extend-的区别" class="headerlink" title="mixin 和 extend 的区别"></a>mixin 和 extend 的区别</h4><p>mixin 是对选项的混合，发生在生成 vue 实例之前，extend 是对 vue 实现继承，返回的是一个 vue 实例， 类似于 Object.create()</p><h4 id="HOC-实现一个-promise-组件"><a href="#HOC-实现一个-promise-组件" class="headerlink" title="HOC 实现一个 promise 组件"></a>HOC 实现一个 promise 组件</h4><p>代码中经常有请求一个 api，然后根据 api 显示不同逻辑的需求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-if=&quot;loading&quot;&gt;loading&lt;/div&gt;</span><br><span class="line">    &lt;div v-if=&quot;!loading&quot;&gt;</span><br><span class="line">      &#123;&#123; content &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content: &quot;&quot;,</span><br><span class="line">      loading: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getContent() &#123;</span><br><span class="line">      this.loading = true;</span><br><span class="line">      this.$api.get(&quot;/some&quot;).then((content) =&gt; &#123;</span><br><span class="line">        this.loading = false;</span><br><span class="line">        this.content = content;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过 HOC 将该组件的请求逻辑提取出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withPromise = <span class="function">(<span class="params">component, promiseFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        loading: <span class="literal">true</span>,</span><br><span class="line">        result: <span class="literal">null</span>,</span><br><span class="line">        error: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">      promiseFn()</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.result = data;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.error = error;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">const</span> loading = <span class="function"><span class="params">()</span> =&gt;</span> h();</span><br><span class="line">      <span class="keyword">const</span> error = <span class="function"><span class="params">()</span> =&gt;</span> h();</span><br><span class="line">      <span class="keyword">const</span> content = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        h(component, &#123;</span><br><span class="line">          loading: <span class="keyword">this</span>.loading,</span><br><span class="line">          content: <span class="keyword">this</span>.content,</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">"div"</span>, <span class="literal">null</span>, [</span><br><span class="line">        <span class="keyword">this</span>.loading ? loading() : <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">this</span>.error ? error() : <span class="literal">null</span>,</span><br><span class="line">        !<span class="keyword">this</span>.loading &amp;&amp; !<span class="keyword">this</span>.error ? content() : <span class="literal">null</span>,</span><br><span class="line">      ]);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newComponent = withPromise(view, getContent);</span><br></pre></td></tr></table></figure><p>上面实现还有几个问题没有解决</p><ol><li>请求函数的参数还没有，不能通过子组件自定义</li><li>子组件参数如果有变化，触发新的查询</li><li>外部组件对于子组件的 prop 等参数没有传递到子组件,包括插槽等</li></ol><p>第一个文件有两种方式拿到子组件的请求参数，第一个是静态的，通过在子组件选项或者定义上面绑定一个特殊的键值实现，或者将值绑定到子组件的实例上，通过 this.$refs 拿到子组件的实例后获取。</p><p>第二个问题需要在子组件上动态的添加 watch 函数，watch 函数监听子组件的查询参数并且触发的回调是父组件的请求函数</p><p>第三个问题，直接将 hoc 组件上的$attrs 和 $listeners 绑定到子组件的 props 和 $listeners 中，其中有个 v-bind 绑定的点，v-bind 总是会属性绑定到 props 中，对是否是 props 的处理，都是子组件的关心的，而不是父组件关心的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withPromise = <span class="function">(<span class="params">component, promiseFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        loading: <span class="literal">false</span>,</span><br><span class="line">        content: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(component, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...this.attrs,</span><br><span class="line">          loading: <span class="keyword">this</span>.loading,</span><br><span class="line">          content: <span class="keyword">this</span>.content,</span><br><span class="line">        &#125;,</span><br><span class="line">        on: <span class="keyword">this</span>.$listeners,</span><br><span class="line">        ref: <span class="string">"component"</span>, <span class="comment">// 用于在mounted时获取实例</span></span><br><span class="line">        scopedSlot: <span class="keyword">this</span>.$scopedSlot</span><br><span class="line">      &#125;, <span class="keyword">this</span>.$children);  <span class="comment">// 注意 $children 和 $slot的区别</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getContent() &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">        promiseFn(<span class="keyword">this</span>.$refs.component.requestParams)</span><br><span class="line">          .then(<span class="function">(<span class="params">content</span>) =&gt;</span> (<span class="keyword">this</span>.content = content))</span><br><span class="line">          .finally(<span class="function"><span class="params">()</span> =&gt;</span> (<span class="keyword">this</span>.loading = <span class="literal">false</span>));</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.getContent();</span><br><span class="line">      <span class="keyword">this</span>.$refs.component.$watch(<span class="string">'requestParams'</span>, <span class="keyword">this</span>.getContent())</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newComponent = withPromise(view, getContent)</span><br><span class="line"><span class="comment">// &lt;newComponent onClick="xxx"&gt;xxxx&lt;/newComponent&gt;</span></span><br></pre></td></tr></table></figure><p>其实还有个问题，发现没有，就是还是没法将ref进行传递。 要想获取到子组件需要一直ref来使用。</p><h3 id="新增props处理"><a href="#新增props处理" class="headerlink" title="新增props处理"></a>新增props处理</h3><p>上面代码中对于props处理在每个HOC组件中都差不多类似。简单一点通过<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalProps = <span class="function">(<span class="params">vm</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        attrs: <span class="keyword">this</span>.vm.$attrs,</span><br><span class="line">        on: <span class="keyword">this</span>.vm.$listeners,</span><br><span class="line">        slotScopeds: <span class="keyword">this</span>.vm.$slotScopeds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h(compoennt, &#123;...normalProps(<span class="keyword">this</span>), <span class="attr">props</span>: &#123;&#125;&#125;, <span class="keyword">this</span>.$children)</span><br></pre></td></tr></table></figure></p><h2 id="组合优于HOC"><a href="#组合优于HOC" class="headerlink" title="组合优于HOC"></a>组合优于HOC</h2><p>组合的意识是通过compose的方式将原有的HOC  fn3(fn2(fn1))的方式变成compose(fn1, fn2, fn3)，将组件作为传递。如果withPromise没有参数，都不需要包装<br>compose(() =&gt; withPromise(), withLog)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vue 中组件复用的方式有 mixin，extend，高阶组件和组合组件三种方式&lt;/p&gt;
&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="https://blog.xunserver.cn/archives/e919cac4.html"/>
    <id>https://blog.xunserver.cn/archives/e919cac4.html</id>
    <published>2022-11-21T02:48:53.000Z</published>
    <updated>2022-11-21T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="axios-中间件"><a href="#axios-中间件" class="headerlink" title="axios 中间件"></a>axios 中间件</h3><p>axios将拦截函数处理成pormise的resolve和reject函数，通过promise链来完成中间件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        name: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        error: error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.use = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.interceptorsData.push(&#123;</span><br><span class="line">        resolve, reject</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    axios.interceptorsData.reduce(<span class="function">(<span class="params">promise, current</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(current.resolve).catch(current.reject)</span><br><span class="line">    &#125;)  <span class="comment">// 通过一次性构建promise链实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="vuex中间件"><a href="#vuex中间件" class="headerlink" title="vuex中间件"></a>vuex中间件</h3><p>vuex 中间通过aop的方式添加中间件，在原有处理逻辑上增加前置或者后置操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vuex.plugin = <span class="function">(<span class="params">&#123;before, after&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    vuex.dispatch.before(before)</span><br><span class="line">    vuex.dispatch.before(after)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        beforeFn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(thism, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="reduce中间件"><a href="#reduce中间件" class="headerlink" title="reduce中间件"></a>reduce中间件</h3><p>通过组合函数的形式，将函数的结果传入下一个函数，compose(fn1, fn2, fn3) = fn3(fn2(fn1()))，见store篇章</p><h3 id="koa中间件"><a href="#koa中间件" class="headerlink" title="koa中间件"></a>koa中间件</h3><p>有点像yeild的方式，每次调用中间件，都是把下一个中间的传入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">middleware.use(<span class="function">(<span class="params">ctx, next</span>)=&gt;</span> &#123;</span><br><span class="line">    ctx.xxx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.xxx)</span><br><span class="line">&#125;)</span><br><span class="line">middleware.run = <span class="function">(<span class="params">i=<span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = middleware.data[i]   <span class="comment">// 保存的所有中间件</span></span><br><span class="line">    <span class="keyword">if</span>(!current[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, middleware.run(i + <span class="number">1</span>)))  <span class="comment">// 通过这种方式实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本质上中间件是一个按照既定模板来实现流式编程的工具，通过这种方式，外部的代码可以侵入到内部实现去耦合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;axios-中间件&quot;&gt;&lt;a href=&quot;#axios-中间件&quot; class=&quot;headerlink&quot; title=&quot;axios 中间件&quot;&gt;&lt;/a&gt;axios 中间件&lt;/h3&gt;&lt;p&gt;axios将拦截函数处理成pormise的resolve和reject函数，通过pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>axios</title>
    <link href="https://blog.xunserver.cn/archives/a09486d2.html"/>
    <id>https://blog.xunserver.cn/archives/a09486d2.html</id>
    <published>2022-11-21T02:27:06.000Z</published>
    <updated>2022-11-21T02:27:06.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack hook体系</title>
    <link href="https://blog.xunserver.cn/archives/390d2d6d.html"/>
    <id>https://blog.xunserver.cn/archives/390d2d6d.html</id>
    <published>2022-11-18T13:11:38.000Z</published>
    <updated>2022-11-18T13:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>webpack 在执行流程中通过大量的hook对外暴露出当前的执行流程，并允许外界程序通过hook修改或者自定义程序行为。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SyncHook &#125; <span class="keyword">from</span> <span class="string">'tapable'</span>;</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> SyncHook;</span><br><span class="line"></span><br><span class="line">sleep.tap(<span class="string">'test-name'</span>, (webpackContext) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(webpackContext);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test-name callback'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sleep.call(some)</span><br></pre></td></tr></table></figure></p><p>由上面可以看到，webpack hook 机制就是新建hook, 插件订阅hook，webpack内部触发hook、<br>针对这三个流程，又做了详细的扩充</p><h3 id="创建hook"><a href="#创建hook" class="headerlink" title="创建hook"></a>创建hook</h3><p>webpack 有不同的hook,不同hook表示内部的回调如何执行。<br>按照回调逻辑区分</p><ul><li>正常依次执行回调</li><li>waterfall:前一个回调的值会带入下一个回调</li><li>bail 依次调用回调，如果有任何一个回调的值返回undefined，后续的回调值取消</li><li>loop 循环执行回调， 直到有一个回调返回undefined</li></ul><p>按照执行回调的方式区分</p><ul><li>sync 同步的执行回调，通过return 返回回调的结果</li><li>async 异步的执行的回调，通过return promies 结果或者callback结果。异步的钩子通过同步的方式执行没有意义拿不到结果，当然不需要结果的除外。</li></ul><h3 id="订阅hook"><a href="#订阅hook" class="headerlink" title="订阅hook"></a>订阅hook</h3><p>有tap(同步订阅),tapAsync(异步订阅)和tapPromise(返回一个promise订阅的方式)</p><h3 id="执行hook"><a href="#执行hook" class="headerlink" title="执行hook"></a>执行hook</h3><p>执行回调的方式有call(依次执行回调函数，会等回调函数执行完), callAsync(异步的依次执行函数，不会等待)，promise(返回一个promise来表示回调的执行结果)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;webpack 在执行流程中通过大量的hook对外暴露出当前的执行流程，并允许外界程序通过hook修改或者自定义程序行为。&lt;br&gt;&lt;figu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macos安装笔记</title>
    <link href="https://blog.xunserver.cn/archives/772650a1.html"/>
    <id>https://blog.xunserver.cn/archives/772650a1.html</id>
    <published>2022-11-15T07:21:53.000Z</published>
    <updated>2022-11-15T07:21:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><ol><li>谷歌浏览器，国内网络使用Safri下载有问题，通过</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;必备软件&quot;&gt;&lt;a href=&quot;#必备软件&quot; class=&quot;headerlink&quot; title=&quot;必备软件&quot;&gt;&lt;/a&gt;必备软件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;谷歌浏览器，国内网络使用Safri下载有问题，通过&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack 配置优化通用步骤</title>
    <link href="https://blog.xunserver.cn/archives/4525b971.html"/>
    <id>https://blog.xunserver.cn/archives/4525b971.html</id>
    <published>2022-11-06T14:19:53.000Z</published>
    <updated>2022-11-06T14:19:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>webpack优化指的两个方便，第一个是打包过程优化，提高打包效率，缩小打包时间。第二个是上线项目的优化，通过配置优化chunk，提高线上加载速度。</p><h3 id="优化打包流程"><a href="#优化打包流程" class="headerlink" title="优化打包流程"></a>优化打包流程</h3><h4 id="resolve-modules-resolve-extensions"><a href="#resolve-modules-resolve-extensions" class="headerlink" title="resolve.modules, resolve.extensions"></a>resolve.modules, resolve.extensions</h4><p>. resovle.modules 用于限定node_module查找范围，默认情况下是从会遍历到文件系统根目录，通过配置指定的node_module 减少查找范围,配置到项目的node_module即可<br>. resolve.extensions 当解析模块时，模块无后缀名时查找顺序，使用正确的扩展名方便查询。如果是ts项目，将ts排列在最前面，如果是vue项目，添加vue到最前面(不过一般来说不同，vue项目要求需要将.vue在代码中补全，以获得编辑器的补全功能)</p><h4 id="module-noParse"><a href="#module-noParse" class="headerlink" title="module.noParse"></a>module.noParse</h4><p>当引入第三方模块时，一般第三方已经编译过，没必要webpack再次编译处理。使用noParse让webpack停止对模块的继续解析。</p><h4 id="module-rule-loader、resolveLoader"><a href="#module-rule-loader、resolveLoader" class="headerlink" title="module.rule.loader、resolveLoader"></a>module.rule.loader、resolveLoader</h4><p>在配置loader时，loader使用的require(‘xxx-loader’)来加载，也会遍历到根模块，使用一个绝对路径来配置。<br>resolveLoader 配置loader的查找目录</p><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;webpack优化指的两个方便，第一个是打包过程优化，提高打包效率，缩小打包时间。第二个是上线项目的优化，通过配置优化chunk，提高线上加
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>家庭wifi组件方案</title>
    <link href="https://blog.xunserver.cn/archives/e77ca00e.html"/>
    <id>https://blog.xunserver.cn/archives/e77ca00e.html</id>
    <published>2022-10-31T02:39:11.000Z</published>
    <updated>2022-10-31T02:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近搭建家庭wifi，目前屋里的wifi客厅放一个，在房间信号不是很好。需要搭建一个支持漫游的wifi方案，爱快、高恪等方案太贵，开源的padavan漫游效果又太差。综合下来集客的AC + Ap方案性价比比较高。在房间和客厅任意走动，wifi不会出现断的情况。</p><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>集客方案需要AC一个和多个AP，AC主要是起一个控制调度作用，AP负责信号的发送，AC需要设备配置不用多高，而且不需要网络，我的设备如下<br>AC: 小米路由器mini * 1   闲鱼、PDD 大概30内包邮<br>AP1: JCG Q20/q10 pro（支持wifi6，书房给mac用）   闲鱼 大概 70 一个<br>AP2：红米 AC2100（作为客厅主力AP）     闲鱼85包邮<br>AP3: 小米路由器pro（备用机器，刷了padavan随时接管屋里wifi）   闲鱼85包邮<br>AP4：vs010（ax3000）   闲鱼90包邮<br>AP5：rax3000Q（ax3000）   闲鱼100包邮<br>AP6：大麦 dw33d （ac 1750） 闲鱼45包邮<br>AP7: 华硕arch17             闲鱼120包邮<br>AP8: 小米R3G (ac 1200， 最能造的机器)    闲鱼 50包邮<br>上面的方案中小米路由器不支持集客AP方案，刷了246ND能正常开机和只能打开2.4G wifi，只能降级作为备用机器，不参与家庭AP。其他设备都可以选择，都是自己折腾过能用的设备。</p><h3 id="小米路由器mini-刷入-AC"><a href="#小米路由器mini-刷入-AC" class="headerlink" title="小米路由器mini 刷入 AC"></a>小米路由器mini 刷入 AC</h3><h4 id="breed"><a href="#breed" class="headerlink" title="breed"></a>breed</h4><ol><li><a href="http://miwifi.com/miwifi_download.html" target="_blank" rel="noopener">官方固件</a>去下载自己的型号的开发版固件</li><li>电脑网页登录路由器后台管理页面，一般是<a href="http://192.168.31.1/" target="_blank" rel="noopener">192.168.31.1</a>。右上角找到固件升级，上传开发版固件升级。</li><li>升级完后，手机小米wifi app绑定路由器</li><li>官方查看SSH密码， <a href="https://d.miwifi.com/rom/ssh" target="_blank" rel="noopener">https://d.miwifi.com/rom/ssh</a>，并按照提示刷入解锁固件（注意，如果下载工具失败，浏览器控制台找到报错的文件，直接下载），U盘除了放入解锁固件外，还需要把breed的固件也同时放入，在<a href="https://breed.hackpascal.net/" target="_blank" rel="noopener">https://breed.hackpascal.net/</a>中找到xiaomini的breed固件，下载放入U盘即可。</li><li>按照官方提示解锁固件后，登录路由器后台SSH（直接 ssh <a href="mailto:root@192.168.31.1" target="_blank" rel="noopener">root@192.168.31.1</a>或者使用putty等工具）。首先备份固件 cat /proc/mtd 查看分区，然后使用 dd if=/dev/mdt0 of=/extdisks/sda4/xxx.bin 挨着备份固件到U盘。备份完成后使用 mtd_write write breed.bin Bootloader 刷入 breed。刷入后等10S拔电即可。</li></ol><h4 id="刷入集客AC"><a href="#刷入集客AC" class="headerlink" title="刷入集客AC"></a>刷入集客AC</h4><ol><li><a href="http://file.cnrouter.com/" target="_blank" rel="noopener">集客官方</a>网页下载 企业路由X1 固件。</li><li>连接好网线，先捅reset不放 ，再开机，10S后松开</li><li>电脑浏览器192.168.1.1 进入控制台。固件更新页面，选择固件X1固件上传。等待刷机后即可。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>集客AC目前是旁AC模式，简单的将原有网络插入wan口即可，不会对原有网络侵扰，如果不使用小米路由器mini，也可以使用虚拟机安装一个x86的集客AC控制器</p><h3 id="小米R3G-刷入集客AP"><a href="#小米R3G-刷入集客AP" class="headerlink" title="小米R3G 刷入集客AP"></a>小米R3G 刷入集客AP</h3><p>小米R3G首先刷入breed，方法同上面小米mini。同样是breed控制台刷入集客AP246ND固件（集客选择MKT AP就能找到），刷入好网线接入到wan口</p><h3 id="AC管理"><a href="#AC管理" class="headerlink" title="AC管理"></a>AC管理</h3><p>AC和AP通电后都接入同一个局域网，等待1分钟后，AP会自动发现AC。到路由器的管理页面查看是否有新设备（有GECOO开头的就是），一个IP一个IP的试，有输入的用户名和密码的就是AC控制器。AC控制器的默认密码是changemeplease。进入后修改各种参数集客，5G射频2不用管，配置了也没得用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近搭建家庭wifi，目前屋里的wifi客厅放一个，在房间信号不是很好。需要搭建一个支持漫游的wifi方案，爱快、高恪等方案太贵，开源的pa
      
    
    </summary>
    
    
  </entry>
  
</feed>
