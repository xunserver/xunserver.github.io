<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bang</title>
  
  <subtitle>生活总会有惊喜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xunserver.cn/"/>
  <updated>2022-10-22T01:49:50.000Z</updated>
  <id>https://blog.xunserver.cn/</id>
  
  <author>
    <name>yangmanman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>all-in-boom</title>
    <link href="https://blog.xunserver.cn/archives/ff614c6c.html"/>
    <id>https://blog.xunserver.cn/archives/ff614c6c.html</id>
    <published>2022-10-22T01:49:50.000Z</published>
    <updated>2022-10-22T01:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近在折腾家里的网路设备，原因娃要出生了， 搞一个好点的存储设备来保存娃的照片视频等，顺便把屋里的设备升级一下。<br>先介绍下现在屋里的网络布局<br><img src="/post-images/all-in-boom/家庭网络拓扑.drawio.png" alt="家庭网络拓扑图"></p><h3 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h3><p>光猫买的是华为的B610-4E替换了运营商送的光猫，比较稳定而且可以自由改桥接。该光猫有4个千兆口，规划如下</p><ul><li>eth0: 网络桥接端口，桥接光猫和软路由(二层端口)</li><li>eth1: 光猫管理端口，192.168.2.4（三层端口）</li><li>eth2: 备用端口，如果路由器故障，通过光猫拨号</li><li>eth3: 电视桥接端口，同网络桥接端口</li></ul><p>需要注意的是，华为的三层lan不是桥接接口， 不能勾选多个三层lan。路由器配置页面的使能啥啥的，就是是否启用。<br>wan口配置三个接口</p><ol><li>桥接模式lan1，路由器拨号</li><li>桥接模式lan4，电视拨号</li><li>路由模式lan3，但是不启用</li></ol><h3 id="软路由"><a href="#软路由" class="headerlink" title="软路由"></a>软路由</h3><p>接下来是软路由的选购。i255 2.5G网口虽然更便宜，但是有断流问题，二来屋里交换机都是千兆，用不上。N5105发热过大，不适合放在弱电箱。单内存的机器在esxi下，装两个虚拟机内存就不够。没法all-in-boom。</p><p>选了倍控家的j4125 4*i211千兆 双内存的这款机器两个内存累计最多16G，j4125 4C4T 2.0Ghz。还支持一个2.5寸的硬盘，刚好能够满足路由器 + homeassistant + nas的需求。网口刚好做以下规划</p><ul><li>eth0: esxi 虚拟路由器的接口 （上面桥接了hass 和 esxi 的管理端口）</li><li>eth1: 连接光猫桥接的lan1，作为路由器的wan口</li><li>eth2: 路由器的lan口</li><li>eth3: 直通给nas</li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>弱电箱: 里面有7个通向客厅房间的网口，电视柜两个，客厅电话线（被我替换成了网线）1个，三个房间4个（主卧两个）。光猫3个（除了光猫的桥接口连接到软路由上）， nas和esxi加起来一个，电视桥接口一个。需要一个16口的交换机。把三个设备塞到一起还是需要费点时间。</p><p>书房: 有个双路的x99机器，一共6个网口。安转的esxi虚拟了三个虚拟机，作为平常生产工具用。直通了3个网口。由于书房只有一个网口，也需要一个交换机来扩展网口，其实可以用路由器的ap模式来扩展，但是我只有三个网口的小米路由器R3G。搞了一个8口千兆交换机</p><p>客厅中电视柜: 机顶盒 <em> 1、switch </em> 1、摄像头 <em> 2、小米AX 6000 </em> 1。之前电视柜还有个做nas的主机(升级后不需要)。 也是需要一个8口千兆交换机</p><h3 id="AP部分"><a href="#AP部分" class="headerlink" title="AP部分"></a>AP部分</h3><ul><li>客厅AX6000使用的小米默认固件开启AP模式，5G网络满足几个笔记本和手机打游戏需求。2.4G 网络用于物联网设备的接入、包括窗帘、客厅灯、电脑开机卡、万能红外遥控器、小米多模网关、小爱音响、斐讯音响、门锁、客厅空调、斐讯空气净化器、厨房的冰箱、电饭煲、洗衣机、加湿器还有各种涂鸦智能的开关（设备就是这么多）</li><li>卧室中关门信号就弱，两个卧室各安转了一个小米R3G（便宜而且体积不占地方），刷了breed安装了H大固件，开启AP模式，同时将发射功率调整到原来的20%。卧室中路由器通过交换机模式满足电视的上网，通过2.4G支持卧室中的物联网设备(遥控器、床头小爱音响、房间灯、空调等)，5G用于平常上网。</li></ul><p>全屋漫游问题，由于小米的固件是在太垃圾，而且试用过小米的漫游方案，确实效果一般，bug还多。采用了弱信号剔除和一致性SSID的方案，把全屋各个WIFI名字设置成一致。各个AP降低放射功率，开启弱信号替换。弱信号的方案成本较低。</p><h3 id="NAS-和-HomeAssistant"><a href="#NAS-和-HomeAssistant" class="headerlink" title="NAS 和 HomeAssistant"></a>NAS 和 HomeAssistant</h3><p>NAS采用的群晖方案，对于小白来说比较简单。j4125中直接虚拟一个，然后RDM直通硬盘<br>HomeAssistant使用官方提供的虚拟机镜像，直接安装。</p><h3 id="各种物联网设备"><a href="#各种物联网设备" class="headerlink" title="各种物联网设备"></a>各种物联网设备</h3><ul><li>小米系列<ul><li>小米触屏音响必须要买，家里的语音交互、TTS、主动问询等功能都依赖该设备。主卧放一个小个、客厅放一个打的当电子相框用。</li><li>小米多模网关、小米系的传感器依赖</li><li>小米传感器: 光照传感器（配合窗帘自动开关），人体传感器、米家蓝牙夜灯（带人体传感器和光照传感器）、门窗传感器，温湿度传感器</li><li>小米家电: 小米空调、小米电视、小米洗衣机、小米冰箱、小米扫地机器人、小米门锁。</li></ul></li><li>涂鸦系<ul><li>涂鸦系的红外万能遥控器，PDD 19块钱包邮，多买几个、控制老电视和其他牌子的空调必备。</li><li>涂鸦系的wifi开关 19包邮，多买几个</li><li>涂鸦系的射频遥控器  淘宝69一个</li></ul></li><li>HomeAssistant论坛<ul><li>窗帘电机 298，支持mqtt、html、tcp等多个协议、通过巴法云可以接入小爱。</li><li>各种开关，把墙上的开关内都置换上。也是支持ha接入。 </li></ul></li><li>其他<ul><li>斐讯N1，刷YYF看电视</li><li>斐讯R1，安转DLAN 放会儿歌</li><li>斐讯m1，空气质量检测，配置ha使用</li><li>各类摄像头，摄像头推荐雄迈（记得关闭外网访问），能够接入ha，小米系的没法接入。</li><li>开机卡，用于打开电脑和关闭电脑。</li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="j4125-安装esxi"><a href="#j4125-安装esxi" class="headerlink" title="j4125 安装esxi"></a>j4125 安装esxi</h3><p>倍控家j4125 + 4 * i211网卡+双内存版本准系统670R。如果对断流能够忍耐的也可选2.5G，准系统550R。准系统需要笔记本内存条DDR4L，最高2666MHZ，单个内存最多支持8G。闲鱼买大概120一根，建议买三星。还需要一个msata的硬盘，最小准备一个64G的盘。</p><p>需要直通的硬盘记得先在PE上面把分区表删除掉保存，修改分区表格式和msata盘一致。</p><p>硬件安装步骤如下</p><ol><li>拆开主机外壳，找到内存插槽，内存条上有个缺口，缺口左右一长一短。斜向上对准主板插口，擦入后，按一下，听见咔一声即可。拆内存时，先把两边的卡扣向外拉一下，内存就自动弹出来了。</li><li>主板上有两个接口和msata硬盘的接口长得一样，注意看有一个写了个WIFI，安装到没写wifi的接口上，先把接口上的固定硬盘的螺丝取下来。插入硬盘后安装螺丝固定。</li><li>安装机械硬盘，先使用送的sata转接线连接硬盘，这个比较简单，然后找主板上的sata接口和供电接口，供电接口是4针的，sata接口长的和硬盘的上接口一致。连接好后，把硬盘固定到主机的背板上。背板是要扣回主机的，硬盘要安装在背板里面，塞进主机。</li></ol><p>系统安装esxi比较稳定，我连续100天没关机。自行官网下载esxi镜像，或者在恩山论坛x86专区下载别人编译好的镜像。</p><ol><li>找一个U盘，最好16G，usb3.0。使用软碟通写入镜像到U盘，或者使用balenaEtcher软件写盘</li><li>U盘插入倍控，连接好键盘。插上电源线后狂按F11进入bios界面。先恢bios到默认设置，检查下VT-D是否开启。选择U盘启动</li><li>进入esxi加载页面后，会有5S等待时间，5S内按下shift + o 键编辑安转设置，输入空格autoPartitionOSDataSize=8192（这一步必要的，用于调整虚拟闪存大小，错过了关机重来）。然后回车进入安装界面，然后根据提示一路默认，系统记得安装到msata盘上。</li><li>系统安装好会需要在控制台调整管理端口，开机进入系统后，按F2进入网络配置，选择network adaptor，用一根网线连接电脑和主机的eth0口，观察哪个控制台哪个是connect的，选择这个网口作为管理端口。ESC退出后会重启网络端口，在进入ipv4配置页面，将管理端口的IP设置为192.168.2.16，网管设置为192.168.2.2 掩码 255.255.255.0，保存后退出。</li><li>电脑网线连接eth0的网口，电脑设置静态IP为192.168.2.21 掩码 255.255.255.0 网关192.168.2.2。</li><li>设置好电脑IP后，登录<a href="https://192.168.2.16进入esxi管理页。" target="_blank" rel="noopener">https://192.168.2.16进入esxi管理页。</a></li></ol><h3 id="esxi-直通切换"><a href="#esxi-直通切换" class="headerlink" title="esxi 直通切换"></a>esxi 直通切换</h3><p>安装好esxi系统后，首先规划好网口，按照先前介绍的来规划，将eth1 eth2 eth3 切换成直通。按照下图来切换</p><h3 id="安装openwrt"><a href="#安装openwrt" class="headerlink" title="安装openwrt"></a>安装openwrt</h3><ol><li>恩山下载任意的x86镜像。一般镜像都有EFI和不带EFI的进项，选择带有EFI字样镜像。下载后解压成.img格式为止</li><li>安装写盘工具写虚拟硬盘，百度<code>starwindconverter官网</code>, 随意填写些信息开始下载。根据提示开始转换，local file =&gt; localfile =&gt; vmdk =&gt; esxi server img =&gt; preallocat。一定要选择预分配，没必要选灵活增长。</li><li>esxi创建openwrt虚拟机，兼容性选择最新的那个(7.0 U2)，系统类型选择linux, linux5.x 64位 或则更高。</li><li>储存选择默认，在下一步都要删除的。</li><li>下一步硬件配置中把所有的设备删除干净，存储、usb和控制器都不要。删除后保存创建虚拟机，路由器CPU 2核心，单插槽两个2核心，内存选2G。不要开机</li><li>重新编辑刚才创建好的虚拟机添加硬盘，选择已有的硬盘，在弹出页中将刚才在用starwindconverter转换好的两个vmdk文件上传，并选择。</li><li>添加直通的两个网口，点击添加其他设备，添加PCI设备，选择需要直通的网卡。保存后退出，不要开机</li><li>开启esxi的ssh访问，然后电脑上ssh <a href="mailto:root@192.168.2.16ssh" target="_blank" rel="noopener">root@192.168.2.16ssh</a>连接上esxi宿主机。使用vmkfstools 对vmdk文件进行扩容 vmkdstools -X 2G /vmfs/volumns/datastore1/router/xxxx.vmdk，一般2G足够应付后面的需求了。</li><li>再到网页编辑虚拟机选择，引导默认取消安全引导，使用EFI引导。</li><li>开机，进入到正常的跑代码openwrt安装完成</li></ol><h3 id="x86路由器-系统配置"><a href="#x86路由器-系统配置" class="headerlink" title="x86路由器 系统配置"></a>x86路由器 系统配置</h3><ol><li>系统安装完成后，电脑网线在eth1、eth2刚才直通给openwrt网口上来回试，如果哪个网口能正常分配IP，表示这个网口是lan口（注意先把网口静态地址设置为DHCP）。</li><li>连接上lan口，根据网关地址找到openwrt的管理地址。根据自己的喜好调整lan配置，我一般习惯把lan口管理地址设置为192.168.2.2，同时设置DHCP 地址为192.168.2.100 ~ 192.168.2.240。192.168.2.100 之前作为屋里设备的静态地址，后面作为那些无关设备的动态地址。</li><li>配置wan口拨号，找运营商要个拨号账密，前提是光猫改了桥接才能使用。光猫改桥接找安装宽带的师傅要个超级密码，登录光猫后删除TR69端口，然后每个页面的都拍照备份一次就可以随意折腾了。</li><li>配置好wan口，lan口就可以替换原有的上网设备了。 光猫桥接口连接wan口，openwrtlan口连接原来的路由器的lan（使原有的路由变成一个AP交换机），先临时这么用</li></ol><p>安装x86路由器的原因是里面有很多固件，可以自由折腾，比如我的就是fast.com测试就有1.2GBPS，还安转了DDNSTO，在外面随时网页连接屋里的设备，还有NPS和zerotier。有了这个路由器，屋里的ATV随时随地可以看YouTube，检索内容也更快。</p><h3 id="安装DSM"><a href="#安装DSM" class="headerlink" title="安装DSM"></a>安装DSM</h3><p>DSM大致和上面的openwrt差不多，把网上下载的好的img镜像转换成vmdk，网上img镜像也只是一个引导镜像，不需要扩容，nas需要的大流量传输，配置好直通网卡。同样是删除所有其他的设备，只添加一个sata控制器。硬盘的话添加转换的镜像，然后需要到ssh中配置RDM直通，到设备管理器中查询需要直通的硬盘ID，vmkfstools -Z /vmfs/disks/xxxx /vmfs/volunms/datastore1/xxx.vmdk。再在虚拟配置中添加这个vmdk硬盘。<br>需要注意的是添加的vmdk文件都需要放在sata控制器上，同时添加引导文件在前，直通硬盘在后。同时也别忘了取消EFI安全引导。</p><p>正常开机后，注意选择sata引导，等1分钟后，到路由器的设备列表中查找是否存在dsm设备的获取到IP。浏览器输入http://获取到的IP:5000 进入dsm安装页面。按照提示上传pat文件，按照提示格式化第二个硬盘，等待10分钟后DSM安装完成。</p><h3 id="安装HomeAssistant"><a href="#安装HomeAssistant" class="headerlink" title="安装HomeAssistant"></a>安装HomeAssistant</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;最近在折腾家里的网路设备，原因娃要出生了， 搞一个好点的存储设备来保存娃的照片视频等，顺便把屋里的设备升级一下。&lt;br&gt;先介绍下现在屋里的网
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>chrome调试通关笔记</title>
    <link href="https://blog.xunserver.cn/archives/a6025488.html"/>
    <id>https://blog.xunserver.cn/archives/a6025488.html</id>
    <published>2022-10-09T01:21:41.000Z</published>
    <updated>2022-10-09T01:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>代码在平台运行时会通过backend对外通过调式协议暴露出运行时各种状态，各种调试工具通过解析调试协议实现UI界面（frontend）。chrome使用的是CDP(chrome devtools protocol)。</p><p>谷歌浏览器中有些devtool插件，比如vue devtools 和 react devtool。浏览器插件分为两个部分，一个是可以注入到当前页面的content script，一个是常驻的background部分。此外如果是扩展的devtool部分，还可以有一个devtool page部分。devtool插件通过content script向当前页面注入backend.js（负责收集运行时数据）,页面的backend.js 通过background通道暴露调试协议，devtool page解析调试协议形成页面。</p><p>vscode也可以调试chrome和nodejs中运行时代码，同理vscode也实现了一个frontend，只不过vscode在解析协议上还做了一层adapter，因为vscode不止可以调试js代码。</p><h3 id="chrome-devtool-protocol"><a href="#chrome-devtool-protocol" class="headerlink" title="chrome devtool protocol"></a>chrome devtool protocol</h3><p>chrome通过ws暴露协议，vscode中配置文件如下,主要有两种方式启动chrome调试，request: “launch” 表示启动一个新的chrome示例，默认配置好ws端口。 request: “attach”表示关联到现有的浏览器示例，这个需要在启动浏览器时指定参数（–remote-debugging-port=9222 –user-data-dir=你自己创建的某个目录）</p><p>需要注意的是如果我们手动启动浏览器需要指定–user-data-dir，这个目录保存了当前浏览器的所有配置缓存插件等,而且一个浏览器实例只能同时使用一个数据目录。所以我们在使用launch模式时需要注意，useDataDir的指定，false 表示使用默认（如果已经开了其他实例，启动会失败）,true使用临时目录(默认值)或者指定一个目录</p><p>通过下载金丝雀版本的chrome可以解决这个问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// .vscode/launch.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Launch Chrome"</span>,</span><br><span class="line">            "request": "launch",  // attach</span><br><span class="line">            "type": "chrome",</span><br><span class="line">            "url": "http://localhost:3000",</span><br><span class="line">            "webRoot": "$&#123;workspaceFolder&#125;",  // 相当于指定pathMapping: &#123;"/":"$&#123;workspaceFolder&#125;/"&#125;</span><br><span class="line">            "port": 9222, // 如果type: attach需要指定</span><br><span class="line">            "runtimeExecutable": "canary",  // type修改成 pwd-chrome</span><br><span class="line">            "useDatadir": false,  // 使用默认用户目录</span><br><span class="line">            // "type": "pwd-chrome" </span><br><span class="line">            "runtimeArgs": "--auto-open-devtools-for-tabs", // 额外的启动参数   --auto-open-devtools-for-tabs 自动打开控制台 --incognito 匿名启动</span><br><span class="line">            // 某些情况下sourcemap解析的文件地址和本地目录结构不一致，需要重新修正</span><br><span class="line">            "sourceMapPathOverrides": &#123;  // bunld.js =&gt; source  =&gt; localfile</span><br><span class="line">                "webpack://?:*/*": "$&#123;workspaceFolder&#125;/*" // ?:* 表示匹配不映射， * 表示匹配并映射。 该规则表示</span><br><span class="line">            &#125;,</span><br><span class="line">            // 针对静态文件重新调整</span><br><span class="line">            "pathMapping": &#123;</span><br><span class="line">                "static/js/": "src/js/"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><p>sourcemap是对源码的描述，大部分dev tool都实现了sourcemap的解析，格式如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    version : <span class="number">3</span>,  <span class="comment">// 版本</span></span><br><span class="line">    file: <span class="string">"out.js"</span>,</span><br><span class="line">    sourceRoot : <span class="string">""</span>,</span><br><span class="line">    sources: [<span class="string">"foo.js"</span>, <span class="string">"bar.js"</span>],  <span class="comment">// 多个源文件</span></span><br><span class="line">    names: [<span class="string">"a"</span>, <span class="string">"b"</span>],</span><br><span class="line">    mappings: <span class="string">"AAgBC,SAAQ,CAAEA;AAAEA"</span>, <span class="comment">// 最重要的描述文件</span></span><br><span class="line">    sourcesContent: [<span class="string">'const a = 1; console.log(a)'</span>, <span class="string">'const b = 2; console.log(b)'</span>] <span class="comment">// 原始代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存在一个问题，webpack中开发环境可能会使用eval函数模拟require，eval函数中无法针对字符串实现断点。如果在eval中添加sourceUrl=xxx，会直接添加eval函数的内容到根目录下的xxx，可以实现对eval执行断点。<br>同时，sourceMap可以递归，eval映射出的文件还可以再次指定sourceMapUrl映射到其他目录。</p><p>针对线上环境，打包时生成sourceMap文件，但是放在本地，在浏览器调试时使用filesystem将对线上的sourcemap映射到本地，实现本地调试线上环境(待实验),或者重定向到本地代码</p><p>sourceMap配置参考这个正则表达式<br>/^(eval-|inline-|hidden-)?(noresources-)?(cheap-(module-)?)?source-map?$/<br>eval：在eval函数中添加sourceUrl在调试环境中添加文件。<br>inline：在bundle.js 中sourceMapUrl直接跟sourceMap内容。<br>hidden: 表示不在bundle在关联sourceMap，但是要生成。<br>noresource: 不在sourcemap中包含原始代码<br>cheap: sourcemap只定位到行错误，不到列错误<br>module: sourcemap生成时会包含每个loader处理的sourceMap（关键配置）</p><h3 id="vue中sourceMap存在hash问题"><a href="#vue中sourceMap存在hash问题" class="headerlink" title="vue中sourceMap存在hash问题"></a>vue中sourceMap存在hash问题</h3><p>使用eval会使映射添加hash后缀，最好的办法是不使用hash, 修改devtool: ‘source-map’，或者使用sourceMapPathOverrides重新映射（未成功实现）</p><h3 id="线上问题如何调试"><a href="#线上问题如何调试" class="headerlink" title="线上问题如何调试"></a>线上问题如何调试</h3><p>目前有几种方案解决</p><ol><li><p>线上环境使用noresources构建sourcemap，通过vscode的detools连接到浏览器实现调试</p></li><li><p>把本地的sourcemap文件添加到filesystem，然后对出错的代码文件右键添加sourcemap，选择filesystem中对应sourcemap文件。这种方式不要设置hidden-source-map</p></li><li><p>打包后服务器手动删除所有sourcemap文件，本地保留一份。这样请求map时总是会404， 然后把本地的sourcemap文件添加到filesystem</p></li><li><p>生产环境正常打包sourcemap，但是在请求.map文件时无权限人员加载404，有权限人员能请求，这样既可以在vscode调试，也能在浏览器调试。不过也有问题，每个bundle中会存在sourceUrl，会增大一点包的体积</p></li><li><p>在打包时对每个chunk和map生成一个映射表（hidden方案），在请求chunk时，通过代理对每个chunk后面添加sourcemap语句，sourcemap指向对应的服务（本地或者远端，或者filesystem），这种方式可以在vscode和浏览器。</p></li><li><p>每次打包时总是生成两份dist,一份配置（hidden方案）,另一份正常配置sourcemap(输出目录配置成线上域地址)，通过overrides将线上的请求代理到本地，这样请求的bundle文件就是本地的带有sourcemap的文件，filesystem添加带有sourcemap的文件夹到调试环境中。这种方式不能在vscode中实现调试</p></li><li><p>针对客户浏览器出现的问题，搜集客户代码报错的行和列，通过sourcemap文件反向查找出错误地址，如果sourcemap配置了sourceContent，还可以直接定位具体的文件。</p></li></ol><p>目前最优的方案还是针对不同的用户，展示不同bundle文件。</p><h3 id="pathMapping-和-sourceMapPathOverrides的区别"><a href="#pathMapping-和-sourceMapPathOverrides的区别" class="headerlink" title="pathMapping 和 sourceMapPathOverrides的区别"></a>pathMapping 和 sourceMapPathOverrides的区别</h3><p>前者是对network中是在的请求资源的映射（会自动忽略查询参数），后者是对sourcemap生成的源文件的映射(sourcemap生成文件在请求中是不存在的)。</p><h3 id="filesystem-和-overrides区别"><a href="#filesystem-和-overrides区别" class="headerlink" title="filesystem 和 overrides区别"></a>filesystem 和 overrides区别</h3><p>浏览器请求时总是先对overrides进行查找，然后是服务端，再对filesystem查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;代码在平台运行时会通过backend对外通过调式协议暴露出运行时各种状态，各种调试工具通过解析调试协议实现UI界面（frontend）。ch
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sass-less</title>
    <link href="https://blog.xunserver.cn/archives/a8f35e34.html"/>
    <id>https://blog.xunserver.cn/archives/a8f35e34.html</id>
    <published>2022-08-02T00:58:37.000Z</published>
    <updated>2022-08-02T00:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h2><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>支持webpack导入，如果导入的文件是_开头，则导入内容不会编译，只会引用变量</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>约定$name: value 形式的为变量。支持字符串（带有空格需要引号包裹），数字，数组（逗号或者空格分隔），对象（(key: value, key2: value2)），boolean。</p><p>变量区分为代码块内变量和代码块外变量。默认情况下，后申明的变量会覆盖前置变量（同作用域），通过$var: xxx !default 这种方式可以前置变量覆盖后置。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: green;</span><br><span class="line"><span class="variable">$color</span>: red !default;  <span class="comment">// 不添加!default red 会覆盖前面，添加!default 后面声明的不会覆盖green</span></span><br></pre></td></tr></table></figure></p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>在嵌套中选择父元素，使用后会忽略当前嵌套</p><h3 id="mixin和-include"><a href="#mixin和-include" class="headerlink" title="@mixin和@include"></a>@mixin和@include</h3><p>通过@mixin 定义代码片段，通过@include引入片段实现复用。@mixin相当于代码片段的生成器，支持参数和默认参数。</p><h3 id="extend"><a href="#extend" class="headerlink" title="@extend"></a>@extend</h3><p>如果需要对某个类实现继承，使用@extend .classname 实现，会继承该类所有实现。该功能唯一用处是在该类实现比较多的场景。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.c .a &#123;</span><br><span class="line">    color: xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">    @<span class="keyword">extend</span> .a;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red; </span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.c</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="xxx-插值表达式"><a href="#xxx-插值表达式" class="headerlink" title="#{xxx}插值表达式"></a>#{xxx}插值表达式</h3><p>前面变量都是用在属性值上，#{}可以用在选择器或者属性名上面，实现动态生成类或者属性。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less解析时区大概两个步骤</p><ol><li>按照层级确定变量</li><li>根据变量赋值<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3>@name: value 形式声明变量，变量用在css属性值、属性、类定义包括动态变量中<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@error:</span> red;</span><br><span class="line"><span class="variable">@color:</span> color;</span><br><span class="line"><span class="variable">@red:</span> blue;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@error</span>;  <span class="comment">// 属性值</span></span><br><span class="line">    <span class="selector-tag">background-</span><span class="variable">@&#123;color&#125;</span>: @<span class="variable">@&#123;error&#125;</span>; <span class="comment">// 作为属性时需要@&#123;&#125;包裹，作为动态变量需要@@</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>less支持在块中将属性作为变量名，规则同变量。总是先变量整个快作用域确定变量，然后再赋值。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.success</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">        background-color: $color </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>less 支持lazy load，先使用变量再声明变量，这种特性总是后声明的覆盖前面。</p><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>less编译时会将所有的类视为可混合，mixin特性如下</p><ol><li><p>支持函数、函数重写和具名参数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span>(<span class="variable">@color</span>) &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span>(<span class="variable">@color</span>, <span class="variable">@padding</span>: <span class="number">2px</span>;) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="variable">@padding</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.someError</span> &#123;</span><br><span class="line">    <span class="selector-class">.error</span>(green)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.otherError</span> &#123;</span><br><span class="line">    <span class="selector-class">.error</span>(<span class="variable">@color</span>: yellow); <span class="comment">// 具名参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成以下，会执行所有满足条件的函数</span></span><br><span class="line"><span class="selector-class">.someError</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持嵌套和部分mixin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: green;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-class">.text</span>(),  &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.someError</span> &#123;</span><br><span class="line">    <span class="selector-class">.error</span><span class="selector-class">.text</span>()  <span class="comment">// 不管是.text 前面添加哪种选择器，不考虑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>混合不考虑选择符, 同一个作用域下存在多个相同引用的时不会重复渲染。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> + <span class="selector-class">.b</span> , <span class="selector-class">.a</span> ~ <span class="selector-class">.b</span> ,<span class="selector-class">.a</span><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面3个变量视为一个引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.c</span> &#123;</span><br><span class="line">    <span class="selector-class">.a</span><span class="selector-class">.b</span>()</span><br><span class="line">    <span class="selector-class">.a</span> <span class="selector-class">.b</span> ()</span><br><span class="line">    <span class="selector-class">.a</span> &gt; <span class="selector-class">.b</span> ()</span><br><span class="line">    <span class="comment">// 上面3种方式都会被下面3种方式匹配，因为引用相同的原因只会渲染一次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持变量直接绑定片段或者另一个mixin结果。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@test:</span> .error();</span><br><span class="line"><span class="variable">@test2:</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br><span class="line"></span><br><span class="line">.info &#123;</span><br><span class="line">    <span class="variable">@test</span>();</span><br><span class="line">    <span class="variable">@test1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="amp-父选择器"><a href="#amp-父选择器" class="headerlink" title="&amp;父选择器"></a>&amp;父选择器</h3><p>使用父选择器后会忽略当前默认的嵌套关系。less的父选择器是一个简单替换，比sass功能多。</p><ol><li>反向选择器 .a &amp;。同sass相同</li><li>贴贴选择器 &amp;b =&gt; .ab &amp;&amp; =&gt; .a.a(sass不支持)  .b&amp; =&gt; .b.a(sass不支持这种方式)</li></ol><h3 id="extend继承"><a href="#extend继承" class="headerlink" title=":extend继承"></a>:extend继承</h3><p>.a:extend(.b) 会继承.b less查找器查询到的内容(按照mixin的规则查询)。通过.a:extend(.b all)表现和sass相同</p><ol><li>extend过程在一次编译，所以不能匹配动态变量。<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@variable:</span> .bucket;</span><br><span class="line"><span class="variable">@&#123;variable&#125;</span> &#123; <span class="comment">// interpolated selector</span></span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.some-class</span><span class="selector-pseudo">:extend(.bucket)</span> &#123;&#125; <span class="comment">// does nothing, no match is found</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="函数和编程能力"><a href="#函数和编程能力" class="headerlink" title="函数和编程能力"></a>函数和编程能力</h3><ol><li>if((@text or @test2), trueReturn, falseReturn) </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scss&quot;&gt;&lt;a href=&quot;#scss&quot; class=&quot;headerlink&quot; title=&quot;scss&quot;&gt;&lt;/a&gt;scss&lt;/h2&gt;&lt;h3 id=&quot;import&quot;&gt;&lt;a href=&quot;#import&quot; class=&quot;headerlink&quot; title=&quot;@impo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端大文件上传</title>
    <link href="https://blog.xunserver.cn/archives/cbd08800.html"/>
    <id>https://blog.xunserver.cn/archives/cbd08800.html</id>
    <published>2022-07-29T07:52:50.000Z</published>
    <updated>2022-07-29T07:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近弄公司的大文件上传，实现了分片、暂停、继续、断点续传和秒传，记录一些过程中的细节。</p><h3 id="buffer、blob和arrayBuffer"><a href="#buffer、blob和arrayBuffer" class="headerlink" title="buffer、blob和arrayBuffer"></a>buffer、blob和arrayBuffer</h3><p>所有文件都可以按照二进制解析，js宿主环境提供了对二进制的处理。</p><ul><li>buffer  nodejs提供的二进制缓冲区</li><li>blob和file   浏览器提供的二进制对象，通过操作对象来操作二进制</li><li>arrayBuffer  浏览器提供的一个具有窗口的二进制对象。</li></ul><p>file完全继承了blob所有的特性并添加了部分特性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob()</span><br></pre></td></tr></table></figure></p><p>TODO:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近弄公司的大文件上传，实现了分片、暂停、继续、断点续传和秒传，记录一些过程中的细节。&lt;/p&gt;
&lt;h3 id=&quot;buffer、blob和ar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统样式设计</title>
    <link href="https://blog.xunserver.cn/archives/60273c5f.html"/>
    <id>https://blog.xunserver.cn/archives/60273c5f.html</id>
    <published>2022-07-28T01:15:24.000Z</published>
    <updated>2022-07-28T01:15:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>规范团队项目</title>
    <link href="https://blog.xunserver.cn/archives/95508531.html"/>
    <id>https://blog.xunserver.cn/archives/95508531.html</id>
    <published>2022-07-22T06:48:30.000Z</published>
    <updated>2022-07-22T06:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="几个角度规范项目开发"><a href="#几个角度规范项目开发" class="headerlink" title="几个角度规范项目开发"></a>几个角度规范项目开发</h2><ol><li>eslint 对js、ts以及在vue项目中的js代码进行质量和风格的检查。</li><li>stylelint 对css代码，包括sass，less等代码的风格和质量进行检查。</li><li>prettier 专注于对代码风格的修复，可以结果上面两个插件对代码进行自动修复。</li><li>editorconfig用于编辑器的默认行为，比如新建一个文件、新起一行、一个tab键的默认格式等。</li><li>.gitconfig 用于配置当前项目git的默认行为，比如下载的代码是lf还是crlf（mac和windows同学最对碰到的问题）,如果使用个人电脑，需要不同的项目对应不同user.name 等需要配置。.git/config文件。</li><li>cz工具能够对commit信息进行编辑。</li><li>husky通过对git add、commit和publish过程的介入，对项目本地化规范。</li></ol><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>eslint通过在项目根目录配置eslintrc.*文件。通过parse选项对文件进行分析。eslint 会从当前文件依次向上检查配置文件，直到文件系统根目录或则碰到一个root: true 的配置文件，利用这个可以给mono配置不同的配置检查，配置文件主要包含一下内容</p><ul><li>env 和 globals 针对全局变量中的检查，比如window变量，document变量等，nodejs的__dirname等等。env 相当于globals的合集。</li><li>parse 和 parseOptions 解析器和解析器选项。 默认是esprima,可以配置成@babel/eslint-parser的 ，支持ts @typescript-eslint/parser 和 支持vue的eslint-plugin-vue。</li><li>rule 配置不同归的规则，key、value形式的对象。value 0 1 2 表示禁用，警告和错误。支持数组的形式调用。数组第二项是rule的参数。</li><li>extends，返回一个有config属性的对象。config属性对应的是配置文件，见后文如何提供一个eslint-plugin。extends都是由插件导入。</li><li>plugins 提供rules的解析，和extends的区别是plugin 提供的是rule规则，但是还未配置。所以一般使用plugin后需要配置相应的extend。plugin 还提供了processor 能力。</li><li>processor 是由plugin 提供，能对非js文件中的js片段提取进行eslint检查。一般都是对应Plugin的extend配置提供。</li><li>overrides 可以覆盖默认的配置，会和全局的定义的配置进行合并</li></ul><p>eslint-plugin-vue <a href="https://eslint.vuejs.org/rules/" target="_blank" rel="noopener">https://eslint.vuejs.org/rules/</a></p><p>下面配置vue3 eslint为例</p><blockquote><p>npm i -D eslint-plugin-vue<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">        node: <span class="literal">true</span>,</span><br><span class="line">        browser: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    globals: [</span><br><span class="line">        <span class="string">'__webpack_public__path__'</span>, <span class="comment">// 忽略代码中webpack相关变量</span></span><br><span class="line">    ]</span><br><span class="line">    parse: <span class="string">'vue-eslint-parse'</span>,  <span class="comment">// 解析vue中template</span></span><br><span class="line">    parseOptions: &#123;</span><br><span class="line">        parse: <span class="string">'@typescript-eslint/parse'</span>,</span><br><span class="line">        sourceType: <span class="string">'module'</span></span><br><span class="line">        <span class="comment">// ... 其余@typescript-eslint/parse parseOptions</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="string">'vue'</span>  <span class="comment">// eslint会默认添加eslint-plugin-vue</span></span><br><span class="line">        <span class="string">'@juqery/test'</span>,  <span class="comment">// @juqery/eslint-plugin-test</span></span><br><span class="line">        <span class="string">'@test'</span>  <span class="comment">// @test/eslint-plugin  @开头总是会处理成组织名</span></span><br><span class="line">    ],</span><br><span class="line">    extends: [</span><br><span class="line">        <span class="string">'plugin:vue'</span>  <span class="comment">// 去eslint-plugin-vue 包中导入config对象</span></span><br><span class="line">        <span class="string">'test'</span>,  <span class="comment">// eslint-config-test包中导入   // 默认前缀是eslint-config</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="plugin浅解析"><a href="#plugin浅解析" class="headerlink" title="plugin浅解析"></a>plugin浅解析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包 eslint-plugin-xunserver</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">'xxxx'</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// rule 定义</span></span><br><span class="line">            create() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            meta() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    config: &#123;</span><br><span class="line">        vue3: &#123; <span class="comment">// 使用时先在plugin中添加rule定义  plugins: ['xunserver'], 然后extends: ['eslint-plugin-xunserver/vue3 或者eslint-plugin-xunserver/vue2']</span></span><br><span class="line">            env: &#123;</span><br><span class="line">                node: <span class="literal">true</span>,</span><br><span class="line">                browser: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            extends: [</span><br><span class="line">                <span class="string">'other config'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        vue2: &#123;</span><br><span class="line">            <span class="comment">// 大致同上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    processor: &#123;</span><br><span class="line">        <span class="comment">// processor 对象</span></span><br><span class="line">        <span class="string">'xxx'</span>: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h3><p>stylelint 配置上同eslint类似。从当前文件开始依次向上寻找.stylelintrc.js配置文件，直到找到为止。同eslint区别是默认都是root配置。大致配置如下</p><ul><li>customSynax，定义解析器，比如在vue和html中使用就需要配置，一般和override搭配使用</li><li>extends, 继承其他配置，可以实现插件和customSynax的引入，和eslint有区别，extends大部分时候还用来配置插件。配置在后面的覆盖前面的，extends引入的会被覆盖。</li><li>plugins，通过插件提供新的规则，一般插件只提供了规则，但是未配置，需要extends配置或者自行配置。</li><li>overrides 能针对不能的文件类型使用不同的配置规则。比如stylelint-config-html/vue 实现了vue的特殊处理。</li><li>rules 对不同的规则配置，null表示规则不生效，其余需要参考rule的实现，数组形式如果第二项是对象，则认为是第二参数。通用的参数有disableFix，message两个关注的。一个可以不处理fix，一个可以自定义报错信息。</li><li>ignoreFiles 忽略文件。第三库不使用stylelint</li></ul><h4 id="recss"><a href="#recss" class="headerlink" title="recss"></a>recss</h4><p>Reasonable System css， 通过style-config-recss 实现规范</p><h4 id="less-sass-和-stylus-的解析"><a href="#less-sass-和-stylus-的解析" class="headerlink" title="less sass 和 stylus 的解析"></a>less sass 和 stylus 的解析</h4><p>使用别人配置好的stylelint-config-standard、stylelint-config-standard-xx 实现，其中stylelint-config-standard是在 stylelint-config-recommend 基础上实现。</p><p>如果是自行配置需要，overrides 对应的less、scss和stylus文件，解析器是postcss-less postcss-scss 和 postcss-styl</p><p>vue需要安装postcss-html 和对应的postcss-less postcss-scss 等</p><h4 id="解决prettier冲突"><a href="#解决prettier冲突" class="headerlink" title="解决prettier冲突"></a>解决prettier冲突</h4><p>同理stylelint不解决格式上的问题，需要关闭和prettier冲突的rules。</p><h4 id="实现一个extend"><a href="#实现一个extend" class="headerlink" title="实现一个extend"></a>实现一个extend</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">    extends: [<span class="string">'others extends'</span>],</span><br><span class="line">    overrides: [</span><br><span class="line">        &#123;</span><br><span class="line">            file: [<span class="string">'*.vue'</span>, <span class="string">'**/*.vue'</span>],</span><br><span class="line">            customSynax: <span class="string">'postcss-html'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h3><p>prettier 是一个format工具，eslint和stylelint同时具有lint和format功能，执行顺序是eslint =&gt; prettier 或者stylelint =&gt; prettier。<br>prettier 的配置文件比较简单，一共就10多个选项，使用时指定需要使用的文件即可，prettier在项目中使用意义不大，主要是不能在codeActionSave中使用。目前prettier对css 和 js的格式化都交给对应的格式化工具，不够prettier 对其他语法的格式化还是比较好用，还是建议在编辑保留。<br>prettier还会使用editorconfig中的配置来初始化配置，如果新建文件总是报错飘红，建议检查editorconfig 和 prettier中冲突的部分。</p><h3 id="vscode中引入格式化工具"><a href="#vscode中引入格式化工具" class="headerlink" title="vscode中引入格式化工具"></a>vscode中引入格式化工具</h3><p>vscode 区分为工作区和用户区配置（本地和全局），vscode提供了两种format方式，一种是codeActionOnSave，表示保存时调用格式化工具。另一个是defaultEditor: ‘xxx’, 表示使用快捷键格式化时调用的工具。</p><ul><li>codeActionOnSave和formatOnSave， formateOnSave是defaultEditor在保存时调用的方式，现在基本启用。codeActionOnSave支持多个格式化程序依次调用。vscode插件在初始化时会向vscode注册format功能</li></ul><p>vscode针对不同类型的文件能够采用不同的配置，”[html]”为html类型的文件采用特定的配置。</p><h3 id="vue中template如何格式化"><a href="#vue中template如何格式化" class="headerlink" title="vue中template如何格式化"></a>vue中template如何格式化</h3><p>vue中template中规范prop能够保证良好的编码思路。建议加上vue/attributes-order。</p><h3 id="husky、lint-stage、commitizen和cz-customizable"><a href="#husky、lint-stage、commitizen和cz-customizable" class="headerlink" title="husky、lint-stage、commitizen和cz-customizable"></a>husky、lint-stage、commitizen和cz-customizable</h3><ul><li>husky 用于在git的各种阶段执行脚本，如果脚本返回错误，停止流程。</li><li>list-stage 用于只校验暂存区文件，提高lint速度，在校验文件时，会从文件的当前的目录开始查找最近的配置，在根目录配置baseconfig，子目录继承。</li><li>commitizen是一个检查commit message的工具。支持各种adapter。cz-customizable 是对应的adapter。安装好后使用git-cz代替git commit。该方案不能很好的和vscode结合，不采用。</li><li>commitlint 检查commit msg是否合规，结合husky实现commit信息的校验。</li></ul><h4 id="husky安装配置"><a href="#husky安装配置" class="headerlink" title="husky安装配置"></a>husky安装配置</h4><blockquote><p>pnpm add husky -Dw  // 项目安装在根目录<br>pnpm set-script prepare “husky install”  配置package.json script.prepare 脚本<br>pnpm husky install   // 初始化husky<br>pnpm add ‘./husky/pre-commit’ ‘lint-stage’  // 不同包调用自身的lint-stage 方法<br>pnpm add ‘./husky/pre-push’ ‘pnpm -F “./packages/**” run lint’  // 全局校验</p></blockquote><h4 id="list-stage"><a href="#list-stage" class="headerlink" title="list-stage"></a>list-stage</h4><p>在子项目中单独配置.lintstagedrc.js文件,文件内容如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .lintstagedrc.js</span></span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'../../.lintstagedrc.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...baseConfig,</span><br><span class="line">    <span class="string">'*.&#123;js,jsx,ts,tsx.vue,html&#125;'</span>: [<span class="string">'eslint --config .eslintrc.js'</span>],</span><br><span class="line">    <span class="string">'*.&#123;css,scss,sass,less,styl,vue,html&#125;'</span>: [<span class="string">'stylelint --config .stylelintrc.js'</span>]</span><br><span class="line">    <span class="string">'*.&#123;ts,tsx,js,jsx,json,html,yml,css,less,scss,md,sass&#125;'</span>: [<span class="string">'prettier --write'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h4><blockquote><p>pnpm add commitlint  -Dw<br>pnpm husky add ‘./hasky/commit-msg’ ‘pnpm commitlint –config .commitlintrc.js –edit $1’<br>添加.commitlintrc.js文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * build : 改变了build工具 如 webpack</span></span><br><span class="line"><span class="comment"> * ci : 持续集成新增</span></span><br><span class="line"><span class="comment"> * chore : 构建过程或辅助工具的变动</span></span><br><span class="line"><span class="comment"> * feat : 新功能</span></span><br><span class="line"><span class="comment"> * docs : 文档改变</span></span><br><span class="line"><span class="comment"> * fix : 修复bug</span></span><br><span class="line"><span class="comment"> * perf : 性能优化</span></span><br><span class="line"><span class="comment"> * refactor : 某个已有功能重构</span></span><br><span class="line"><span class="comment"> * revert : 撤销上一次的 commit</span></span><br><span class="line"><span class="comment"> * style : 代码格式改变</span></span><br><span class="line"><span class="comment"> * test : 增加测试</span></span><br><span class="line"><span class="comment"> * anno: 增加注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">'always'</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'build'</span>,</span><br><span class="line">        <span class="string">'ci'</span>,</span><br><span class="line">        <span class="string">'chore'</span>,</span><br><span class="line">        <span class="string">'docs'</span>,</span><br><span class="line">        <span class="string">'feat'</span>,</span><br><span class="line">        <span class="string">'fix'</span>,</span><br><span class="line">        <span class="string">'perf'</span>,</span><br><span class="line">        <span class="string">'refactor'</span>,</span><br><span class="line">        <span class="string">'revert'</span>,</span><br><span class="line">        <span class="string">'style'</span>,</span><br><span class="line">        <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'anno'</span>,</span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="eslintrc-js和eslintignore-文件"><a href="#eslintrc-js和eslintignore-文件" class="headerlink" title="eslintrc.js和eslintignore 文件"></a>eslintrc.js和eslintignore 文件</h3><p>eslint（stylelint）在执行时，按照如下执行。</p><ol><li>确定当前使用的eslint文件位置，确定执行的上下文。</li><li>确定需要处理的全部文件</li><li>根据上下文中中的.eslitingnore、命令中的–no-ignore、–ext 确定需要处理的最终文件合集</li><li>一个一个文件的查找eslintrc配置，找到配置后执行eslint。配置的查找规则从当前需要检查的配置往上级目录查找，知道文件系统的根目录或者碰到一个root:true的配置文件，这种方式相当于变相实现了继承（stylelint在查找到第一个配置文件后停止，意味着需要自行实现继承）。</li></ol><h3 id="vscode中eslint和stylelint"><a href="#vscode中eslint和stylelint" class="headerlink" title="vscode中eslint和stylelint"></a>vscode中eslint和stylelint</h3><p>vscode执行逻辑大致同上，只是确定文件的方式有所不同。</p><ol><li>vscode打开时加载项目根目录下的ignore文件</li><li>根据vscode中的no-ignore 和插件配置的生效文件确定最终文件。</li></ol><h3 id="lint-staged-如何实现只检查部分文件"><a href="#lint-staged-如何实现只检查部分文件" class="headerlink" title="lint-staged 如何实现只检查部分文件"></a>lint-staged 如何实现只检查部分文件</h3><p>eslint，styllint和prettier均支持stdin方式确定输入文件。lint-staged把需要检查的文件和配置一一对比，确定出需要执行命令的文件，添加在命令后。<br>lintstagedrc的查找方式从被检查的文件开始向上查找，lintstagedrc中指令执行的上下和本身相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lintstagedrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"*.(vue,ts,tsx,js,jsx)"</span>: <span class="string">"eslint"</span>   <span class="comment">// 相当于执行在.lintstagedrc.js所在目录下执行eslint xx.js命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="monorepo格式化解决方案"><a href="#monorepo格式化解决方案" class="headerlink" title="monorepo格式化解决方案"></a>monorepo格式化解决方案</h3><p>monorepo仓库有如下难点需要解决。</p><ol><li>不同项目使用不同技术栈，采用的规范不一致。</li><li>CI和lint-staged中的校验是全局的。</li><li>vscode编辑器总是从项目根目录读取工具并加载ignore文件。<br>针对以上问题，解决方案如下</li><li>不同的子项目在编码时，建议到对应的子目录下编写，目的是为了匹配vscode的格式化功能。</li><li>不同子项目在配置时，通通引用公共的配置</li><li>ci和git 校验时采用调用各子项目中的lint工具。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;几个角度规范项目开发&quot;&gt;&lt;a href=&quot;#几个角度规范项目开发&quot; class=&quot;headerlink&quot; title=&quot;几个角度规范项目开发&quot;&gt;&lt;/a&gt;几个角度规范项目开发&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;eslint 对js、ts以及在vue项目中的js代码进行质量和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>browlist</title>
    <link href="https://blog.xunserver.cn/archives/5bc71ff9.html"/>
    <id>https://blog.xunserver.cn/archives/5bc71ff9.html</id>
    <published>2022-07-21T01:39:49.000Z</published>
    <updated>2022-07-21T01:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>配置当前项目面向的平台，可以帮助babel、postcss识别出当前内容中哪些是需要转换</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>支持字符串和对象的配置防范，对于字符串的配置可以使用npx browserlist string 检查字符串配置是否有效。<br>TODO: 字符串配置对象详解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;p&gt;配置当前项目面向的平台，可以帮助babel、postcss识别出当前内容中哪些是需要转换&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>babel</title>
    <link href="https://blog.xunserver.cn/archives/b197ee89.html"/>
    <id>https://blog.xunserver.cn/archives/b197ee89.html</id>
    <published>2022-07-21T00:32:32.000Z</published>
    <updated>2022-07-21T00:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>babel能把es6+转换成es5代码，有两方面转换，一是对语法的转换，比如箭头函数class语法、async语法等。二是对新的api比如数组和字符串上新添加的方法。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>babel是由@babel/core 为主，通过一系列plugin来完成转换。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>babel通过项目根目录下的配置文件处理一般都用babel.config.js 或 .bebelrc，两个区别是js需要按照js文件格式导出，rc文件只用写一个对象即可。</p><h3 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h3><p>一系列已经配置好的插件合集，通过对外暴露options来对内部plugin进行配置。presets的是由后往前解析的，意味申明在后面的preset会先执行，每一个preset其实就是一个返回bable配置对象的函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.myCustomPreset = <span class="function">(<span class="params">presetOptions</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        presets: [<span class="string">"@babel/preset-xxx"</span>],</span><br><span class="line">        plugins: [<span class="string">"@babel/plugin-xx"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>对于同一段代码的解析，由前往后。配置方式和presets一样，plugin总优先于presets中的插件先执行。</p><p>###<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        [<span class="string">'@babel/plugin-runtime-transform'</span>, &#123;</span><br><span class="line">            xx: xx</span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h3><ul><li>targets 直接配置target属性，默认使用项目下browserlist文件（建议使用）</li><li>useBuiltIns: ‘entry’,引入浏览器不支持的全部polyfill，即使未在代码中使用。 ‘usage’，在各个使用的地方应用，可能会存在重复的情况</li><li>corejs: 3</li></ul><h3 id="bebel-preset-env-和-bebel-plugin-transform-runtime"><a href="#bebel-preset-env-和-bebel-plugin-transform-runtime" class="headerlink" title="bebel/preset-env 和 @bebel/plugin-transform-runtime"></a>bebel/preset-env 和 @bebel/plugin-transform-runtime</h3><p>配置targets后，preset-env查询targets所支持的特性，过滤出生效的插件，每个插件在声明时需要指定能够生效的浏览器</p><p>polyfil主要包含3个方面的内容</p><ul><li>corejs，对高级api的支持，比如Object.defineProperty 这一类的api。或者在原型添加某些方法，比如数组新增的那些方法</li><li>各种helper函数，比如箭头函数和class语法，生成各种helper函数。</li><li>regenerator，对async语法糖进行转换</li></ul><p>preset-env对polyfill的处理是，corejs和regenerator全局注入，helper在模块注入（在模块现场申明一个helper，和transform-runtime区别在transform-runtime的helper是由corejs导出的，每个地方都可以复用），这样会污染全局环境。</p><p>@bebel/plugin-transform-runtime 将全局的注入全部改成模块的注入。缺点是不支持target，总是会做polyfill操作。</p><p>得到一个最终的版本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        [<span class="string">'transform-runtime'</span>, &#123;</span><br><span class="line">            corejs: <span class="number">3</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    presets: [</span><br><span class="line">        [<span class="string">'env'</span>, &#123;</span><br><span class="line">            corejs: <span class="number">3</span>,</span><br><span class="line">            useBuiltIns: <span class="string">'usage'</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="执行实现配置文件"><a href="#执行实现配置文件" class="headerlink" title="执行实现配置文件"></a>执行实现配置文件</h3><p>导出配置文件即可，在需要引用的地方extends合并。需要注意的时，preset文件中不能包含extends</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;babel能把es6+转换成es5代码，有两方面转换，一是对语法的转换，比如箭头函数class语法、async语法等。二是对新的api比如数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>esbuild-loader</title>
    <link href="https://blog.xunserver.cn/archives/f6187c2d.html"/>
    <id>https://blog.xunserver.cn/archives/f6187c2d.html</id>
    <published>2022-07-20T07:34:00.000Z</published>
    <updated>2022-07-20T07:34:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最全前端基础设计项目搭建 (一) 项目初始化和脚手架搭建</title>
    <link href="https://blog.xunserver.cn/archives/c5806e5.html"/>
    <id>https://blog.xunserver.cn/archives/c5806e5.html</id>
    <published>2022-07-20T02:51:25.000Z</published>
    <updated>2022-07-20T02:51:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><p>webpack 和 vite 统统都要，主应用采用webpack，部分子应用采用vite<br>ts-lodaer，babel-loader和esbuilder 全部整齐。</p><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><p>qiankun、micro-app和 webpack mf 以及 vite mf。</p><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>ts + sass</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ol><li>所有子应用均支持本地单独部署</li><li>支持CICD，githubpage和gitee自动发布，且能支持自动感知</li><li>http模块需要抽离到公共库，公共库内容支持开发调试。</li><li>monoRepo，pnpm</li><li>有代码守护，支持CDN</li></ol><h3 id="初始化项目目录"><a href="#初始化项目目录" class="headerlink" title="初始化项目目录"></a>初始化项目目录</h3><ol><li>pnpm init 生成package.json</li><li><p>创建packages目录，创建pnpm-workspace.yaml,配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"packages/*"</span></span><br></pre></td></tr></table></figure></li><li><p>在packages中新建各个子应用，package.json中的name作为应用名称</p></li></ol><h3 id="host应用webpack配置"><a href="#host应用webpack配置" class="headerlink" title="host应用webpack配置"></a>host应用webpack配置</h3><h4 id="env-js-和-constant-js-配置"><a href="#env-js-和-constant-js-配置" class="headerlink" title="env.js 和 constant.js 配置"></a>env.js 和 constant.js 配置</h4><p>通过配置dot文件，可以把一些自定义的环境变量注入到打包的流程中，不需要再使用cross-env工具。<br>dotenv包和dotenv-expand， 前者用于读取dot文件中的变量后者用于合并扩展env。<br>dot文件参考vue-cli的实现，命令行 &gt; 系统自带 &gt; .env.[mode].local &gt; .env.[mode] &gt; .env.local &gt; .env<br>webpack.config.js 通过导出函数返回配置可以获取命令行参数，webpack –config webpack.config.js –mode development。通过不同的mode，先初始化环境变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">modulex.exports = <span class="function">(<span class="params">env, arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mode = arg.mode || <span class="string">'production'</span>;</span><br><span class="line">    loadEnv(mode); <span class="comment">// 加载环境变量</span></span><br><span class="line">    <span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">`<span class="subst">$&#123;mode&#125;</span>.config.js`</span>)</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>constant.js 用于定义一些webpack配置中需要的常量。</p><h3 id="webpack-merge处理不同mode的config。"><a href="#webpack-merge处理不同mode的config。" class="headerlink" title="webpack-merge处理不同mode的config。"></a>webpack-merge处理不同mode的config。</h3><p>通过webpack-merge库实现webpack.config.js的合并。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./base.config.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="context、entry和extensions"><a href="#context、entry和extensions" class="headerlink" title="context、entry和extensions"></a>context、entry和extensions</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// context: path.resolve(),  // 绝对路径</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">'./src/index'</span>  <span class="comment">// ./开头</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">'.vue'</span>, <span class="string">'.ts'</span>, <span class="string">'.js'</span>] <span class="comment">// 常用的写在前面 对entry同样生效，因为entry本质是虚拟一个新文件。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>development和production区别不同，development需要方便调试。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// development.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(<span class="string">'dist'</span>),  <span class="comment">// 输出文件目录</span></span><br><span class="line">        filename: <span class="string">'[name].js'</span>  <span class="comment">// 生产环境采用添加chunkhash配置</span></span><br><span class="line">        chunkFilename: <span class="string">'[name].chunk.js'</span>  <span class="comment">// 生产环境 添加 contenthash</span></span><br><span class="line">        clean: <span class="literal">true</span>,  <span class="comment">// 每次build均删除dist</span></span><br><span class="line">        uniqueName: process.env.APP_NAME <span class="comment">// 注意每个应用加载的变量的需要不一样，而且不能被覆盖。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="alias和tsconfig-json中的paths"><a href="#alias和tsconfig-json中的paths" class="headerlink" title="alias和tsconfig.json中的paths"></a>alias和tsconfig.json中的paths</h4><p>使用js文件将tsconfig.json中的compilerOptions.paths和webpack中的别名对应起来，避免重复修改。两处格式不同需要做一些转换。配置tsconfig.js 两个作用。一是对ts-loader、babel-loader(ts)、esbuild-loader生效，这几个loader在处理时会忽略部分配置。二是部分编辑插件会根据配置项处理路径补全，错误提示等信息。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    "target": "esnext",  // ts-loader 编译代码目标，总是设置为esnext，表示ts不处理高级语言，交给babel处理</span><br><span class="line">    "module": "esnext",  // 针对import 语句的处理，esnext 不处理 import 语句等。交给webpack或者rollup处理</span><br><span class="line">    "strict": true,   // 严格模式</span><br><span class="line">    "jsx": "preserve",  // preserve 表示支持jsx但不不处理（交给babel处理），如果设置为none表示不支持jsx。</span><br><span class="line">    "moduleResolution": "node",  // module解决方案</span><br><span class="line">    "skipLibCheck": true,</span><br><span class="line">    "esModuleInterop": true,</span><br><span class="line">    "allowSyntheticDefaultImports": true,</span><br><span class="line">    "forceConsistentCasingInFileNames": true,</span><br><span class="line">    "useDefineForClassFields": true,</span><br><span class="line">    "sourceMap": true,</span><br><span class="line">    "baseUrl": ".", // paths路径补全基于baseUrl</span><br><span class="line">    "types": [</span><br><span class="line">      <span class="string">"webpack-env"</span></span><br><span class="line">    ],</span><br><span class="line">    "paths": &#123;</span><br><span class="line">      "@/*": [</span><br><span class="line">        <span class="string">"src/*"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    "lib": [    // 能够使用的全局变量</span><br><span class="line">      "esnext",</span><br><span class="line">      "dom",</span><br><span class="line">      "dom.iterable",</span><br><span class="line">      <span class="string">"scripthost"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "include": [</span><br><span class="line">    "src/**/*.ts",</span><br><span class="line">    "src/**/*.tsx",</span><br><span class="line">    "src/**/*.vue",</span><br><span class="line">    "tests/**/*.ts",</span><br><span class="line">    <span class="string">"tests/**/*.tsx"</span></span><br><span class="line">  ],</span><br><span class="line">  "exclude": [</span><br><span class="line">    <span class="string">"node_modules"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="devServer配置"><a href="#devServer配置" class="headerlink" title="devServer配置"></a>devServer配置</h3><h3 id="资源配置"><a href="#资源配置" class="headerlink" title="资源配置"></a>资源配置</h3><h4 id="public-和-assets"><a href="#public-和-assets" class="headerlink" title="public 和 assets"></a>public 和 assets</h4><p>public表示需要被直接拷贝到生成目录下的文件夹，代码中引用时通过./public/xx 的方式， assets 是项目中依赖的资源，会经过webpack loader处理。vue会把除了绝对路径的资源都交给webpack处理，导致没办法对public文件使用相对路径。项目规定如下</p><ol><li>public全部使用相对路径，template中通过修改属性值为首字母大写可以跳过vue-compiler处理，style中css-loader 通过options.url.filter 添加自定义函数，less和sass loader 建议不处理资源，都交给css-loader 处理</li><li>assets相对路径和绝对路径均可，建议使用别名。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;h3 id=&quot;打包工具&quot;&gt;&lt;a href=&quot;#打包工具&quot; class=&quot;headerlink&quot; title=&quot;打包工具&quot;&gt;&lt;/a&gt;打包工具&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>npm</title>
    <link href="https://blog.xunserver.cn/archives/a1345b2b.html"/>
    <id>https://blog.xunserver.cn/archives/a1345b2b.html</id>
    <published>2022-07-19T02:26:23.000Z</published>
    <updated>2022-07-19T02:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="npm-下载包流程"><a href="#npm-下载包流程" class="headerlink" title="npm 下载包流程"></a>npm 下载包流程</h3><ol><li>检查项目中是否存在package-lock.json 文件，如果有，比较和package.json和lock.json（一般都不一致），如果版本兼容则使用lock.json 定义的依赖，如果不兼容使用package.json 并更新。 </li><li>检查缓存，无缓存使用,registry中获取包的tgz压缩包，下载(npm-registry-fetch)到本地缓存目录。</li><li>从缓存目录解压到node_modules目录，tgz是一个package目录，解压时未包含package目录</li></ol><h3 id="npm-本地添加离线包"><a href="#npm-本地添加离线包" class="headerlink" title="npm 本地添加离线包"></a>npm 本地添加离线包</h3><p>公司处于内网环境无法下载包，需要自行添加包。</p><ol><li>使用npm-pack-all 制作tgz离线包。</li><li>上传离线包到npm仓库</li><li>网络下载或者使用npm i xxx.tgz安装</li></ol><h3 id="yarn-常用命令"><a href="#yarn-常用命令" class="headerlink" title="yarn 常用命令"></a>yarn 常用命令</h3><p>npm i =&gt; yarn<br>npm i xx  =&gt; yarn add xx -S<br>npm i xx -S =&gt; yarn add xx<br>npm i xx -D =&gt; yarn add xx -D<br>npm i -g xx =&gt; yarn global add xx<br>npm uninstall xx =&gt; yarn remove xx</p><h3 id="mutilRepo-和-monoRepo"><a href="#mutilRepo-和-monoRepo" class="headerlink" title="mutilRepo 和 monoRepo"></a>mutilRepo 和 monoRepo</h3><p>当团队项目变多，而且各个项目存在关联时，就需要采用monoRepo方式管理。传统的muti的lRepo将项目分散到各个仓库。会出现如下痛点</p><ul><li>不能批量操作，操作某个项目需要到相应的目录下操作。项目多起来简直就是地狱</li><li>比如一个组件库升级了版本，需要在组件库修改版本号，发布npm。然后业务库再更新package.json 重新安装依赖。</li><li>组件库如果是break change 的更新，业务库可能会忘记及时更新</li></ul><p>monoRepo出现会解决这些痛点，可以在一个地方对所有仓库进行，仓库相互之间能互相感知。</p><h3 id="npm-痛点"><a href="#npm-痛点" class="headerlink" title="npm 痛点"></a>npm 痛点</h3><p>npm1 npm2项目下根据项目的package.json下载依赖到node_module，如果依赖存在依赖其他的情况会在node_modules/xxx/node_modules, 而且递归下去。 出现问题是大量重复的包被安装，而且文件目录过生对于查找耗时严重。</p><p>npm3 后优化了结构扁平化处理，如果一个依赖没在项目node_modules 出现，依赖的依赖就会安装在项目的node_modules 中，如果两个依赖同时依赖一个版本不一致的库，先安装的依赖在项目下，后安装按照npm1 npm2  处理。这样做也有问题 1.扁平的算法耗时严重。2. 项目未在package.json 中声明的依赖也可以直接引用，会出现不确定性(往往是自动补全代码带来的)。 3. 对于相同依赖的不同版本，完全是按照安装先后顺序来的，会有不确定的情况，这种会对缓存有较大影响（后续的package-lock.json专门解决这个）</p><h3 id="pnpm-解决的痛点"><a href="#pnpm-解决的痛点" class="headerlink" title="pnpm 解决的痛点"></a>pnpm 解决的痛点</h3><p>pnpm通过软链接的方式把扁平的结构放到.pnpm目录中，同时.pnpm 通过npm2 的方式保证了包的正确性，子package中的node_module也是引用的root node_module/.pnpm的包。</p><h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3><h4 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h4><ul><li>pnpm help xxx 查询各cli使用</li><li>pnpm config set xx=xxx –location=project | user | global</li><li>pnpm xxx 自动查询找package中定义的脚本，如果未查询到当做shell命令执行，pnpm pwd  =&gt; /xx/xx/xx</li><li><p>pnpm install，安装整个项目包括子项目的依赖, –frozen-lockfile 保证安装依赖不会更新lockFile。-P 只安装Dependencies依赖， -D 只下载devDependencies依赖。</p></li><li><p>pnpm add xx 安装某个依赖，默认会添加依赖到dependencies， -E 明确版本（必备） -D 保存到devDependencies -P 添加到peerDependencies -O 添加到可选依赖 -W 安装到项目根目录<br>当运行安装依赖时默认会在子集中查找是否有满足条件的包，如果有引用子项目的，通过–workspace 指定包只能在子项目中查找。</p></li><li><p>npm update 更新某个包，也用于更新子项目。</p></li><li><p>pnpm env use 16 -g  代替nvm功能安装包，也支持在项目的npmrc 文件中配置use-node-version=16 保证不同的项目使用不同盖尔nodejs</p></li><li><p>pnpm publish -F @xunserver/test  发布某个子项目，发布项目时，会替换package中workspace协议的依赖。–public=access 发布公共项目 –dry-run 仅执行发布流程但是不发布 –no-git-checks 不检查git –public-branch 设置发布的分支 通过packagejson中的publishConfig字段可以定义在发布时替换相应的package字段</p></li><li><p>pnpm pack  将需要publish的包xxx.gz输出到本地目录</p></li></ul><h4 id="npm-config"><a href="#npm-config" class="headerlink" title="npm_config"></a>npm_config</h4><p>pnpm 复用.npmrc 配置文件，大部分配置都能在cli指定通过选项指定，部分不能指定的配置在.npmrc中key=value，如果需要在cli动态指定参数有两种方案添加npm_config_key=value 的环境变量，二是添加选项–config.key=value<br>常用的npm_config 有如下</p><ul><li>registry=<a href="http://xxxx/" target="_blank" rel="noopener">http://xxxx/</a> 制定依赖安装的仓库，支持@bable:registry=xxx，指定某个包（或者组织）只按照某个仓库安装</li><li><code>&lt;URL&gt;</code>:_authToken   url 是仓库的地址，_authToken 支持从环境变量获得${xxx}</li><li><code>&lt;URL&gt;</code>:tokenHelper  tokenHelper指向一个可以执行的文件，通过文件返回的结果作为token。</li><li>use-node-version=16.1.1 指定项目运行需要的nodejs版本</li><li>node-mirror:<releasedir> 默认值 <a href="https://nodejs.org/download/" target="_blank" rel="noopener">https://nodejs.org/download/</a><releasedir>/  指定pnpm env use 的下载的nodejs目录</releasedir></releasedir></li></ul><h4 id="packageJSON需要关注的字段"><a href="#packageJSON需要关注的字段" class="headerlink" title="packageJSON需要关注的字段"></a>packageJSON需要关注的字段</h4><ul><li><p>engines 指定项目的nodejs版本和pnpm版本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"engines"</span>: &#123;</span><br><span class="line">        <span class="attr">"node"</span>: <span class="string">"&gt;=10"</span>,</span><br><span class="line">        <span class="attr">"pnpm"</span>: <span class="string">"&gt;=3"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>publishConfig 发布时替换packageJSON中字段</p></li></ul><h4 id="pnpm-解决patch问题"><a href="#pnpm-解决patch问题" class="headerlink" title="pnpm 解决patch问题"></a>pnpm 解决patch问题</h4><p>有时候用的第三方依赖有bug，需要我们自行调整，使用package alias简单实现，下载第三方源码（比如xxx1），修改编译发布到自己的仓库（取了了新名字xxx2）。pnpm add xxx1@npm:xxx2 即可把对xxx1的引用全部换成xxx2。</p><h4 id="pnpm-命令补全"><a href="#pnpm-命令补全" class="headerlink" title="pnpm 命令补全"></a>pnpm 命令补全</h4><p>pnpm install-completion</p><h4 id="用好pnpm的关键-–filter-F"><a href="#用好pnpm的关键-–filter-F" class="headerlink" title="用好pnpm的关键  –filter -F"></a>用好pnpm的关键  –filter -F</h4><h4 id="pnpm生产实战"><a href="#pnpm生产实战" class="headerlink" title="pnpm生产实战"></a>pnpm生产实战</h4><p>假设项目中存在packageA和packageB，其中packageA依赖于packageB。面临着如下的问题</p><ol><li>packageA在构建生产环境时，使用本地构建的packageB还是发布到环境的packageB</li><li>如果是CI在构建，是否需要在CI环境上构建packageB</li><li>本地构建开发环境时，如何引入packageB的包，引入的是构建前的包还是构建后的包</li><li>本地开发环境如何对packageB的代码进行调试</li><li>packageA需要依赖packageB的老版本，但是当前项目中packageB是新版本，如何解决。</li><li>如何和webpack的模块联邦结合</li></ol><p>packageJson中依赖通过workspace: x.x.x 指定，如果本地项目中存在对应的版本，会使用对应版本，如果不存在，会使用npm仓库的版本</p><h3 id="n-包管理器是啥"><a href="#n-包管理器是啥" class="headerlink" title="n 包管理器是啥"></a>n 包管理器是啥</h3><p>ni xx -S =&gt; npm i xxx -S<br>nr =&gt; npm run<br>nrm =&gt; npm uninstall<br>nx =&gt; npm execute </p><p>n 会自动检查项目下存在package-lock.json、yarn.lock或者pnpm-lock.yaml 自动选择包管理器安装。</p><h3 id="npmrc、-yarnrc和-pnpmrc"><a href="#npmrc、-yarnrc和-pnpmrc" class="headerlink" title=".npmrc、.yarnrc和.pnpmrc"></a>.npmrc、.yarnrc和.pnpmrc</h3><p>npmrc格式是key=value的形式 value和key有空格需要用””包起来<br>yarnrc格式是key value 的形式，有空格需要用””包裹<br>pnpmrc使用的npmrc配置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;npm-下载包流程&quot;&gt;&lt;a href=&quot;#npm-下载包流程&quot; class=&quot;headerlink&quot; title=&quot;npm 下载包流程&quot;&gt;&lt;/a&gt;npm 下载包流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;检查项目中是否存在package-lock.json 文件，如果有，比较
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css选择器学习</title>
    <link href="https://blog.xunserver.cn/archives/c9ab05c.html"/>
    <id>https://blog.xunserver.cn/archives/c9ab05c.html</id>
    <published>2022-07-04T01:38:09.000Z</published>
    <updated>2022-07-04T01:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><ul><li>0 通配符，部分逻辑组合伪类:not() :where() :is()</li><li>1 标签选择器 </li><li>10 类选择器、属性选择器、伪类</li><li>100 ID选择器</li><li>1000 style属性内联</li><li>10000 !important 选择器。<br>从上面可以看到，无论如何都不能使用!import，!important 只能用于动态重置js设置的代码（js重置js代码，不能在css文件中硬编码）。如果需要提升优先级，可以采用.xxx.xxx.xxx、.xxx[class][class]这两种形式</li></ul><p>不同等级的选择器不能通过数量的堆积来跨越，比如一个ID选择器，即使重复10个class选择器也不能覆盖，正是因为这种无法覆盖的特性，禁止使用ID选择器，一定是禁止。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 优先级 2 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> <span class="selector-class">.text</span> &#123;</span></span><br><span class="line"><span class="undefined">        color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 重复书写 优先级 3*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.text</span><span class="selector-class">.text</span><span class="selector-class">.text</span> &#123; </span></span><br><span class="line"><span class="undefined">        color: blue;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 上面方法或许不优雅 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.text</span><span class="selector-attr">[class]</span><span class="selector-attr">[class]</span>  &#123; </span></span><br><span class="line"><span class="undefined">        color: green;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h3><ol><li>ID选择器</li><li>class</li><li>标签</li><li>通配</li><li>属性</li><li>部分状态伪类</li></ol><p>优先使用class选择器，属性选择器仅特殊使用。  </p><h3 id="css渲染的理解"><a href="#css渲染的理解" class="headerlink" title="css渲染的理解"></a>css渲染的理解</h3><p>css渲染的查找循序是从右往左，css解析时会把树形的css结构变成hash的结构方便快速查找。在渲染某个dom时，先从右往左检查是否命中css选择器。如果命中采用优先级高的，如果未命中检查是否有继承值，如果还没有采用默认值。</p><h3 id="a链接变色怪事"><a href="#a链接变色怪事" class="headerlink" title="a链接变色怪事"></a>a链接变色怪事</h3><p>额外需要记住，伪类的优先级和类选择器相同</p><h3 id="css中大小写问题"><a href="#css中大小写问题" class="headerlink" title="css中大小写问题"></a>css中大小写问题</h3><p>HTML中标签和属性不区分大小写，但是属性区分大小写，所以有如下规则</p><ul><li>标签选择器不区分大小写</li><li>属性选择器前面的属性不区分，后面的属性值区分，可以通过在]前面添加i 表示不区分。 [class=TEXT i]  [ID=TEXT i]。</li><li>class和ID选择器本质上是属性值选择器有区分。</li></ul><h3 id="特殊命名"><a href="#特殊命名" class="headerlink" title="特殊命名"></a>特殊命名</h3><p>可以使用-开头的css命名，可以起到强调作用.-important</p><h3 id="不要出现一下命名"><a href="#不要出现一下命名" class="headerlink" title="不要出现一下命名"></a>不要出现一下命名</h3><p>.box .title .text .header .main .aside .warnning .success .red .green 都加上前缀。</p><h3 id="html标签中获得灵感"><a href="#html标签中获得灵感" class="headerlink" title="html标签中获得灵感"></a>html标签中获得灵感</h3><p>header body aside main nav section content summary detail option img footer a li g(roup) desc x(box)  这几个加上前缀,百试不爽。</p><h3 id="html属性中获取"><a href="#html属性中获取" class="headerlink" title="html属性中获取"></a>html属性中获取</h3><p>radio button checkbox range number email tel color date url time file cell log menu log tab list panel tree row region item </p><h3 id="状态类（禁止在css中声明，只能配合用）"><a href="#状态类（禁止在css中声明，只能配合用）" class="headerlink" title="状态类（禁止在css中声明，只能配合用）"></a>状态类（禁止在css中声明，只能配合用）</h3><p>active invalide disabled selected checked  需要注意的是所有的转态</p><h3 id="css命名最佳实践"><a href="#css命名最佳实践" class="headerlink" title="css命名最佳实践"></a>css命名最佳实践</h3><ul><li>嵌套层级不能过深</li><li>尽量低优先级</li><li>不要div.text 这种意义不大的选择器</li><li>公共结构、公共模块、UI组件、精致布局都不适合面向属性的命名</li><li>细枝末节和特殊场景微调适合面向属性的命名</li><li>状态类不能单独使用</li></ul><h3 id="js中后代选择器逻辑"><a href="#js中后代选择器逻辑" class="headerlink" title="js中后代选择器逻辑"></a>js中后代选择器逻辑</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">ID</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#test"</span>).querySelectorAll(<span class="string">"div div"</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>js中后代选择器是作用域是全局的，针对每一个子节点检查css命中情况。而且是在全局范围内检查。target满足全局范围内的div div所以命中。</p><p>如果需要只在子节点css域检查，需要添加 “:scope div div”</p><h3 id="谨慎使用-gt-子选择器"><a href="#谨慎使用-gt-子选择器" class="headerlink" title="谨慎使用&gt;子选择器"></a>谨慎使用&gt;子选择器</h3><p>会强制绑定DOM结构，违背了分离原则。可以采用具名的后代选择器实现限制选择</p><h3 id="相邻兄弟选择器和兄弟选择器"><a href="#相邻兄弟选择器和兄弟选择器" class="headerlink" title="相邻兄弟选择器和兄弟选择器"></a>相邻兄弟选择器和兄弟选择器</h3><ol><li>会忽略文本节点和注释节点</li><li><p>可以实现:first-child 效果 li+li 和 :not(li+li)  xxx + *。:first-child必要是第一个子节点，+的应用范围大一些。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    li + * &#123;</span></span><br><span class="line"><span class="undefined">        color: red</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- asd --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    123</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配合状态伪类实现css上面的逻辑交付</p></li></ol><h3 id="属于选择符"><a href="#属于选择符" class="headerlink" title="|| 属于选择符"></a>|| 属于选择符</h3><p>用于表格中通过colgroup 设置样式。 .xxx || td 查找td 同时属于.xxx。</p><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><ul><li>不能重复自身(废话)</li><li>可以简单提升优先级比如 <code>html body .text</code>提升了.text。</li><li>组合时必须写在前面input[type=radio]，而且尽量不写。</li></ul><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p>dom中可以存在多个相同的id，id选择器也会正常命中，包括querySelectorAll。还有个历史原因ID属性会被绑定到window同名变量上，多个相同id会绑定成数组。</p><h3 id="属性值选择器"><a href="#属性值选择器" class="headerlink" title="属性值选择器"></a>属性值选择器</h3><p>格式类似[attr=”xxx”]，没得空格可以省略引号。</p><ul><li>[attr=xxx] 完全匹配</li><li>[attr~=”xxx”] 单词匹配  匹配class=”xxx xxx1” 但是不匹配 class=”xxx1xxx”。使用场景是九宫格定位时 class=”center top” class=”left bottom” 这一类场景出现</li><li>[attr=|”xxx”] 开头单词部分(或者全匹配)匹配 匹配 class=”xxx-x xx” 不匹配 class=”xx xxx-x”或则 class=”xxx x”，用于部分前缀匹配。</li><li>[attr^=”xxx”] 前缀匹配，能够包含前一匹配。可以用于判断a链接类型，展示不同图标。</li><li>[attr$=”xxx”] 后缀匹配  可以用于判断文件类型展示不同图标。</li><li>[attr*=”xxx”] 包含匹配  可以匹配当前链接是不是站外地址</li></ul><p>通过动态的添加css可以实现过滤效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">searchValue</span>) =&gt;</span> &#123;</span><br><span class="line">    styleEl.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">        [data-search*="<span class="subst">$&#123;searchValue&#125;</span>"]: &#123;</span></span><br><span class="line"><span class="string">            display: none</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="通过兄弟选择器实现展示隐藏"><a href="#通过兄弟选择器实现展示隐藏" class="headerlink" title="通过兄弟选择器实现展示隐藏"></a>通过兄弟选择器实现展示隐藏</h3><p>通过添加transition保证从a到img中，不会突变显示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.target-button</span><span class="selector-pseudo">:hover</span> ~ <span class="selector-class">.visible-img</span>, <span class="selector-class">.visible-img</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="undefined">        visibility: visible；</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.visible-img</span> &#123;</span></span><br><span class="line"><span class="undefined">        visibility: hidden;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">transition</span>: <span class="selector-tag">visibility</span> <span class="selector-class">.2s</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"target-button"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">href</span>=<span class="string">"xxx"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="通过-focus-伪类实现下拉暂存效果"><a href="#通过-focus-伪类实现下拉暂存效果" class="headerlink" title="通过:focus 伪类实现下拉暂存效果"></a>通过:focus 伪类实现下拉暂存效果</h3><p>通过设置tableIndex实现元素能否被聚焦<br>tabIndex=0 不能被聚焦<br>tabIndex=-1 不能被tab检索，但是能点击触发:focus<br>tabIndex=1 可以被tab检索也能触发:focus </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.target-button</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.visible-img</span> &#123;</span></span><br><span class="line"><span class="undefined">    visibility: visible;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">classk</span>=<span class="string">"target-button"</span> <span class="attr">tabIndex</span>=<span class="string">"-1"</span>&gt;</span>任意元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"visible-img"</span> <span class="attr">href</span>=<span class="string">"xx"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>上面实现在苹果下有问题，需要在最外层添加tabIndex=-1（不能在body上）</p><h3 id="ctive-伪类"><a href="#ctive-伪类" class="headerlink" title=":ctive 伪类"></a>:ctive 伪类</h3><p>匹配任意元素，当鼠标按下时触发，抬起时消失。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">div</span><span class="selector-pseudo">:active</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="undefined">        content: "active伪类";</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    点击我</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以用于埋点数据。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xxx</span><span class="selector-pseudo">:active</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(xxx);</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不使用display-none或者visibility-hidden隐藏内容"><a href="#不使用display-none或者visibility-hidden隐藏内容" class="headerlink" title="不使用display: none或者visibility: hidden隐藏内容"></a>不使用display: none或者visibility: hidden隐藏内容</h3><p>这两种方式会导致键盘检索失效。建议通过下面方法或者opacity:0 来实现<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hidden</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">clip</span>: <span class="built_in">rect</span>(0 0 0 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="focus-within"><a href="#focus-within" class="headerlink" title="focus-within"></a>focus-within</h3><p>子元素触发focus会触发，用于下拉中有操作的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;选择器优先级&quot;&gt;&lt;a href=&quot;#选择器优先级&quot; class=&quot;headerlink&quot; title=&quot;选择器优先级&quot;&gt;&lt;/a&gt;选择器优先级&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;0 通配符，部分逻辑组合伪类:not() :where() :is()&lt;/li&gt;
&lt;li&gt;1 标
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue3进阶</title>
    <link href="https://blog.xunserver.cn/archives/9a707413.html"/>
    <id>https://blog.xunserver.cn/archives/9a707413.html</id>
    <published>2022-06-12T07:37:53.000Z</published>
    <updated>2022-06-12T07:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup 函数只会执行一次，如果是if语句中创建的部分配置，可能无法访问。组合式函数需要同步调用，但是可以使用await语句。setup 单文件下如果语句使用了await 会自动将setup设置为async </p><h3 id="模板中表达式的作用域是ctx，在模板中使用赋值语句如下"><a href="#模板中表达式的作用域是ctx，在模板中使用赋值语句如下" class="headerlink" title="模板中表达式的作用域是ctx，在模板中使用赋值语句如下"></a>模板中表达式的作用域是ctx，在模板中使用赋值语句如下</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increaseCount"</span>&gt;</span>&#123;&#123; (a = count) &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会被转换如下<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toDisplayString <span class="keyword">as</span> _toDisplayString, createElementVNode <span class="keyword">as</span> _createElementVNode, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createElementBlock(<span class="string">"div"</span>, &#123; <span class="keyword">class</span>: <span class="string">"about"</span> &#125;, [</span><br><span class="line">    _createElementVNode(<span class="string">"button"</span>, &#123; onClick: _ctx.increaseCount &#125;, _toDisplayString((_ctx.a = _ctx.count)), <span class="number">9</span> <span class="comment">/* TEXT, PROPS */</span>, [<span class="string">"onClick"</span>]),</span><br><span class="line">    _createElementVNode(<span class="string">"button"</span>, <span class="literal">null</span>, _toDisplayString(_ctx.a), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure></p><h3 id="挂载到this-data上的值全部变成响应式"><a href="#挂载到this-data上的值全部变成响应式" class="headerlink" title="挂载到this data上的值全部变成响应式"></a>挂载到this data上的值全部变成响应式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            value: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="keyword">const</span> test1 = &#123;</span><br><span class="line">            value: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.value = test1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// this.value 已经是一个proxy对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value === test1 )  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="style-支持数组的样式对象，vue会自动补齐前缀"><a href="#style-支持数组的样式对象，vue会自动补齐前缀" class="headerlink" title=":style 支持数组的样式对象，vue会自动补齐前缀"></a>:style 支持数组的样式对象，vue会自动补齐前缀</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleObject1, styleObject2]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ref-和reactive"><a href="#ref-和reactive" class="headerlink" title="ref 和reactive"></a>ref 和reactive</h3><p>ref用于对非引用对象创建响应式<br>reactive 对数组或者对象创建响应式</p><p>对一个响应式对象调用响应式依旧是响应式。。。。。</p><h3 id="对reactive-原对象修改值，不会引起响应式变动，但会影响值。"><a href="#对reactive-原对象修改值，不会引起响应式变动，但会影响值。" class="headerlink" title="对reactive 原对象修改值，不会引起响应式变动，但会影响值。"></a>对reactive 原对象修改值，不会引起响应式变动，但会影响值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reactive(obj); </span><br><span class="line">obj.test = <span class="number">2</span>  <span class="comment">// 不会导致响应式监听</span></span><br><span class="line"></span><br><span class="line">state.test === <span class="number">2</span> <span class="comment">// 但是读取值时会变动，可以用于手动控制视图更新</span></span><br></pre></td></tr></table></figure><h3 id="ref的解包"><a href="#ref的解包" class="headerlink" title="ref的解包"></a>ref的解包</h3><ol><li>声明在顶层作用域的ref在模板中会自动解包，:count=”count” 相当于:count=”count.value” 子组件收到的是原始值， 不是ref对象。 state.count 就不能自动解包， 因为只有state是顶层对象 </li><li> 模板计算值如果是一个ref，会自动解包   不需要使用count.value</li><li>如果一个ref是reactive 对象（不包括数组和其他集合类型set，map）的property， 那么和普通的property表现相同， 会自动解包<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    count</span><br><span class="line">&#125;)</span><br><span class="line">state.count++ <span class="comment">// 不需要使用 state.count.value++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state1 = reactive([count])</span><br><span class="line">state[<span class="number">0</span>].value++   <span class="comment">// 数组需要</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性返回一个ref（将返回值用ref()包装起来， 如果返回的是一个reactive对象，就是ref(reactive(xxxx)), 如果是其他响应式对象，处理方式同上），支持set，get形式。可以用于v-model。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed(&#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> props.modelValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        emits(<span class="string">'update:modelValue'</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="style-和-class-绑定"><a href="#style-和-class-绑定" class="headerlink" title="style 和 class 绑定"></a>style 和 class 绑定</h3><ol><li>内联式<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123;'is-error': isError, active: data.active.value, success: state.success&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isError = ref(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    active: ref(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>对象式和计算属性<br>对象内部通过属性取值获取值（存疑），所以可以传入一个reactive对象。对象的键名作为class名称，属性值表示是否渲染<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"styleObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObject = reactive(&#123;</span><br><span class="line">    active: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'is-error'</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样可以使用计算属性</span></span><br><span class="line"><span class="keyword">const</span> active = ref(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">const</span> styleObject1 = computed(<span class="function"><span class="params">()</span>=&gt;</span> (&#123;</span><br><span class="line">    active: active.value </span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ol start="3"><li><p>数组式<br><code>:class=&quot;[active, isError ? &#39;is-error&#39; : &#39;&#39;]&quot;</code>  可以传入一个空字符串不绑定class，数组每一项计算值直接作为class名称</p></li><li><p>style绑定对象时，对象的键作为属性，对象键值作为属性值。绑定数组时，每一项是一个样式对象。同理也支持字符串（空字符表示不渲染），可以通过alt html属性查看定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"['color: red', '', [&#123;color: 'blue '&#125;]]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  // blue</span><br></pre></td></tr></table></figure></li><li><p>样式绑定是自动添加浏览器前缀</p></li></ol><h3 id="v-if-和-v-for"><a href="#v-if-和-v-for" class="headerlink" title="v-if 和 v-for"></a>v-if 和 v-for</h3><p>vue3 中 同时使用v-if 会先执行，vue2 中 v-for 会先执行，如果同时使用，建议使用计算属性或者将v-for 提升到template上面</p><h3 id="vue3中的v-model"><a href="#vue3中的v-model" class="headerlink" title="vue3中的v-model"></a>vue3中的v-model</h3><p>vue3 中v-model 语法糖有所变化</p><ol><li><p>在原生html 表单控件中, 通过添加.lazy 修饰符可以将input 替换成change事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:value</span>=<span class="string">"xxx"</span> @<span class="attr">input</span>=<span class="string">"event =&gt; xxx = event.target.value"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在组件中使用的是:modelValue 和 @update:modelValue实现，替代了.sync 功能</p></li><li>同时组件中支持v-model:arg1=”xxx” 这种参数。展开来是 :arg1=”xxx” @update:arg1。所以v-model是v-model:modelValue的简写。完全替代了.sync 修饰符</li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li>组合式api的生命周期始终在选项式前面执行</li><li>组合式生命周期少了created和beforeCreate</li><li>setup在beforeCreate 前面执行</li></ol><h3 id="watch-和-watchEffect"><a href="#watch-和-watchEffect" class="headerlink" title="watch 和 watchEffect"></a>watch 和 watchEffect</h3><p>watch 用于副作用操作，支持同步和异步的方式，能对ref、reactive对象（属性变化时监听，浅监听，支持第三个参数设置 { deep: true }）、getter函数（同计算属性），或者数组监听（任何一个变化都触发）。<br>watchEffect 时一种自动监听的方法，会默认执行一次回调函数，收集依赖（同计算属性），同时也支持异步的方式， 不过只会收集前面同步的依赖（比如第一个await 前的属性）。</p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>如果一个getter函数返回的是响应式对象， 默认是浅监听，需要设置deep: true 才能生效。reactive对象直接作为监听项默认是深度监听 ，如果需要浅监听需要使用getter函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = ref(<span class="string">'https://www.xx.com'</span>);</span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;<span class="attr">url</span>: <span class="string">'xxx'</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> state1 = reactive(&#123; <span class="comment">// 作为监听项时， 默认是深层监听，如果只想是浅，用 getter 函数, deep设置为false也无效。</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        url: <span class="string">'xxx'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> data = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> stopRequest =  watch(url, <span class="keyword">async</span> (newValue, oldValue, cleanFn) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> request(newValue);</span><br><span class="line">    data.value = res.data;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 上述监听值还可以为 ()=&gt; url.value 、 [()=&gt;url.value, url]、 () =&gt; state.url  state。</span></span><br></pre></td></tr></table></figure></p><ol><li>watch函数会返回一个stop函数，通过调用stop可以停止监听。</li><li><p>watch回调函数支持第三个参数用于清理之前的正在执行的副作用，比如每次回调时清理前一个未完成的回调。cleanFn(() =&gt; { // 执行清理逻辑， 比如放弃上一次请求， 始终使用最新请求 })，会在每次回调前调用（第一次回调不调用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(count, (_, __, clearFn) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    clearFn(<span class="function"><span class="params">()</span> =&gt;</span> clearTimeout(timer));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>watch函数第三个参数时选项，{deep: boolean, immediate: boolean, flush: boolean}, 其中flush默认时pre 表示在dom更新前调用，post表示更新后（和设置pre然后nexttick()相同）。flush中pre，post都有缓冲队列机制，在同步操作中多次调用会放入到队列中，只会执行一次。这个机制同vue的默认机制。同时可以设置flush: sync 取消缓冲队列, 而且会立刻同步的调用的回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state.data.url = <span class="number">123</span>;   <span class="comment">// 语句后立刻执行一次回调</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"xxx"</span>);   <span class="comment">// 然后打印 xxx</span></span><br><span class="line">state.data.url = <span class="number">1234</span>;  <span class="comment">// 语句又立刻执行一次回调</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果上面是post或者pre 则会打印 xxx 然后只执行一次回调</span></span><br></pre></td></tr></table></figure></li><li><p>watch 同步创建watch监听器会在组件销毁时自动停止， 如果是异步创建的监听器，需要手动设置停止，尽量少创建异步监听器，可以使用判断语句异步转同步。</p></li></ol><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>把一个ref绑定到模板ref属性上，会自动绑定ref，同react。使用起来同ref对象一样，需要通过ref.value 来获取。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="defineProps和defineEmits"><a href="#defineProps和defineEmits" class="headerlink" title="defineProps和defineEmits"></a>defineProps和defineEmits</h3><p>都是sfc setup下面的宏。在sfc编译的时候回解析到相应的位置。</p><h4 id="defineProps-详解"><a href="#defineProps-详解" class="headerlink" title="defineProps 详解"></a>defineProps 详解</h4><ol><li><p>defineProps定义的属性会解析成选项式中props属性。defineProps的返回值解析成对setup(prop)中prop的引用。由于宏原因，defineProps中不能访问setup内部声明的变量，但是可以访问引用进来的。因为引用语句在总是上层</p></li><li><p>props如果接受到undefind值会触发自动default，如果未设置default，值为undefined。Boolean类型会自动转换成对应boolean值</p></li><li><p>props 是一个响应式对象，需要避免对齐解构，如果需要解构使用toRefs 或者toRef(props, xxx)，但是在defineProps 解构是安全的，因为vue编译器会忽略这个解构</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = definedProps(&#123;</span><br><span class="line">count: number,</span><br><span class="line">info: <span class="literal">null</span>,  <span class="comment">// 或者undefined，设置这两个值时会跳过类型检查</span></span><br><span class="line">data: &#123;</span><br><span class="line">type: <span class="built_in">String</span> <span class="comment">// 支持对象式的配置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会转换成</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">props: &#123;</span><br><span class="line">count: number,</span><br><span class="line">info: <span class="literal">null</span>,  <span class="comment">// 或者undefined，设置这两个值时会跳过类型检查</span></span><br><span class="line">data: &#123;</span><br><span class="line">type: <span class="built_in">String</span> <span class="comment">// 支持对象式的配置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">setup(_props) &#123;</span><br><span class="line"><span class="keyword">const</span> props =_ props;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>&lt;CustomComp count /&gt;</code> 实际是<code>&lt;CustomComp count=&#39;&#39; /&gt;</code>的缩写，所以除了boolean类型总是会得到一个空字符串,boolean 类型在收到一个’’或者undefined时会触发default</p></li><li><p>模板中可以自动使用prop属性，比如上面的count, 可以直接，实际上也是宏的作用，在解析模板时，如果是变量是setup定义的，会使用ctx.count, 如果是宏定义的会使用宏的props.count, 如果都没定义使用ctx.count</p></li></ol><h4 id="defineEmits"><a href="#defineEmits" class="headerlink" title="defineEmits"></a>defineEmits</h4><p>同defineProps一样会到解析到{emits: [] }中，支持对象语法实现拦截器或者hook，可以在每次触发的通过返回boolean进行校验。但是不支持混合书写。defineEmits返回的结果是setup(props, {emit: customEmit})中emit的别名，在模板中如果直接使用$emit,使用的是ctx.$emit。也可以把emit暴露到模板中直接使用customEmit(‘xxxx’)；</p><p>组件内部实现了事件机制，对组件v-on或者onXxx的prop 会添加订阅，通过emit或者once(vue3 没得once)触发订阅。vue3不能取消订阅，可以通过触发拦截器实现。事件在beforeCreate前初始化，所谓在生命周期任何适合都可以用，可以通过@hook:created 实现对声明周期的监听</p><h3 id="透传attribute"><a href="#透传attribute" class="headerlink" title="透传attribute"></a>透传attribute</h3><p>任何未在组件porps或者emit 声明的都是attribute，默认情况下attribute会绑定到组件根元素上，如果根元素不存在需要手动绑定$attr到制定元素，可以添加inheritAttrs: false 选项取消默认绑定。$attrs对象包含了所有的未声明$attrs, 会将v-on转换成onXxx形式的prop值传入（所以v-on 也可以用v-bind来实现）。通过这个机制可以实现事件的分发，比如可以把某个事件分布到多个子组件上，或则批量的设置样式。</p><h3 id="关于事件的思考"><a href="#关于事件的思考" class="headerlink" title="关于事件的思考"></a>关于事件的思考</h3><p>对于组件v-bind:onXxx和直接v-on:xxx 相同(:onAdd = @add)， 针对原生元素@click 相当于v-bind:onClick。<br>针对以上特性所以在透传attrbute时，可以直接用v-bind 绑定事件,因为事件在处理成onXxx的prop属性值<br>这个特性可以用h函数解释，h函数的第二参数，以on开头的事件会被处理成事件</p><p>vue2 特性待研究</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>直接第三个参数设置为对象传入，每个键是slot name，值是一个函数包括子组件传递的作用域。同理支持动态的slot name。指定插槽选项式使用的是this.$slot,setup() 函数用二参数中的slot属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h(CustomComponent, &#123;</span><br><span class="line">    onClick: <span class="function"><span class="params">()</span> =&gt;</span> state.count++;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="function">(<span class="params">user</span>) =&gt;</span> h(<span class="string">'span'</span>, [user.name, user.code]) <span class="comment">// &lt;CustomComponent&gt;&lt;template #default="user"&gt;&#123;&#123;user.name&#125;&#125;&#123;&#123;user.code&#125;&#125;&lt;/template&gt;&lt;/CustomComponent&gt;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>插槽的函数如下，每一个slot都是一个函数，通过传递函数参数实现作用域插槽<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ComponentPublicInstance &#123;</span><br><span class="line">  $slots: &#123; [name: <span class="built_in">string</span>]: Slot &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slot = <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> VNode[]</span><br></pre></td></tr></table></figure></p><p>因为render函数中，插槽是在子组件中调用的。所以子组件可以控制插槽延迟渲染，可以实现一个组件版本的v-if。这样可以升级权限指令为权限组件，实现更高级的功能。</p><p>插槽的生命周期如下，parent init -&gt; parent beforeMounte -&gt; child init -&gt; child beforeMounte -&gt; child mounted -&gt; parent mounted </p><h3 id="provide-和-inject"><a href="#provide-和-inject" class="headerlink" title="provide 和 inject"></a>provide 和 inject</h3><p>在vue3 provide 和 inject 的功能可以通过第三方store覆盖比如声明一个store 文件，里面简单的存放响应式对象即可实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">provide(<span class="string">'count'</span>, count)  <span class="comment">// 提供</span></span><br><span class="line"></span><br><span class="line">inject(<span class="string">'count'</span>, ref(<span class="number">2</span>))  <span class="comment">// 注入</span></span><br></pre></td></tr></table></figure></p><p>实际可以用一个store.js实现, 然后在provide和inject的地方引入这个变量进行操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><h3 id="组合式函数"><a href="#组合式函数" class="headerlink" title="组合式函数"></a>组合式函数</h3><ul><li>组合式函数需要同步调用，因为需要感知当前的组件的实例，也可以在await 后调用(仅局限于sfc 的setup)，编译器会自动添加保存await前的实例。组合函数是逻辑复用的银弹，但不是唯一银弹，无渲染组件可以解决组件复用和逻辑复用。</li><li>组合式函数仅会调用一次，如果是有副作用的操作，可以使用watch、effect等操作。</li><li>约定组合式函数使用use命名开头</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useEventListener = <span class="function">(<span class="params">target, name, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// 可以感知当前绑定组件的实例</span></span><br><span class="line">    target.addEventListener(name, callback);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    target.removeEventListener(name, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useMouse = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> x = ref(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> y = ref(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEventListener(<span class="built_in">document</span>, <span class="string">"mousemove"</span>, (event) =&gt; &#123;</span><br><span class="line">    x.value = event.pageX;</span><br><span class="line">    y.value = event.pageY;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x,</span><br><span class="line">    y,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>不建议在自定义组件上使用自定义指令，组件会透传指令。</li><li>自定义组件还是有多个根元素，指令无法正确识别而且$attrs 也无法识别</li><li>可以看到内置指令和自定义指令是两回事，自定义指令更多的是对dom操作。通过生成的vnode实现，但是不能改变创建的vnode。</li></ul><h3 id="teleporr"><a href="#teleporr" class="headerlink" title="teleporr"></a>teleporr</h3><p>支持to和disable prop。to变更实际上会导致el的变化，并不会导致重新生命周期。 to支持元素或者选择器</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li>使用params和path不能同时使用，path需要改成name</li><li>redirect 支持函数，参数是to，可以动态的重定向。重定向中相对路径相对于当前路由</li><li>别名是多个path对应一个component, 别名的path也支持相对于当前路由的相对路劲，同时支持params</li><li>支持路由组件传参的方式，将params 变成props，导航时设置props: true 即可。</li></ul><h3 id="渲染函数和jsx"><a href="#渲染函数和jsx" class="headerlink" title="渲染函数和jsx"></a>渲染函数和jsx</h3><ul><li>在setup() 函数或者函数组件中返回vnode，参数都是setup(props, { emits, attrs, expose, slots})</li><li><p>在render函数或者setup返回函数中，参数形式如下render(ctx)，其中ctx指的是vue实例, 也就是this。</p></li><li><p>setup暴露的出的属性方法默认不能通过ref查询到，可以通过expose暴露。</p></li></ul><h3 id="插槽-1"><a href="#插槽-1" class="headerlink" title="插槽"></a>插槽</h3><p>slot需要通过slots.xxx() 渲染，而且如果是自定义组件需要通过函数或者对象函数的形式传入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    render(ctx) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ctx === <span class="keyword">this</span>) <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">'span'</span>, <span class="comment">/** 没得选项，第二个参数直接变成slot **/</span>, <span class="number">123</span>) <span class="comment">// 不需要使用插槽</span></span><br><span class="line">        <span class="keyword">return</span> h(CustomComp, () =&gt; <span class="number">123</span>)  <span class="comment">// 传入default插槽 123</span></span><br><span class="line">        <span class="keyword">return</span> h(CustomComp, &#123; <span class="keyword">default</span>() &#123;<span class="keyword">return</span> <span class="number">123</span>&#125;, header() &#123;<span class="keyword">return</span> <span class="string">'header'</span>&#125; &#125;) <span class="comment">// 使用具名插槽，同时也可以给函数传入参数，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsx中可以用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h4><p>withDirectives(vnode, [directives, params, modifier, data])。通过把vnode包装，实现一个有指令的vnode，可以通过resolvedirective找到指令。</p><p>jsx中自定义指令和模板相同，v-model也是相同, 在sfc中需要满足vmDerect</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>使用props传入，变成onXxx形式，如果需要添加修饰符，需要将事件响应函数使用withModifiers(fun, [‘self’])这种形式包裹传入。</p><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>函数组件返回一个vnode。参数同setup相同，需要手动声明函数的props和emits。可以偷懒不声明，到attrs属性中获取，不过就不能获的devtools支持。</p><p>声明方式在函数的的静态属性上， 同选项式api相同</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件是一个具有install属性的对象（或者就是一个install函数），通过app.use 调用。会传入app和options</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>vue3中不能通过vue.prototype.xx 来全局添加属性，需要通过app.config.globalProperties.xxx 来添加全局属性。</p><h3 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h3><h4 id="ref-和-shadowRef"><a href="#ref-和-shadowRef" class="headerlink" title="ref 和 shadowRef"></a>ref 和 shadowRef</h4><p>当ref的参数是一个对象时，参数会被reactive调用，意味着对state.value.count.xxx 进行修改也会触发state.value 的变化，可以通过shadowRef避免这个问题。仅当对state.value进行修改时才触发。</p><h4 id="reactive、shallowReactive"><a href="#reactive、shallowReactive" class="headerlink" title="reactive、shallowReactive"></a>reactive、shallowReactive</h4><p>对第一层reactive创建响应式，reactive对递归的将所有的子属性设置为reactive对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _state = &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">        name: <span class="string">'xxx'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> state = reactive(_state)</span><br><span class="line">isReactive(state.user)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h4 id="readonly和shallowReadonly"><a href="#readonly和shallowReadonly" class="headerlink" title="readonly和shallowReadonly"></a>readonly和shallowReadonly</h4><p>创建一个只读的响应式对象，接受一个对象、响应式对象或者ref。使用场景，在做提供一个原值拷贝。</p><h4 id="CustomRef"><a href="#CustomRef" class="headerlink" title="CustomRef"></a>CustomRef</h4><p>创建一个自定义行为的ref，官方内置两种ref，可以通过CustomRef来实现自定义行为的ref。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounceRef = <span class="function">(<span class="params">value, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    CustomRef(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                track()</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>(v) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!timer) &#123;</span><br><span class="line">                    value = v;</span><br><span class="line">                    track();</span><br><span class="line">                    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        timer = <span class="literal">null</span>;</span><br><span class="line">                    &#125;, delay);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="强制触发ref的变化"><a href="#强制触发ref的变化" class="headerlink" title="强制触发ref的变化"></a>强制触发ref的变化</h4><p>对一个shallowRef对象使用triggerRef(ref)可以触发ref所有相关的副作用。不能触发computed<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = shallowRef(<span class="number">0</span>);</span><br><span class="line">watch(count, <span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line">count.value++;</span><br><span class="line"></span><br><span class="line">triggerRef(count) <span class="comment">// 1 --- 2</span></span><br></pre></td></tr></table></figure></p><h3 id="工具api"><a href="#工具api" class="headerlink" title="工具api"></a>工具api</h3><h4 id="toRef、toRefs、unref"><a href="#toRef、toRefs、unref" class="headerlink" title="toRef、toRefs、unref"></a>toRef、toRefs、unref</h4><p>将一个响应式对象(包括readonly)转换成每个子属性都是ref的，对象属性值的变更会导致ref也更新。</p><p>unref将一个值（如果是非ref）转化成ref并返回<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = state.count</span><br><span class="line">state.count++  <span class="comment">// count 不会变化，已经丢失响应式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = toRefs(state)  <span class="comment">// 这样不会丢失响应式，对</span></span><br><span class="line"><span class="keyword">const</span> count = toRef(state, <span class="string">'count'</span>)</span><br><span class="line">isRef(count) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="isRef、isProxy、isReactive、isReadonly"><a href="#isRef、isProxy、isReactive、isReadonly" class="headerlink" title="isRef、isProxy、isReactive、isReadonly"></a>isRef、isProxy、isReactive、isReadonly</h3><p>isProxy检查 reactive、shallowReactive、readonly、shallowReadonly</p><h3 id="toRaw、markRaw"><a href="#toRaw、markRaw" class="headerlink" title="toRaw、markRaw"></a>toRaw、markRaw</h3><p>toRaw 返回一个响应对象的原始对象的引用。markRaw将一个普通对象锁住，使其不能被转换成响应式对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toRaw(reactive(state)) === state) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isReactive(reactive(markRaw(state)))) <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line">state.state = markRaw(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(reactive(state))) <span class="comment">// false 子属性也是能锁住</span></span><br></pre></td></tr></table></figure></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>支持多个组件引用同一个模板<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">src</span>=<span class="string">"./template.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">src</span>=<span class="string">"./style.css"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础教程&quot;&gt;&lt;a href=&quot;#基础教程&quot; class=&quot;headerlink&quot; title=&quot;基础教程&quot;&gt;&lt;/a&gt;基础教程&lt;/h2&gt;&lt;h3 id=&quot;setup&quot;&gt;&lt;a href=&quot;#setup&quot; class=&quot;headerlink&quot; title=&quot;setup&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim</title>
    <link href="https://blog.xunserver.cn/archives/280100fb.html"/>
    <id>https://blog.xunserver.cn/archives/280100fb.html</id>
    <published>2022-04-20T17:56:34.000Z</published>
    <updated>2022-04-20T17:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>w 移动到下个单词开头<br>e 移动到当前单词结尾<br>b 移动到上个单词开头<br>3b 移动3次<br>0 移动到行首<br>ctrl + o 移动到上一个光标<br>ctrl + i 移动到下一个光标<br>G 末尾<br>gg 开头<br>799G 跳转到799行</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>x 删除当前光标内容<br>dw 删除当前光标及后面空格<br>d$ 删除当前光标到行尾<br>de 删除当前光标到单词结尾<br>d% 删除到下一个尾括号<br>3x 删除3个光标<br>3de 执行3次de</p><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>u 撤销操作<br>crtl + R 前进操作</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>输入r 然后输入替换的单词<br>c [number] motion 同删除类似</p><p>:s/aaa/bbb 当前行 替换 aaa成bbb一次<br>:s/aaa/bbb/g 当前行全部替换<br>:1,10s/aaa/bbb/g 1到10行 全部替换<br>:%s/aaa/bbb/gc 全文询问式替换</p><h3 id="删除暂存器"><a href="#删除暂存器" class="headerlink" title="删除暂存器"></a>删除暂存器</h3><p>p将暂存器的内容放置到光标后，如果是行，放置到当前光标下方</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找总是从光标向后，如果需要反向，使用?<br>/xxx 查找xxx<br>输入n 查找下一个，N查找上一个</p><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>i 光标前<br>a 光标后<br>A 插入行末尾<br>R 替换模式<br>o 下一行插入<br>O 上一行插入</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>:set xxx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;移动&quot;&gt;&lt;a href=&quot;#移动&quot; class=&quot;headerlink&quot; title=&quot;移动&quot;&gt;&lt;/a&gt;移动&lt;/h3&gt;&lt;p&gt;w 移动到下个单词开头&lt;br&gt;e 移动到当前单词结尾&lt;br&gt;b 移动到上个单词开头&lt;br&gt;3b 移动3次&lt;br&gt;0 移动到行首&lt;br&gt;ctr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ts-type-practice</title>
    <link href="https://blog.xunserver.cn/archives/e961b2fe.html"/>
    <id>https://blog.xunserver.cn/archives/e961b2fe.html</id>
    <published>2022-04-11T17:27:45.000Z</published>
    <updated>2022-04-11T17:27:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新坑，TS类型编程学习</p><h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><h3 id="any-和-unknown区别"><a href="#any-和-unknown区别" class="headerlink" title="any 和 unknown区别"></a>any 和 unknown区别</h3><p>any可以接受任何值，也可以赋值<br>unknown可以接受任何值，但是不能赋值给any和unknown之外的类型</p><h3 id="keyof-用于把索引类型变成联合类型"><a href="#keyof-用于把索引类型变成联合类型" class="headerlink" title="keyof 用于把索引类型变成联合类型"></a>keyof 用于把索引类型变成联合类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Test = keyof Person <span class="comment">// "name" | "age"</span></span><br><span class="line"><span class="keyword">type</span> Test1 = <span class="string">"name"</span> <span class="keyword">extends</span> keyof Person ? <span class="literal">true</span> : <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> a: Test = <span class="string">"name"</span></span><br></pre></td></tr></table></figure><h3 id="extends-详解"><a href="#extends-详解" class="headerlink" title="extends 详解"></a>extends 详解</h3><p>满足下面条件，判断为true</p><ol><li>两边类型都是常量时，常量需要相同</li><li>两边都是基础类型时，类型需要相同</li><li>索引类型，需要操作符左边包含操作符右边</li><li>联合类型，满足其中一个即可。</li><li>交叉类型需要全部满足<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Pig &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">'pig'</span>,</span><br><span class="line">    weight: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = Pig <span class="keyword">extends</span> Animal ? <span class="literal">true</span> : <span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="联合类型和交叉类型"><a href="#联合类型和交叉类型" class="headerlink" title="联合类型和交叉类型"></a>联合类型和交叉类型</h3><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><ol><li>针对基础类型时，表示的是几个类型任意一个。</li><li>联合类型只能调用共同方法</li></ol><h4 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h4><ol><li><p>针对基础类型和常量类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp; <span class="built_in">boolean</span> <span class="comment">// never</span></span><br><span class="line"><span class="built_in">string</span> &amp; <span class="built_in">string</span> <span class="comment">// string</span></span><br><span class="line"><span class="built_in">string</span> &amp; (<span class="built_in">string</span> | <span class="built_in">boolean</span>) <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li><li><p>针对索引类型, 表示的索引合集，需要同时满足所有。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = A &amp; B; <span class="comment">// A需要同时具有name 和 age属性</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="IsEqual"><a href="#IsEqual" class="headerlink" title="IsEqual"></a>IsEqual</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单版本</span></span><br><span class="line"><span class="keyword">type</span> IsEqual1&lt;A, B&gt; = A <span class="keyword">extends</span> B ? B <span class="keyword">extends</span> A ? <span class="literal">true</span> : <span class="literal">false</span> : <span class="literal">false</span> </span><br><span class="line"><span class="keyword">type</span> Test = IsEqual1&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> Test1 = IsEqual1&lt;<span class="built_in">string</span>, <span class="string">'1'</span>&gt;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> Test2 = IsEqual1&lt;<span class="built_in">string</span>, <span class="built_in">string</span> | <span class="built_in">boolean</span>&gt; <span class="comment">// boolean !!! 失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级版本</span></span><br><span class="line"><span class="keyword">type</span> IsEqual12&lt;A, B&gt; = [A] <span class="keyword">extends</span> [B] ? [B] <span class="keyword">extends</span> [A] ? <span class="literal">true</span> : <span class="literal">false</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> Test3 = IsEqual12&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> Test4 = IsEqual12&lt;<span class="built_in">string</span>, <span class="string">'1'</span>&gt;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> Test5 = IsEqual12&lt;<span class="built_in">string</span>, <span class="built_in">string</span> | <span class="built_in">boolean</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> Test6 = IsEqual12&lt;&#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">   readonly name: <span class="built_in">string</span>,</span><br><span class="line">&#125;&gt;  <span class="comment">// true  !!!!! 失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版本</span></span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;A, B&gt; = <span class="function">(<span class="params">&lt;T&gt;(<span class="params"></span>) =&gt; T <span class="keyword">extends</span> A ? 1 : 2 </span>) <span class="params">extends</span> (<span class="params">&lt;T&gt;(<span class="params"></span>) =&gt; T <span class="keyword">extends</span> B ? 1 : 2</span>) ? <span class="params">true</span> : <span class="params">false</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">Test7</span> = <span class="params">IsEqual</span>&lt;&#123;</span></span><br><span class="line"><span class="function">    <span class="params">name</span>: <span class="params">string</span></span></span><br><span class="line"><span class="function">&#125;, &#123;</span></span><br><span class="line"><span class="function">   <span class="params">readonly</span> <span class="params">name</span>: <span class="params">string</span>,</span></span><br><span class="line"><span class="function">&#125;&gt;  // <span class="params">false</span></span></span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="提取元组的第一个数组类型"><a href="#提取元组的第一个数组类型" class="headerlink" title="提取元组的第一个数组类型"></a>提取元组的第一个数组类型</h3><p><a href="GetCupleFirstType">在线查看</a><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetCupleFirstType&lt;T <span class="keyword">extends</span> unknown[]&gt; = T <span class="keyword">extends</span> [infer FirstType, ...unknown[]] ? FirstType : never;</span><br><span class="line"><span class="keyword">type</span> Test = GetCupleFirstType&lt;[<span class="built_in">string</span>, <span class="built_in">number</span>, symbol]&gt;  <span class="comment">// Test = string</span></span><br></pre></td></tr></table></figure></p><h3 id="提取元组的最后一个类型"><a href="#提取元组的最后一个类型" class="headerlink" title="提取元组的最后一个类型"></a>提取元组的最后一个类型</h3><p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwBkCGBnYBhArmANhAKuBADz5QQAewEAdgCYpSY0DWNA9gO40DaAugD4oAXihlK1eox4A6OczZdefADRQAljQBmEAE5RkaPlAD8B1MCgAuKDQgA3PQChQkMRDQjY8Qxmx5CSGIeNF1NAHM1GkwAWwAjPTUUEHj2HEEoKAB6LPdPUWTUnCA" target="_blank" rel="noopener">在线查看</a><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetLastCupleType&lt;T <span class="keyword">extends</span> unknown[]&gt; = T <span class="keyword">extends</span> [...unknown[], infer Last] ? Last : never</span><br><span class="line"><span class="keyword">type</span> Test = GetLastCupleType&lt;[<span class="built_in">string</span>, <span class="built_in">number</span>, symbol]&gt;  <span class="comment">// Test = symbol</span></span><br></pre></td></tr></table></figure></p><h3 id="数组Pop"><a href="#数组Pop" class="headerlink" title="数组Pop"></a>数组Pop</h3><p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBACg9mAPAFShAHsCA7AJgZygFdsBrbOAd2wG0BdAPigF4pUMs9CaA6PgS2wAzCACcoAJQj5gAGmJkK1OlAD8k6cCgAuKNggA3MQG4AUKEhtNLWAkQ0ZowQHN5AIzhwANhACG2eXwQAFsPL0YoKAB6KKgHYCdsVygPbz9sOiA" target="_blank" rel="noopener">在线查看</a><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> unknown[]&gt; = T <span class="keyword">extends</span> [...infer Rest, unknown] ? Rest : never;</span><br><span class="line"><span class="keyword">type</span> Test = Pop&lt;[<span class="built_in">string</span>, <span class="built_in">boolean</span>, symbol]&gt;  <span class="comment">// [string, boolean]</span></span><br></pre></td></tr></table></figure></p><h3 id="数组Push"><a href="#数组Push" class="headerlink" title="数组Push"></a>数组Push</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> unknown[], S&gt; = [...T, S]</span><br><span class="line"><span class="keyword">type</span> Test = Push&lt;[<span class="built_in">boolean</span>], <span class="built_in">string</span>&gt; <span class="comment">// [boolean, string]</span></span><br></pre></td></tr></table></figure><h3 id="数组Shift"><a href="#数组Shift" class="headerlink" title="数组Shift"></a>数组Shift</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shift&lt;T <span class="keyword">extends</span> unknown[]&gt; = T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Rest] ? Rest : never</span><br><span class="line"><span class="keyword">type</span> Test = Shift&lt;[unknown, <span class="built_in">boolean</span>, <span class="string">'1'</span>]&gt;  <span class="comment">// [boolean, '1']</span></span><br></pre></td></tr></table></figure><h3 id="数组Unshift"><a href="#数组Unshift" class="headerlink" title="数组Unshift"></a>数组Unshift</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Unshift&lt;T <span class="keyword">extends</span> unknown[], S&gt; = [S, ...T]</span><br><span class="line"><span class="keyword">type</span> Test = Unshift&lt;[<span class="built_in">boolean</span>], <span class="built_in">string</span>&gt; <span class="comment">// [string, boolean]</span></span><br></pre></td></tr></table></figure><h3 id="数组concat"><a href="#数组concat" class="headerlink" title="数组concat"></a>数组concat</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> unknown[], S <span class="keyword">extends</span> unknown[]&gt; = [...T, ...S]</span><br><span class="line"><span class="keyword">type</span> Test = Concat&lt;[<span class="built_in">boolean</span>, <span class="built_in">string</span>], [<span class="string">'1'</span>, <span class="string">'2'</span>]&gt; <span class="comment">// [boolean, string, '1', '2']</span></span><br></pre></td></tr></table></figure><h3 id="数组zip"><a href="#数组zip" class="headerlink" title="数组zip"></a>数组zip</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Zip&lt;One <span class="keyword">extends</span> [unknown, unknown], Other <span class="keyword">extends</span> [unknown, unknown]&gt; = One <span class="keyword">extends</span> [infer OneFirst, infer OneAnother] ? Other <span class="keyword">extends</span> [infer OtherFirst, infer OtherAnother] ? [[OneFirst, OtherFirst], [OneAnother, OtherAnother]]: [] : []</span><br><span class="line"><span class="keyword">type</span> Test = Zip&lt;[<span class="string">'1'</span>, <span class="string">'2'</span>], [<span class="string">'3'</span>, <span class="string">'4'</span>]&gt;  <span class="comment">// [['1', '3'], ['2', '4']]</span></span><br></pre></td></tr></table></figure><h3 id="任意长度数组合并-zip2"><a href="#任意长度数组合并-zip2" class="headerlink" title="任意长度数组合并 zip2"></a>任意长度数组合并 zip2</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Zip2&lt;One <span class="keyword">extends</span> unknown[], Second <span class="keyword">extends</span> unknown[]&gt; = One <span class="keyword">extends</span> [infer OneFirst, ...infer OneRest] ? Second <span class="keyword">extends</span> [infer SecondFirst, ...infer SecondRest] ? [[OneFirst, SecondFirst], ...Zip2&lt;OneRest, SecondRest&gt;] : [[OneFirst], ...Zip2&lt;OneRest, []&gt;] : Second <span class="keyword">extends</span> [infer SecondFirst, ...infer SecondRest] ? [SecondFirst, ...Zip2&lt;SecondRest, []&gt;] : []</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = Zip2&lt;[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"4"</span>], [<span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span> ,<span class="string">"1"</span>]&gt;</span><br></pre></td></tr></table></figure><h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReverseHelper&lt;T <span class="keyword">extends</span> unknown[], R <span class="keyword">extends</span> unknown[] = []&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest] ? ReverseHelper&lt;Rest, [First, ...R]&gt; : R</span><br><span class="line"><span class="keyword">type</span> Reverse&lt;T <span class="keyword">extends</span> unknown[]&gt; = ReverseHelper&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = Reverse&lt;[<span class="string">'1'</span>]&gt;</span><br></pre></td></tr></table></figure><h3 id="数组flat"><a href="#数组flat" class="headerlink" title="数组flat"></a>数组flat</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArrayFlat&lt;T, R <span class="keyword">extends</span> unknown[] = []&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest] ?  ArrayFlat&lt;Rest, [...R, ...ArrayFlat&lt;First&gt;]&gt; : [...R, ...(T <span class="keyword">extends</span> unknown[] ? T : [T])]</span><br><span class="line"><span class="keyword">type</span> Test = ArrayFlat&lt;[<span class="number">1</span>| <span class="number">5</span> | <span class="number">2</span>]&gt; <span class="comment">// 为啥是 1 | 5 | 2</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串-startWith"><a href="#字符串-startWith" class="headerlink" title="字符串 startWith"></a>字符串 startWith</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StartWith&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;S&#125;</span><span class="subst">$&#123;string&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span>  <span class="comment">// ts只有字符串，没char，所以用string匹配</span></span><br><span class="line"><span class="keyword">type</span> Test = StartWith&lt;<span class="string">"123"</span>, <span class="string">"1"</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="字符串EndWith"><a href="#字符串EndWith" class="headerlink" title="字符串EndWith"></a>字符串EndWith</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EndWith&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;string&#125;</span><span class="subst">$&#123;T&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> Test = EndWith&lt;<span class="string">"123"</span>, <span class="string">"3"</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> Test1 = EndWith&lt;<span class="string">"123"</span>, <span class="string">"4"</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="字符串首位字符串"><a href="#字符串首位字符串" class="headerlink" title="字符串首位字符串"></a>字符串首位字符串</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetFirstString&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;string&#125;</span>`</span> ? First : never <span class="comment">// infer 定义的变量只能在true里面使用</span></span><br><span class="line"><span class="keyword">type</span> Test = GetFirstString&lt;<span class="string">"123"</span>&gt; <span class="comment">// "1"</span></span><br></pre></td></tr></table></figure><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replace&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">string</span>, R <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Prev&#125;</span><span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;infer After&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Prev&#125;</span><span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;After&#125;</span>`</span> : S</span><br><span class="line"><span class="keyword">type</span> Test = Replace&lt;<span class="string">"123"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&gt; <span class="comment">// "133"</span></span><br><span class="line"><span class="keyword">type</span> Test1 = Replace&lt;<span class="string">"123"</span>, <span class="string">"3"</span>, <span class="string">"2"</span>&gt; <span class="comment">// "133"</span></span><br></pre></td></tr></table></figure><h3 id="创建指定长度的字符串"><a href="#创建指定长度的字符串" class="headerlink" title="创建指定长度的字符串"></a>创建指定长度的字符串</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串Trim"><a href="#字符串Trim" class="headerlink" title="字符串Trim"></a>字符串Trim</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">'\n'</span> | <span class="string">' '</span> | <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span> ? TrimLeft&lt;Rest&gt; : S</span><br><span class="line"><span class="keyword">type</span> TrimRight&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Rest&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span> ? TrimRight&lt;Rest&gt; : S</span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = TrimLeft&lt;TrimRight&lt;S&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = Trim&lt;<span class="string">"  123\n\t"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="首字母转大写"><a href="#首字母转大写" class="headerlink" title="首字母转大写"></a>首字母转大写</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UpcaseFirst&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;First&gt;&#125;</span><span class="subst">$&#123;Rest&#125;</span>`</span> : S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = UpcaseFirst&lt;<span class="string">'ceshi'</span>&gt; <span class="comment">// "Ceshi"</span></span><br></pre></td></tr></table></figure><h3 id="转小驼峰"><a href="#转小驼峰" class="headerlink" title="转小驼峰"></a>转小驼峰</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CamelCase&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Prev&#125;</span>_<span class="subst">$&#123;infer AfterFirst&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Prev&#125;</span><span class="subst">$&#123;Uppercase&lt;AfterFirst&gt;&#125;</span><span class="subst">$&#123;CamelCase&lt;Rest&gt;&#125;</span>`</span> : S</span><br><span class="line"><span class="keyword">type</span> A = CamelCase&lt;<span class="string">'dong_test_liu'</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="删除指定字符串"><a href="#删除指定字符串" class="headerlink" title="删除指定字符串"></a>删除指定字符串</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DropStr&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Prefix&#125;</span><span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;infer Suffix&#125;</span>`</span> ? DropStr&lt;<span class="string">`<span class="subst">$&#123;Prefix&#125;</span><span class="subst">$&#123;Suffix&#125;</span>`</span>, T&gt; : S</span><br><span class="line"><span class="keyword">type</span> Test = DropStr&lt;<span class="string">'123'</span>, <span class="string">'1'</span>&gt; <span class="comment">// '23'</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="获取函数参数类型"><a href="#获取函数参数类型" class="headerlink" title="获取函数参数类型"></a>获取函数参数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetParamsType&lt;F <span class="keyword">extends</span> <span class="built_in">Function</span>&gt; = F <span class="keyword">extends</span> (...args: infer Args) =&gt; <span class="built_in">any</span> ? Args : []</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test= GetParamsType&lt;<span class="function">(<span class="params">a?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>&gt; <span class="comment">// [a?: string]</span></span><br></pre></td></tr></table></figure><h3 id="获取函数返回参数类型"><a href="#获取函数返回参数类型" class="headerlink" title="获取函数返回参数类型"></a>获取函数返回参数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetReturnType&lt;F <span class="keyword">extends</span> <span class="built_in">Function</span>&gt; = F <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; infer Return ? Return : never   <span class="comment">// args中需要设置any，不能是unknow</span></span><br><span class="line"><span class="keyword">type</span> Test = GetReturnType&lt;<span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><h3 id="添加函数参数"><a href="#添加函数参数" class="headerlink" title="添加函数参数"></a>添加函数参数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetParamsType&lt;F <span class="keyword">extends</span> <span class="built_in">Function</span>&gt; = F <span class="keyword">extends</span> (...args: infer Args) =&gt; <span class="built_in">any</span> ? Args : [];</span><br><span class="line"><span class="keyword">type</span> GetReturnType&lt;F <span class="keyword">extends</span> <span class="built_in">Function</span>&gt; = F <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; infer Return ? Return : never;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddFunctionParams&lt;F <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>, T&gt; = <span class="function">(<span class="params">...args: [...GetParamsType&lt;F&gt;, T]</span>) =&gt;</span> GetReturnType&lt;F&gt;;</span><br><span class="line"><span class="keyword">type</span> AddFunctionParams1&lt;F <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>, T&gt; = F <span class="keyword">extends</span> (...args: infer Args) =&gt; infer ReturnType ? <span class="function">(<span class="params">...args: [...Args, T]</span>) =&gt;</span> ReturnType : F</span><br><span class="line"><span class="keyword">type</span> Test = AddFunctionParams1&lt;<span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>, <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="设置函数中this的类型"><a href="#设置函数中this的类型" class="headerlink" title="设置函数中this的类型"></a>设置函数中this的类型</h3><p>通过函数参数中第一个参数this定义类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    say(name: <span class="built_in">string</span>): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SayName &#123;</span><br><span class="line">    (<span class="keyword">this</span>: Person): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: SayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.say(<span class="string">'name is yang'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'yang'</span>,</span><br><span class="line">    say(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">a() <span class="comment">// Error</span></span><br><span class="line">a.call(person)</span><br><span class="line"><span class="keyword">const</span> b = a.bind(person)</span><br><span class="line">b()</span><br></pre></td></tr></table></figure></p><h3 id="获取函数中this指向的类型。"><a href="#获取函数中this指向的类型。" class="headerlink" title="获取函数中this指向的类型。"></a>获取函数中this指向的类型。</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetThisType&lt;T <span class="keyword">extends</span> <span class="built_in">Function</span>&gt; = T <span class="keyword">extends</span> (<span class="keyword">this</span>: infer ThisType, ...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> ? ThisType : never <span class="comment">// 注意，函数参数要用 any[] 接受</span></span><br><span class="line"><span class="keyword">type</span> Test = GetThisType&lt;<span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">string</span>, name: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span>&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><h3 id="构造器和类实例"><a href="#构造器和类实例" class="headerlink" title="构造器和类实例"></a>构造器和类实例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonCtor &#123;</span><br><span class="line">    <span class="keyword">new</span> (name: <span class="built_in">string</span>): Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createPerson: Person = <span class="function"><span class="keyword">function</span>(<span class="params">ctor: PersonCtor</span>)  </span>&#123;</span><br><span class="line">    ctor() <span class="comment">// 禁止 非构造函数调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(<span class="string">'name'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取构造器的实例类型"><a href="#获取构造器的实例类型" class="headerlink" title="获取构造器的实例类型"></a>获取构造器的实例类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取构造函数的函数实列</span></span><br><span class="line"><span class="keyword">type</span> GetInstanceType&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> &gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]) =&gt; infer InstanceType ? InstanceType : unknown </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonCtor &#123;</span><br><span class="line">    <span class="keyword">new</span> (): Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = GetInstanceType&lt;PersonCtor&gt;  <span class="comment">// Person</span></span><br></pre></td></tr></table></figure><h3 id="获取函数构造器参数"><a href="#获取函数构造器参数" class="headerlink" title="获取函数构造器参数"></a>获取函数构造器参数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取构造函数的参数类型</span></span><br><span class="line"><span class="keyword">type</span> GetInstanceType&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> &gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (...args: infer ParamsType) =&gt; <span class="built_in">any</span> ? ParamsType : unknown </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PersonCtor &#123;</span><br><span class="line">    <span class="keyword">new</span> (name: <span class="built_in">boolean</span>): Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = GetInstanceType&lt;PersonCtor&gt;  <span class="comment">// [name: boolean]</span></span><br></pre></td></tr></table></figure><h3 id="获取索引类型中指定值的类型"><a href="#获取索引类型中指定值的类型" class="headerlink" title="获取索引类型中指定值的类型"></a>获取索引类型中指定值的类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">boolean</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetPropNameType&lt;T&gt; = <span class="string">'name'</span> <span class="keyword">extends</span> keyof T ? T <span class="keyword">extends</span> &#123; name: infer NameType &#125; ? NameType : never : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = GetPropNameType&lt;Person&gt; <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure><h3 id="索引类型值修改"><a href="#索引类型值修改" class="headerlink" title="索引类型值修改"></a>索引类型值修改</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChangeValue&lt;T&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof T]: [T[K]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = ChangeValue&lt;Person&gt;</span><br></pre></td></tr></table></figure><h3 id="索引类型索引修改"><a href="#索引类型索引修改" class="headerlink" title="索引类型索引修改"></a>索引类型索引修改</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChangeIndex&lt;T&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> Uppercase&lt;K &amp; <span class="built_in">string</span>&gt;]: [T[K]] <span class="comment">// 只过滤 string类型， 交叉类型在针对普通类型时需要严格相同， 同时never索引默认不会展示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">    <span class="number">1</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = ChangeIndex&lt;Person&gt; <span class="comment">// &#123;NAME: string, age: number&#125;  无 1: number</span></span><br></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyRecord&lt;S <span class="keyword">extends</span>  <span class="built_in">string</span> | <span class="built_in">number</span> | symbol, T&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> S ]: T</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A =  MyRecord&lt;<span class="built_in">string</span> | <span class="number">1</span>, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="取出值为指定类型的索引"><a href="#取出值为指定类型的索引" class="headerlink" title="取出值为指定类型的索引"></a>取出值为指定类型的索引</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mypick&lt;Obj, T&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> Obj[k] <span class="keyword">extends</span> T ? K : never] : Obj[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">    sex: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Test = Mypick&lt;&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    sex: A</span><br><span class="line">&#125;, A | <span class="built_in">string</span>&gt;   <span class="comment">// &#123; name: string; sex: A &#125;</span></span><br></pre></td></tr></table></figure><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadOnly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = MyReadOnly&lt;&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><h3 id="ToPartial-全部可选"><a href="#ToPartial-全部可选" class="headerlink" title="ToPartial 全部可选"></a>ToPartial 全部可选</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToPartial&lt;T&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof T]?: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = ToPartial&lt;&#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><h3 id="去掉readonly"><a href="#去掉readonly" class="headerlink" title="去掉readonly"></a>去掉readonly</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DropReadOnly&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt; = &#123;</span><br><span class="line">    -readonly [K <span class="keyword">in</span> keyof T]: T[K] </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Test = DropReadOnly&lt;&#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><h3 id="去掉可选"><a href="#去掉可选" class="headerlink" title="去掉可选"></a>去掉可选</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DropOptional&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof T]-?: T[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Test = DropOptional&lt;&#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><h3 id="获取指定索引类型的子集"><a href="#获取指定索引类型的子集" class="headerlink" title="获取指定索引类型的子集"></a>获取指定索引类型的子集</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterByIndexType&lt;Obj <span class="keyword">extends</span> <span class="built_in">Object</span>, T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span> | symbol&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> K &amp; T]: Obj[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = FilterByIndexType&lt;&#123;</span><br><span class="line">    [x: symbol]: <span class="built_in">number</span></span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    <span class="number">1</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="number">2</span>: <span class="built_in">number</span></span><br><span class="line">&#125;,  symbol | <span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReverseHelper&lt;T <span class="keyword">extends</span> unknown[], R <span class="keyword">extends</span> unknown[] = []&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest] ? ReverseHelper&lt;Rest, [First, ...R]&gt; : R</span><br><span class="line"><span class="keyword">type</span> Reverse&lt;T <span class="keyword">extends</span> unknown[]&gt; = ReverseHelper&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = Reverse&lt;[<span class="string">'1'</span>]&gt;<span class="keyword">type</span> B = <span class="number">1</span> &amp; (<span class="built_in">number</span> | <span class="built_in">string</span>)</span><br></pre></td></tr></table></figure><h3 id="获取指定指针类型的子集"><a href="#获取指定指针类型的子集" class="headerlink" title="获取指定指针类型的子集"></a>获取指定指针类型的子集</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterValueType&lt;Obj <span class="keyword">extends</span> <span class="built_in">Object</span>, T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span> | symbol&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof Obj <span class="keyword">as</span> Obj[K] <span class="keyword">extends</span> T ? K :never]: Obj[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Test = FilterValueType&lt;&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="递归获取promise返回值类型"><a href="#递归获取promise返回值类型" class="headerlink" title="递归获取promise返回值类型"></a>递归获取promise返回值类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepPromiseTypeHelper&lt;P&gt; = P <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer ValueType&gt; ?  DeepPromiseTypeHelper&lt;ValueType&gt; : P</span><br><span class="line"><span class="keyword">type</span> DeepPromiseType&lt;P <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;unknown&gt;&gt; = DeepPromiseTypeHelper&lt;P&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = DeepPromiseType&lt;<span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><h3 id="是否包含"><a href="#是否包含" class="headerlink" title="是否包含"></a>是否包含</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;A, B&gt; = <span class="function">(<span class="params">&lt;T&gt;(<span class="params"></span>) =&gt; T <span class="keyword">extends</span> A ? 1 : 2 </span>) <span class="params">extends</span> (<span class="params">&lt;T&gt;(<span class="params"></span>) =&gt; T <span class="keyword">extends</span> B ? 1 : 2</span>) ? <span class="params">true</span> : <span class="params">false</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">Include</span>&lt;<span class="params">S</span> <span class="params">extends</span> <span class="params">unknown</span>[], <span class="params">T</span>&gt; = <span class="params">S</span> <span class="params">extends</span> [<span class="params">infer</span> <span class="params">First</span>, ...<span class="params">infer</span> <span class="params">Rest</span>] ? <span class="params">IsEqual</span>&lt;<span class="params">First</span>, <span class="params">T</span>&gt; <span class="params">extends</span> <span class="params">true</span> ? <span class="params">true</span> :  <span class="params">Include</span>&lt;<span class="params">Rest</span>, <span class="params">T</span>&gt; : <span class="params">false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">A</span> = <span class="params">Include</span>&lt;['1' | '2', '2'], '2' | '1'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pick、omit和Exclude"><a href="#pick、omit和Exclude" class="headerlink" title="pick、omit和Exclude"></a>pick、omit和Exclude</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExclude&lt;T <span class="keyword">extends</span> keyof <span class="built_in">any</span>, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> K ? never : T;</span><br><span class="line"><span class="keyword">type</span> test1 = MyExclude&lt;<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, <span class="number">3</span>&gt; <span class="comment">// 1 | 2 利用了分布式条件语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyPick&lt;T <span class="keyword">extends</span> Record&lt;keyof <span class="built_in">any</span>, unknown&gt;, K <span class="keyword">extends</span> keyof T = keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyOmit&lt;T <span class="keyword">extends</span> Record&lt;keyof <span class="built_in">any</span>,unknown&gt;, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = MyPick&lt;T, MyExclude&lt;keyof T, K&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test = MyOmit&lt;&#123;</span><br><span class="line">    age: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">number</span></span><br><span class="line">&#125;, <span class="string">'age'</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="getByPropType、getByPropValue"><a href="#getByPropType、getByPropValue" class="headerlink" title="getByPropType、getByPropValue"></a>getByPropType、getByPropValue</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetPropsByType&lt;T <span class="keyword">extends</span> object, K&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> K ? P : never </span><br><span class="line">&#125;[keyof T]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PickByPropType&lt;T <span class="keyword">extends</span> object, K&gt; = Pick&lt;T, GetPropsByType&lt;T, K&gt;&gt;</span><br><span class="line"><span class="keyword">type</span> OmitByPropType&lt;T <span class="keyword">extends</span> object,K&gt; = Omit&lt;T, GetPropsByType&lt;T, K&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="互斥的联合类型"><a href="#互斥的联合类型" class="headerlink" title="互斥的联合类型"></a>互斥的联合类型</h3><p>因为结构类型的存在,联合类型不能很好的做到互斥（复杂类型），比如下面<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">    age: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">    name: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C = A | B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test: C = &#123;  <span class="comment">// 无法做到只能A或者B</span></span><br><span class="line">    age: <span class="string">'1'</span>;</span><br><span class="line">    name： <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进如下</span></span><br><span class="line"><span class="keyword">type</span> WithOut&lt;T, U&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> Exclude&lt;keyof U, keyof T&gt;]: never; </span><br><span class="line">&#125; &amp;  T</span><br></pre></td></tr></table></figure></p><h3 id="元组和联合类型相互转换"><a href="#元组和联合类型相互转换" class="headerlink" title="元组和联合类型相互转换"></a>元组和联合类型相互转换</h3><p>T[number]</p><h3 id="错题分析"><a href="#错题分析" class="headerlink" title="错题分析"></a>错题分析</h3><h4 id="写一个链式的对象"><a href="#写一个链式的对象" class="headerlink" title="写一个链式的对象"></a>写一个链式的对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断是否是联合类型"><a href="#判断是否是联合类型" class="headerlink" title="判断是否是联合类型"></a>判断是否是联合类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; = [T] <span class="keyword">extends</span> [never] ? <span class="literal">false</span> : ( <span class="comment">// 单独一个never，使用包裹避免分布式条件语句</span></span><br><span class="line">  T <span class="keyword">extends</span> U ? Exclude&lt;U, T&gt; <span class="keyword">extends</span> never ? <span class="literal">false</span> : <span class="literal">true</span> : <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;新坑，TS类型编程学习&lt;/p&gt;
&lt;h2 id=&quot;知识记录&quot;&gt;&lt;a href=&quot;#知识记录&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue查漏补缺（二）双向绑定原理</title>
    <link href="https://blog.xunserver.cn/archives/61b757b4.html"/>
    <id>https://blog.xunserver.cn/archives/61b757b4.html</id>
    <published>2022-03-24T06:05:48.000Z</published>
    <updated>2022-03-24T06:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    cont</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初始化对象&quot;&gt;&lt;a href=&quot;#初始化对象&quot; class=&quot;headerlink&quot; title=&quot;初始化对象&quot;&gt;&lt;/a&gt;初始化对象&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue查漏补缺（一）生命周期</title>
    <link href="https://blog.xunserver.cn/archives/69b5cd9a.html"/>
    <id>https://blog.xunserver.cn/archives/69b5cd9a.html</id>
    <published>2022-03-24T00:03:10.000Z</published>
    <updated>2022-03-24T00:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生命周期解释"><a href="#生命周期解释" class="headerlink" title="生命周期解释"></a>生命周期解释</h3><p>生命周期函数是一个hook，类似于好莱坞的设计模式，hook是同步调用，在Vue执行的各个时间点被调用，能获取到对应时间点VM的状态</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol><li>赋值_self, vm=this</li><li>合并extend和mixin选型</li><li>初始化proxy拦截器</li><li>初始化render生成函数</li><li>初始化组件上的事件监听器</li></ol><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ol><li>injection</li><li>prop</li><li>method</li><li>data</li><li>computed</li><li>watch</li><li>provider<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3></li><li>编辑模板生成render函数</li><li>vm.$el 赋值（但是还未替换dom）<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3></li><li>执行render函数，生成vnode</li><li>挂载vnode到dom中<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生命周期解释&quot;&gt;&lt;a href=&quot;#生命周期解释&quot; class=&quot;headerlink&quot; title=&quot;生命周期解释&quot;&gt;&lt;/a&gt;生命周期解释&lt;/h3&gt;&lt;p&gt;生命周期函数是一个hook，类似于好莱坞的设计模式，hook是同步调用，在Vue执行的各个时间点被调用，能获
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>json-schema-json</title>
    <link href="https://blog.xunserver.cn/archives/e6d11dd8.html"/>
    <id>https://blog.xunserver.cn/archives/e6d11dd8.html</id>
    <published>2022-03-15T06:42:52.000Z</published>
    <updated>2022-03-15T06:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>form表单渲染schemaField</li><li>schemaField中根据type渲染不同Field。</li><li>ObjectFiled，需要渲染容器</li><li>如果是其他类型，渲染由widget包裹的组件</li><li>widget是一个el-form-item</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;form表单渲染schemaField&lt;/li&gt;
&lt;li&gt;schemaField中根据type渲染不同Field。&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http查漏补缺</title>
    <link href="https://blog.xunserver.cn/archives/756fdee8.html"/>
    <id>https://blog.xunserver.cn/archives/756fdee8.html</id>
    <published>2022-03-03T09:43:40.000Z</published>
    <updated>2022-03-03T09:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="https-加密流程"><a href="#https-加密流程" class="headerlink" title="https 加密流程"></a>https 加密流程</h3><ol><li>服务端使用第三方机构（ca）的私钥加密，获得一个公钥证书发给浏览器</li><li>浏览器调用三芳芳机构公钥解密，获得服务端的公钥。浏览器使用服务端公钥生成一个对称密钥，发给服务端</li><li>服务端使用自己的私钥解密，获取到对称的密钥</li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS使用UDP， 递归查询是指域名服务帮忙查询下一级，迭代查询是指客户端自己查询下一级</p><h3 id="常见服务端口"><a href="#常见服务端口" class="headerlink" title="常见服务端口"></a>常见服务端口</h3><p>20 ftp数据口<br>21 ftp控制口<br>22 ssh<br>23 telnet<br>80 http<br>443 https<br>3306 mysql<br>6379 redis   </p><h3 id="localStorage-和-sessionStorage。"><a href="#localStorage-和-sessionStorage。" class="headerlink" title="localStorage 和 sessionStorage。"></a>localStorage 和 sessionStorage。</h3><p>localStorage在存储系统中按照同源策略保存，sessionStorage按照同源同时加上tabId保存，当页面tab被关闭时清空，而不是等到浏览器关闭时清空，而且不同tab页面不共享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;https-加密流程&quot;&gt;&lt;a href=&quot;#https-加密流程&quot; class=&quot;headerlink&quot; title=&quot;https 加密流程&quot;&gt;&lt;/a&gt;https 加密流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;服务端使用第三方机构（ca）的私钥加密，获得一个公钥证书发给浏览
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器解析</title>
    <link href="https://blog.xunserver.cn/archives/50c7c64b.html"/>
    <id>https://blog.xunserver.cn/archives/50c7c64b.html</id>
    <published>2022-03-01T07:35:42.000Z</published>
    <updated>2022-03-01T07:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器渲染进程包含的线程"><a href="#浏览器渲染进程包含的线程" class="headerlink" title="浏览器渲染进程包含的线程"></a>浏览器渲染进程包含的线程</h3><ol><li>GUI 渲染线程，负责解析HTML，CSS，构建DOM、CSSOM和render tree, 布局和绘制。当页面回流时。</li><li>js引擎线程，一个渲染进程只有一个js引擎线程，负责解析执行js代码</li><li>事件线程，当事件触发时，会添加到队尾，等待js引擎执行</li><li>定时器线程，触发后放在队尾</li><li>htto请求线程，请求后放在队尾</li></ol><h3 id="简略版xuanran"><a href="#简略版xuanran" class="headerlink" title="简略版xuanran"></a>简略版xuanran</h3><ol><li>解析html，构建dom树</li><li>解析css,构建css树</li><li>cssom和dom合并成渲染树</li><li>根据渲染树计算节点位置，布局</li><li>调用GUI绘图，上色，合成图层，并渲染到界面上</li></ol><h3 id="html、css和js解析构建顺序"><a href="#html、css和js解析构建顺序" class="headerlink" title="html、css和js解析构建顺序"></a>html、css和js解析构建顺序</h3><ol><li>html解析从上到下解析文档，依次构建DOM</li><li>如果碰到link或者style，异步的进行cssom构建</li><li>如果碰到js脚本，会先等到前面的cssom构建完成，才会解析js脚本（可以先下载）。js脚本解析执行期间，html会停止解析</li><li>初始的html解析完成后，会触发documentContentLoad 事件。此时图片资源可能还未下载完成</li><li>load 事件表示初始html以及资源全部load</li></ol><h3 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h3><p>一个普通的文档流被视为一个图层，包括浮动和非（fixed）定位。对于频繁的渲染需要生成一个新的图层来操作。</p><ol><li>3D转换</li><li>fixed</li><li>动画</li></ol><h3 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h3><p>重绘不涉及布局和几何变化，比如改下颜色。<br>回流是指布局和几何外观的改变，需要渲染整个图层。<br>所有重绘和回流都只争对当前元素</p><h3 id="避免回流"><a href="#避免回流" class="headerlink" title="避免回流"></a>避免回流</h3><ol><li>translate 替换 top</li><li>选择器从右到左，避免dom查找过深</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器渲染进程包含的线程&quot;&gt;&lt;a href=&quot;#浏览器渲染进程包含的线程&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染进程包含的线程&quot;&gt;&lt;/a&gt;浏览器渲染进程包含的线程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;GUI 渲染线程，负责解析HTML，CSS，构建
      
    
    </summary>
    
    
  </entry>
  
</feed>
