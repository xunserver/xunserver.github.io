<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bang</title>
  
  <subtitle>生活总会有惊喜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xunserver.cn/"/>
  <updated>2023-02-16T04:13:56.000Z</updated>
  <id>https://blog.xunserver.cn/</id>
  
  <author>
    <name>yangmanman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js-context and scoped</title>
    <link href="https://blog.xunserver.cn/archives/f112fe7a.html"/>
    <id>https://blog.xunserver.cn/archives/f112fe7a.html</id>
    <published>2023-02-16T04:13:56.000Z</published>
    <updated>2023-02-16T04:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重新理一下js的中执行上下文和作用域的底层逻辑，以及this的中一些误区</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>js引擎在执行代码时会创建三种上下文，全局上下文，函数上下文和eval上下文。上下文以栈的形式保存，最开始，js引擎会创建一个全局上下文，推入栈。当执行到一个函数时，会创建一个函数上下文，入栈,再执行上下文的初始化。函数中又会一层一层的创建上下文，持续的推入栈形成上下文栈，当函数执行完成后，栈会弹出销毁。<br>上下文包含三个要素，变量对象，作用域和this推导。变量对象(VO)，函数中又称为AO，是在函数执行时才激活的对象。函数执行时先分析生成AO，包括形参，函数声明和变量声明（注意有先后顺序），如果变量声明和函数以及形参冲突，则变量声明取消。分析完后进入函数执行过程，这时候又会动态的调整AO。</p><p>函数在创建的时候会将当前的上下文的scoped保存到函数的[[scoped]]对象中，当函数上下文初始时，函数的scoped = object.assign([[scoped]], AO)。这样形成了作用域链。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(d)  <span class="comment">// function</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">23</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(d)  <span class="comment">// 23</span></span><br><span class="line">    <span class="keyword">var</span> e = <span class="string">'e'</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面执行a时的AO 和 作用域</span></span><br><span class="line">functionContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">2</span></span><br><span class="line">            [<span class="number">0</span>]: <span class="number">2</span></span><br><span class="line">            [<span class="number">1</span>]: <span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">        c: <span class="number">5</span>,</span><br><span class="line">        d: <span class="function"><span class="keyword">function</span>,</span></span><br><span class="line"><span class="function">        <span class="title">d</span>: <span class="title">undefined</span> // 变量申明不会覆盖形参和函数申明</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">scoped</span>: </span>&#123;</span><br><span class="line">        ...[[scoped]]</span><br><span class="line">        ...AO,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="this的绑定"><a href="#this的绑定" class="headerlink" title="this的绑定"></a>this的绑定</h3><p>简单理解就是谁调用this指向谁，如果没有调用方，this指向undefined，非严格模式下，undefined就会指向全局， 箭头函数的this在创建时绑定，绑定的是创建时上下文中的this，如果使用了call，apply调用直接指向参数，如果是bind绑定的，this也是在函数创建时绑定。</p><p>初始化上下文时，如果this已经绑定到值，不会执行this的初始化，bind、call、apply也是同理，如果发现函数在初始化阶段已经绑定了this，重新绑定不会生效。</p><p>需要注意的是js中(foo.bar)和(false || foo.bar) 不一致，前者会直接返回foo.bar的引用，后者会返回一个新的值时foo.bar的拷贝<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    bar,</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">foo.bar() <span class="comment">// 1</span></span><br><span class="line">(foo.bar)() <span class="comment">// 1 括号不会影响旧值</span></span><br><span class="line">(<span class="literal">false</span> || foo.bar)() <span class="comment">// 2   // 表达式会返回一个新值</span></span><br><span class="line"><span class="keyword">var</span> c = foo.bar</span><br><span class="line">c() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;重新理一下js的中执行上下文和作用域的底层逻辑，以及this的中一些误区&lt;/p&gt;
&lt;h3 id=&quot;执行上下文&quot;&gt;&lt;a href=&quot;#执行上下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FE-advance</title>
    <link href="https://blog.xunserver.cn/archives/fcb5ead3.html"/>
    <id>https://blog.xunserver.cn/archives/fcb5ead3.html</id>
    <published>2023-02-15T08:45:48.000Z</published>
    <updated>2023-02-15T08:45:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器和网络"><a href="#浏览器和网络" class="headerlink" title="浏览器和网络"></a>浏览器和网络</h3><h4 id="浏览器的进程有哪些，分别作用"><a href="#浏览器的进程有哪些，分别作用" class="headerlink" title="浏览器的进程有哪些，分别作用"></a>浏览器的进程有哪些，分别作用</h4><h4 id="浏览器的线程"><a href="#浏览器的线程" class="headerlink" title="浏览器的线程"></a>浏览器的线程</h4><h4 id="输入一个url，浏览器如何处理解析"><a href="#输入一个url，浏览器如何处理解析" class="headerlink" title="输入一个url，浏览器如何处理解析"></a>输入一个url，浏览器如何处理解析</h4><h4 id="js引擎的执行，如何和各个线程配合"><a href="#js引擎的执行，如何和各个线程配合" class="headerlink" title="js引擎的执行，如何和各个线程配合"></a>js引擎的执行，如何和各个线程配合</h4><h4 id="什么请求会携带cookies"><a href="#什么请求会携带cookies" class="headerlink" title="什么请求会携带cookies"></a>什么请求会携带cookies</h4><p>任何请求都会携带cookies，最终能不能携带cookies还需要多步过滤。</p><h4 id="cookies如何携带，如何设置。"><a href="#cookies如何携带，如何设置。" class="headerlink" title="cookies如何携带，如何设置。"></a>cookies如何携带，如何设置。</h4><p>携带当前请求的父域名和父路径上的cookies，设置域名也是只能设置到当前请求的父域名路径</p><h4 id="跨域场景的cookies是如何设置和携带的"><a href="#跨域场景的cookies是如何设置和携带的" class="headerlink" title="跨域场景的cookies是如何设置和携带的"></a>跨域场景的cookies是如何设置和携带的</h4><p>跨域和携带cookies不冲突，cookies是只看目的不看来源，对于xhr 和 fetch的请求，总是需要手动的设置的是否在请求中包含cookies。对于其他的比如标签，链接或者link等不考虑跨域。</p><h4 id="什么是跨站，samesite是什么"><a href="#什么是跨站，samesite是什么" class="headerlink" title="什么是跨站，samesite是什么"></a>什么是跨站，samesite是什么</h4><p>只有两个请求的顶级有效域名 + 1相同，既是同站。samesite有lax、strict和none。老版本中samesite默认值是none, 意味着cookies的携带不看来源，目前各大浏览器统一设置为 lax, 对于跨站的请求只允许a标签、预加载和get 表单能携带cookies。 </p><h4 id="浏览器的缓存有些那些"><a href="#浏览器的缓存有些那些" class="headerlink" title="浏览器的缓存有些那些"></a>浏览器的缓存有些那些</h4><h4 id="no-store和no-cache"><a href="#no-store和no-cache" class="headerlink" title="no-store和no-cache"></a>no-store和no-cache</h4><h4 id="webpack中的缓存如何配置"><a href="#webpack中的缓存如何配置" class="headerlink" title="webpack中的缓存如何配置"></a>webpack中的缓存如何配置</h4><h4 id="put、post、get区别，浏览器常见的状态码"><a href="#put、post、get区别，浏览器常见的状态码" class="headerlink" title="put、post、get区别，浏览器常见的状态码"></a>put、post、get区别，浏览器常见的状态码</h4><h4 id="跨域的几种方法和原理"><a href="#跨域的几种方法和原理" class="headerlink" title="跨域的几种方法和原理"></a>跨域的几种方法和原理</h4><h4 id="xss和crsf攻击是啥，如何防范"><a href="#xss和crsf攻击是啥，如何防范" class="headerlink" title="xss和crsf攻击是啥，如何防范"></a>xss和crsf攻击是啥，如何防范</h4><h4 id="postmessage如何实现，讲述一下为什么能实现跨域。"><a href="#postmessage如何实现，讲述一下为什么能实现跨域。" class="headerlink" title="postmessage如何实现，讲述一下为什么能实现跨域。"></a>postmessage如何实现，讲述一下为什么能实现跨域。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并获取其他窗口的引用</span></span><br><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'IFRAME'</span>);</span><br><span class="line">insertIframe(iframe);</span><br><span class="line">iframe.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">    iframe.contentWindow.postMessage(<span class="string">"some message"</span>, <span class="string">'/'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// iframe中</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'message'</span>, message =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(message.origin === <span class="string">'https://www.baidu.com'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.parent.postMessage(<span class="string">'iframe message'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所有的跨域都基于信任链，子iframe手动添加了对父origin的信任，父origin也手动添加了对子的信任。</p><p>还有基于window.domain的跨域，在两个页面是同站但是跨域的场景，手动将的两个站点的window.domain 设置为相同即可在两个页面分别直接获取window对象</p><h4 id="access-control-allow流程。"><a href="#access-control-allow流程。" class="headerlink" title="access-control-allow流程。"></a>access-control-allow流程。</h4><ol><li>判断当前请求是简单请求还是复杂请求，如果是简单请求直接请求，后端在响应中携带access-control-allow: * 对应的域，浏览器检查响应中是否有该字段并且能和当前的域匹配，响应才会被正确的解析。如果是复杂请求，浏览器先发送一个option请求， 不携带请求体，询问是否同意跨域，如果同意再发送简单请求。<h4 id="简单请求和复杂请求"><a href="#简单请求和复杂请求" class="headerlink" title="简单请求和复杂请求"></a>简单请求和复杂请求</h4>简单请求需要满足request method: option, get, post ，request header: accept accept-language 。content-language和 content-type 是 x-www-form-urlencode 和 mutilpart/formdata 以及 text/plain，注意不包括我们平常用的json。 其余的都是复杂请求。</li></ol><p>对于所有的跨域，请求中总是会携带当前域的信息通过origin 协议 host 和端口<br>其中简单请求服务端响应的有:<br>access-control-allow-origin: *（表示所有，但是不会携带cookies，即使设置了携带） ，对于开发环境，建议是正向代理总是将Origin，除了浏览器其他平台没有跨域问题<br>access-control-allow-credentials: 下次请求是否允许发送的cookie（要携带cookies， 两个条件缺一不可）</p><p>对于复杂请求，还会添加 max-age: 表示多少时间内不需要再次预请求。 allow-method: 允许的请求的方法  allow-headers: *(除了 authoritie需要手动指定外，如果一定要手动指定，一定记得添加content-type 这样就能允许所有的content-type类型)</p><h4 id="从浏览器上做优化有哪些-seo，多域名，"><a href="#从浏览器上做优化有哪些-seo，多域名，" class="headerlink" title="从浏览器上做优化有哪些(seo，多域名，)"></a>从浏览器上做优化有哪些(seo，多域名，)</h4><h4 id="获取其他页面的window，获取iframe的window，-iframe获取上级windows"><a href="#获取其他页面的window，获取iframe的window，-iframe获取上级windows" class="headerlink" title="获取其他页面的window，获取iframe的window， iframe获取上级windows"></a>获取其他页面的window，获取iframe的window， iframe获取上级windows</h4><h4 id="iframe如何创建最优，iframe对主页面的影响"><a href="#iframe如何创建最优，iframe对主页面的影响" class="headerlink" title="iframe如何创建最优，iframe对主页面的影响"></a>iframe如何创建最优，iframe对主页面的影响</h4><h3 id="css相关"><a href="#css相关" class="headerlink" title="css相关"></a>css相关</h3><h4 id="BFC是啥"><a href="#BFC是啥" class="headerlink" title="BFC是啥"></a>BFC是啥</h4><ol><li>BFC外的浮动元素不会和BFC区域重叠</li><li>BFC高度会计算浮动元素</li><li>BFC不会和另一个BFC出现margin重叠</li><li>BFC中的上下边距会重叠，取最大的那个</li></ol><h4 id="flex各个属性，flex实现居中-如何平分剩余空间等"><a href="#flex各个属性，flex实现居中-如何平分剩余空间等" class="headerlink" title="flex各个属性，flex实现居中, 如何平分剩余空间等"></a>flex各个属性，flex实现居中, 如何平分剩余空间等</h4><h4 id="重绘和回流是什么"><a href="#重绘和回流是什么" class="headerlink" title="重绘和回流是什么"></a>重绘和回流是什么</h4><h4 id="渲染层，合成层和图形层是啥"><a href="#渲染层，合成层和图形层是啥" class="headerlink" title="渲染层，合成层和图形层是啥"></a>渲染层，合成层和图形层是啥</h4><h4 id="animation和transition"><a href="#animation和transition" class="headerlink" title="animation和transition"></a>animation和transition</h4><h4 id="几个像素和viewport的关系"><a href="#几个像素和viewport的关系" class="headerlink" title="几个像素和viewport的关系"></a>几个像素和viewport的关系</h4><p>物理像素，指的是一个设备屏幕有多少个物理点，比如pc是1080 <em> 1920表示横向有1920个像素（系统本身不缩放的情况下）。有些设备屏幕是高清屏，用了多个物理像素来展示一个逻辑像素，称为像素比DPR，设备的DPR是固定的，比如苹果某些是2，有些设备是3。莫、默认情况下1 css px = 1 物理像素 </em> DPR（也就是所谓的设备像素，后文中device-width），但是又出现了缩放的场景， 这个时候 1 css px  = 1 物理像素 <em> DPR </em> 2。</p><p>layoutview， 浏览器默认的窗口的大小，980px（css像素），如果不手动指定视图大小，浏览器会按照这个展示<br>visual view  可视窗口，总是理想窗口 / 缩放<br>ideal view   理想窗口，总是和设备像素相同</p><p>在移动端中，大部分设备的DPR是固定的，设备像素也是固定的。但是在pc端因为2k和4k屏的出现，可以动态的调整DPR值，所以现在pc端也需要注意高清屏的问题</p><p>我们在css中接触的总是css像素。下面举一个例子子来加强理解<br>设置 <strong><meat name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1, minimum-scale=1"></meat></strong><br>如果上面的设备的DPR是2，物理像素是750，设备像素就是375，<br>这个时候1css像素就是 1 物理像素 <em> DPR </em> scale(1)就是1设备像素</p><p>再考虑视图的问题，上面因为同时设置了width 和 scale，按照谁大取谁的方式，刚好device-width 和 initial-scale相同，所以layoutview是375px，如果页面中有元素设置500px，就会出现滚动条。可视区域的大小总是设备像素375px;换算成css就是375</p><p>将scale = 2，这个时候因为width还是375，但是 initial-scale * ideal view = 750 大于375，所以最终的layoutview是750px。可视区域也变成了 375 / 2，所以滚动条会有 1 / 4</p><h4 id="1px-解决"><a href="#1px-解决" class="headerlink" title="1px 解决"></a>1px 解决</h4><p>设计稿是750px, 750px中除了一个1px的，映射到实机就是0.5px，css不支持0.5px设置，有两种推荐的方案，第一个是通过transform: scale()来缩放。第二个是直接不用设备独立像素，把手机的像素扩展到最大，比如750px的设计稿，直接将取消缩放，让界面也是750px宽，在这个基础上再做rem等比的缩放。推荐第二种。</p><h3 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h3><h4 id="执行上下文是啥，三大上下文类型，上下文的三大要素"><a href="#执行上下文是啥，三大上下文类型，上下文的三大要素" class="headerlink" title="执行上下文是啥，三大上下文类型，上下文的三大要素"></a>执行上下文是啥，三大上下文类型，上下文的三大要素</h4><h4 id="词法作用域和语法作用域，为什么js是词法作用域"><a href="#词法作用域和语法作用域，为什么js是词法作用域" class="headerlink" title="词法作用域和语法作用域，为什么js是词法作用域"></a>词法作用域和语法作用域，为什么js是词法作用域</h4><h4 id="this的绑定规则，bind后还能修改this吗（使用call修改）"><a href="#this的绑定规则，bind后还能修改this吗（使用call修改）" class="headerlink" title="this的绑定规则，bind后还能修改this吗（使用call修改）"></a>this的绑定规则，bind后还能修改this吗（使用call修改）</h4><h4 id="箭头函数中的上下文深入理解，实现一个调整箭头函数this绑定的函数"><a href="#箭头函数中的上下文深入理解，实现一个调整箭头函数this绑定的函数" class="headerlink" title="箭头函数中的上下文深入理解，实现一个调整箭头函数this绑定的函数"></a>箭头函数中的上下文深入理解，实现一个调整箭头函数this绑定的函数</h4><h4 id="作用域链是什么"><a href="#作用域链是什么" class="headerlink" title="作用域链是什么"></a>作用域链是什么</h4><h4 id="原型链是什么"><a href="#原型链是什么" class="headerlink" title="原型链是什么"></a>原型链是什么</h4><h4 id="如何实现继承，继承的几种方式对比"><a href="#如何实现继承，继承的几种方式对比" class="headerlink" title="如何实现继承，继承的几种方式对比"></a>如何实现继承，继承的几种方式对比</h4><h4 id="class继承和原型继承的区别"><a href="#class继承和原型继承的区别" class="headerlink" title="class继承和原型继承的区别"></a>class继承和原型继承的区别</h4><h4 id="几个原型相关的对象API"><a href="#几个原型相关的对象API" class="headerlink" title="几个原型相关的对象API"></a>几个原型相关的对象API</h4><h4 id="原型中的属性代理如何实现的"><a href="#原型中的属性代理如何实现的" class="headerlink" title="原型中的属性代理如何实现的"></a>原型中的属性代理如何实现的</h4><h4 id="实现一个instanceof-简单描述typeof-和-Object-prototype-toString-call"><a href="#实现一个instanceof-简单描述typeof-和-Object-prototype-toString-call" class="headerlink" title="实现一个instanceof, 简单描述typeof 和 Object.prototype.toString.call()"></a>实现一个instanceof, 简单描述typeof 和 Object.prototype.toString.call()</h4><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="几个有关原型的方法"><a href="#几个有关原型的方法" class="headerlink" title="几个有关原型的方法"></a>几个有关原型的方法</h4><h4 id="属性控制器"><a href="#属性控制器" class="headerlink" title="属性控制器"></a>属性控制器</h4><h4 id="可迭代对象的总结，如何快速转换成数组等。"><a href="#可迭代对象的总结，如何快速转换成数组等。" class="headerlink" title="可迭代对象的总结，如何快速转换成数组等。"></a>可迭代对象的总结，如何快速转换成数组等。</h4><h4 id="判断变量类型的的方法"><a href="#判断变量类型的的方法" class="headerlink" title="判断变量类型的的方法"></a>判断变量类型的的方法</h4><h3 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h3><h4 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h4><h4 id="实现promise"><a href="#实现promise" class="headerlink" title="实现promise"></a>实现promise</h4><h4 id="实现debounce-和-throlle"><a href="#实现debounce-和-throlle" class="headerlink" title="实现debounce 和 throlle"></a>实现debounce 和 throlle</h4><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h4 id="判断对象的类型，toString-实现"><a href="#判断对象的类型，toString-实现" class="headerlink" title="判断对象的类型，toString 实现"></a>判断对象的类型，toString 实现</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器和网络&quot;&gt;&lt;a href=&quot;#浏览器和网络&quot; class=&quot;headerlink&quot; title=&quot;浏览器和网络&quot;&gt;&lt;/a&gt;浏览器和网络&lt;/h3&gt;&lt;h4 id=&quot;浏览器的进程有哪些，分别作用&quot;&gt;&lt;a href=&quot;#浏览器的进程有哪些，分别作用&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一起写UI库（三）----栅格布局</title>
    <link href="https://blog.xunserver.cn/archives/179039cd.html"/>
    <id>https://blog.xunserver.cn/archives/179039cd.html</id>
    <published>2022-12-24T11:33:14.000Z</published>
    <updated>2022-12-24T11:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>实现一个UI库都具备的栅格系统，用于快速实现一个响应式的布局，栅格系统有如下特性</p><ul><li>具备一个row容器和一系列的col单元格，当然，col单独存在时也需要能正常展示</li><li>24个单元格，更加精细化的展示，同时还需要能够在单元格之间有空隙</li><li>单元格除了正常的排列外还需要具备偏移和排序功能</li><li>响应式布局也是必不可少的</li><li>新的框架也要是一个能够利用新特性的来实现栅格的，拥抱新特性</li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="基于float"><a href="#基于float" class="headerlink" title="基于float"></a>基于float</h4><p>首先实现一个简单的row，row根据不同设备大小定义，宽度100%<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">clear</span>: both;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">    <span class="selector-class">.clearfix</span>();</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@unit-count:</span> <span class="number">24</span>;</span><br><span class="line">    <span class="variable">@unit-width:</span> (<span class="number">100%</span> / <span class="variable">@unit-count</span>)</span><br><span class="line">    .col &#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    each(range(<span class="variable">@unit-count</span>), &#123;</span><br><span class="line">        .col-<span class="variable">@&#123;value&#125;</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: (<span class="variable">@unit-width</span> * <span class="variable">@value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加上间隔，假设间隔添加为12px，而且间隔还需要是首尾无间隔，中间的间隔相同<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">        <span class="attribute">margin-right</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以按照下面写</span></span><br><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">6px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">        <span class="attribute">padding-right</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>栅格系统的偏移指的是在原有位置上平移，如果有重复会直接覆盖。排序会使最终的效果按照css不是html实现，我们定义通过col-offset-4 表示在原有的位置上向右偏移4个单元格。定义col-push-4表示从第四个单元格开始布局<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">each</span>(range(<span class="variable">@unit-count</span>), &#123;</span><br><span class="line">    <span class="selector-class">.col-offset-</span><span class="variable">@&#123;value&#125;</span> &#123;</span><br><span class="line">        <span class="comment">// 偏移的关键通过相对定位 不会影响到其他</span></span><br><span class="line">        <span class="attribute">left</span>: <span class="variable">@value</span> * <span class="variable">@unit-width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .col-push-<span class="variable">@&#123;value&#125;</span> &#123;</span><br><span class="line">        <span class="comment">// 排序的关键是marigin，通过margin会影响到后面所有的</span></span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="variable">@value</span> * <span class="variable">@unit-width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="bootstrap实现栅格系统"><a href="#bootstrap实现栅格系统" class="headerlink" title="bootstrap实现栅格系统"></a>bootstrap实现栅格系统</h4><p>主要是参考bootstrap的栅格系统，bootstrap栅格系统由container、row和col组成。规定col必须包含在row中，row可以包含在container或者另一个col中。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span><span class="attribute">-sizes</span>: &#123;</span><br><span class="line">    <span class="attribute">sm</span>: <span class="number">768px</span></span><br><span class="line">    <span class="attribute">md</span>: <span class="number">992px</span>;</span><br><span class="line">    <span class="attribute">lg</span>: <span class="number">1200px</span>;</span><br><span class="line">    <span class="attribute">xs</span>: <span class="number">1920px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@media-sizes</span>[sm]) &#123;</span><br><span class="line">    <span class="comment">// 总是在两边空出一定间隔，避免撑满</span></span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">@media-sizes</span>[sm] - <span class="number">18px</span>; <span class="comment">// 750px;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@media-sizes</span>[md]) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">@media-size</span>[md] - <span class="number">22px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@media-sizes</span>[lg]) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">@media-size</span>[md] - <span class="number">30px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="comment">// 额外增加了15px的间隔</span></span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: auto;</span><br><span class="line">    <span class="attribute">margin-right</span>: auto;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.row</span> &#123;</span><br><span class="line">        <span class="comment">// 抵消到container额外增加的padding的</span></span><br><span class="line">        <span class="attribute">margin-left</span>: -<span class="number">15px</span>;</span><br><span class="line">        <span class="attribute">margin-right</span>: -<span class="number">15px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.col</span> &#123;</span><br><span class="line">        <span class="comment">// 因为这个地方总是增加了15的padding，为了方便col本身也作为container 容器使用, 也能实现间隔</span></span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">        <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="基于flex实现栅格系统"><a href="#基于flex实现栅格系统" class="headerlink" title="基于flex实现栅格系统"></a>基于flex实现栅格系统</h4><p>bootstrap栅格系统的神，目前bootstrap4 和 bootstrap5采用的方式就是flex的方式实现栅格，整理借鉴一下。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">each</span>(range(<span class="variable">@unit-count</span>), &#123;</span><br><span class="line">    <span class="selector-class">.col-</span><span class="variable">@&#123;value&#125;</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">@unit-width</span> * <span class="variable">@value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="迁移到ui框架"><a href="#迁移到ui框架" class="headerlink" title="迁移到ui框架"></a>迁移到ui框架</h3><p>前面我们的设计都是在style上面作文章，实际栅格系统这种东西也就是style，没有交互，迁移到UI框架需要开放一些定制能力，比如栅格的间隔大小，栅格的个数，这个是单纯的样式系统不能实现的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="踩坑总结"><a href="#踩坑总结" class="headerlink" title="踩坑总结"></a>踩坑总结</h3><ol><li><p>在less中使用计算时，有时会碰到变量不计算的问题(被处理成了宏，直接替换了)，使用括号包括强制计算</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@unit-count:</span> <span class="number">10</span>;</span><br><span class="line"><span class="variable">@unit-width:</span> <span class="number">100%</span> / <span class="number">10</span></span><br><span class="line"></span><br><span class="line">.col &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@unit-width</span> * <span class="number">5</span>  <span class="comment">// 理想应该输出 50   实际会输出 100% / 10 * 5</span></span><br><span class="line">    <span class="attribute">width</span>: (<span class="variable">@unit-width</span> * <span class="number">5</span>)  <span class="comment">// 强制计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>less中没有slot功能，比如想在@media将内容整个嵌入，还没找到办法实现</p></li><li><p>嵌套选择器没法跳过，这个还没找到功能</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-b</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里我只想最终的输出如下</span></span><br><span class="line"><span class="selector-class">.a-b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上会输出如下</span></span><br><span class="line"><span class="selector-class">.a</span> <span class="selector-class">.a-b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果选择更上一级的父选择器, 这个目前已经解决，通过将&amp;赋值实现</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;实现一个UI库都具备的栅格系统，用于快速实现一个响应式的布局，栅格系统有如下特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具备一个row容器和一系列的co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>硬盘分区和卷</title>
    <link href="https://blog.xunserver.cn/archives/7b2d2672.html"/>
    <id>https://blog.xunserver.cn/archives/7b2d2672.html</id>
    <published>2022-12-21T02:19:05.000Z</published>
    <updated>2022-12-21T02:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录下平常工作中接触的硬盘、分区和卷等概念，同时理解下电视盒子和各种中路由中分区的作用</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>大部分场景中硬盘和磁盘多理解成物理的设备。我们常见的机械硬盘，固态硬盘。根据接口不同又有sata盘，m2盘，m2-sata盘。<br>在linux中 /dev/sda /dev/sdb 就表示的两个磁盘</p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>通常情况下，硬盘不能直接使用，op总是只能识别特定的文件系统。通过对硬盘进行划分成不同的区域，对不同的区域进行不同的格式为不同的文件系统。</p><p>分区有MBR分区和GPT分区（重装系统的会经常看到），前者是老协议，后者较新，目前基本都是GPT</p><p>MBR(master boot record) 主引导记录，使用硬盘的第一个扇区来记录硬盘分区信息。其中64B记录的是4个分区表，所以MBR的硬盘最多只能有4个主分区。或者3个主分区加一个扩展分区（扩展分区中再分区成逻辑分区才能使用）。分区表中记录的起始分区起始扇区和终止扇区，由于分区表大小有限，所以MBR分区不能识别2T以上的硬盘<br>除此之外起始扇区中还记录了主引导程序(446)</p><p>GPT(GUID partition table) 全局分区表 GPT在硬盘的首尾都记录了关键信息，GPT中分区表大小是不是固定的。</p><h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p>卷是一个或者多个的分区组成的帮助操作系统管理的逻辑分组，windows中我们看到的卷和分区是相同，一个卷就包含一个分区，也能创建一个包含多个分区的卷，并且多个分区可以不是连续分区。</p><p>所以分区是连续的，但是卷不一定是连续的。</p><h3 id="系统分区、启动分区和活动分区"><a href="#系统分区、启动分区和活动分区" class="headerlink" title="系统分区、启动分区和活动分区"></a>系统分区、启动分区和活动分区</h3><p>系统分区指的是具有的引导程序的分区，启动分区是具有操作系统的分区，活动分区只能是主分区，而且一个硬盘只能有一个活动分区。分区表80开头的是活动分区。活动分区一定指向的是系统分区</p><h3 id="电脑系统启动流程"><a href="#电脑系统启动流程" class="headerlink" title="电脑系统启动流程"></a>电脑系统启动流程</h3><p>MBR的方式启动。bios中选择启动哪个硬盘，启动硬盘中MBR存放的第一个引导程序，第一引导程序可能直接引导系统，也可能继续查找其他的主分区的引导程序。所以MBR的如果是单硬盘双系统不能定制图形化比较大的引导程序</p><p>GPT的方式会查询硬盘中的各个分区中的EFI/boot/bootx64.efi文件做为引导项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;记录下平常工作中接触的硬盘、分区和卷等概念，同时理解下电视盒子和各种中路由中分区的作用&lt;/p&gt;
&lt;h3 id=&quot;硬盘&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>每日一个linux命令</title>
    <link href="https://blog.xunserver.cn/archives/540c0c41.html"/>
    <id>https://blog.xunserver.cn/archives/540c0c41.html</id>
    <published>2022-12-20T12:59:41.000Z</published>
    <updated>2022-12-20T12:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一下在开发中常用的linux命名</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找文件系统的中文件，默认查询的是目录以及子目录。</p><pre><code>find path [option]</code></pre><p>常见使用如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询指定目录不含子目录中 包含的.bat脚本文件</span></span><br><span class="line">find ./some-path --maxdepth 1 --name <span class="string">"*.bat"</span>   <span class="comment"># 支持的是基础通配符</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;记录一下在开发中常用的linux命名&lt;/p&gt;
&lt;h3 id=&quot;find&quot;&gt;&lt;a href=&quot;#find&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通配符</title>
    <link href="https://blog.xunserver.cn/archives/aecba7e5.html"/>
    <id>https://blog.xunserver.cn/archives/aecba7e5.html</id>
    <published>2022-12-06T08:18:35.000Z</published>
    <updated>2022-12-06T08:18:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发中常用到各种通配符，目前通配符规范较多，有linux通配符，也有nodejs通配符。简单记录一下区别和各自的使用场景，</p><h1 id="linux通配符"><a href="#linux通配符" class="headerlink" title="linux通配符"></a>linux通配符</h1><ul><li>* 匹配零个或者多个字符，但是不匹配”.”开头的文件, 也不会匹配/之外的内容（限制在单个路径）</li><li>? 匹配任何单个字符</li><li>~yang 用户杨根目录</li><li>[0-9] 匹配0-9 一次</li><li>[!0-9] 不匹配0-9一次</li></ul><p>linux是先匹配再执行。比如touch *.txt。先匹配发现没有则不执行。</p><p>touch {1..9}.txt 先解开大括号创建1到9的txt</p><p>后来bash又在这个基础上扩展了几个语法</p><ul><li><strong> 跨目录匹配，也是先按照目录展开模式再匹配    ls <em>/</em>.* 和 ls </strong>/<em>.</em> 有区别</li><li>{a,b,c} 重复执行匹配模式，先展开大括号再执行*等匹配</li><li>{a..c} 重复执行a到c之间的匹配模式</li><li>?(parttern-list) 匹配一次括号里面的模式</li><li>*(parttern-list) 匹配0次或者多次</li><li>+(parttern-list) 匹配一次或者多次</li><li>@(parttern-list) 匹配一次</li><li>!(parttern-list) 不匹配</li></ul><p>回到开头node中大部分都使用的是扩展后的语法，而且是自行实现，不和平台挂钩。但是我们在命令行中执行命令时根据使用shell的版本，有可能没有实现一些扩展语法</p><p>比如在rimraf中删除东西 rimraf *<em>/node_modules 有可能就不会删除，因为没有实现\</em>* 语法。</p><p>还有一个坑是npm中执行脚本，npm执行脚本不一定会在当前的shell执行，有可能会在其他的shell。就会出现glob语法和在命令行执行不一致的情况，比如上面的rimraf。<br>大部分工具目前都是用的自定义的glob，通过将glob用引号包裹起来可以避免shell的glob模式</p><p><a href="https://medium.com/@jakubsynowiec/you-should-always-quote-your-globs-in-npm-scripts-621887a2a784" target="_blank" rel="noopener">npm 中一定要用引号包裹</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;开发中常用到各种通配符，目前通配符规范较多，有linux通配符，也有nodejs通配符。简单记录一下区别和各自的使用场景，&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://blog.xunserver.cn/archives/f255ffad.html"/>
    <id>https://blog.xunserver.cn/archives/f255ffad.html</id>
    <published>2022-12-05T13:56:44.000Z</published>
    <updated>2022-12-05T13:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经常用docker，但是从来没有系统性的总结过docker满足生产力需要掌握的内容</p><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>docker可以理解为一个具有初始操作的快照模版，docker通过运行一个镜像生成容器。</p><ul><li>docker pull nodejs 拉取镜像</li><li>docker images 或者 docker ls 查看本地镜像</li><li>docker image rm xx-image</li></ul><h4 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"&#123;</span></span><br><span class="line"><span class="string">  "</span>registry-mirrors<span class="string">": [</span></span><br><span class="line"><span class="string">    "</span>https://hub-mirror.c.163.com<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>https://mirror.baidubce.com<span class="string">"</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;"</span> &gt;&gt; /etc/daemon.json</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器相当于镜像的实例化，每个容器都是一个进程，如果想让容器一直存在需要容器的启动进程一直存在。</p><ul><li>docker container ls 查看当前系统的容器</li><li>docker run –name somename -it –rm -p -v –mount –link -d –restart。<ul><li>-p 本地端口:容器内端口；</li><li>-v 本地本地路径（绝对路劲）|数据卷:容器内路径</li><li>–mount source=some-volumn,target=/var/xxx  绑定本地目录或者数据卷</li><li>-it 绑定本地的输入输出</li><li>–rm 容器终止后删除容器</li><li>–restart always 容器总是重启</li><li>–link 添加另一个容器来组成网络(总是或默认创建一个容器网络)</li></ul></li><li>docker container inspect xxx 查看容器具体信息</li><li>docker container exec  xx -it sh 容器执行某个新命令，常用于进入容器查看信息</li></ul><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>docker 数据卷（相当于一个目录）可用在多个容器之前共享，不会随着容器终止而清空内容，通过–mount 或者-v 绑定到容器中</p><ul><li>docker volume xxxname</li><li>docker volume inspect xxx 查看某个数据卷，主要查看存放位置等。</li></ul><h3 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h3><ul><li>docker network ls 查看所有的网络</li><li>docker network create -d bridge xxx 创建一个桥接网络（一个新的网络，桥接在原host上面的）</li></ul><p>docker 在安装时默认会生成host和bridge两个网络。重点是bridge网络，通过虚拟网桥docker0和容器的网口连接，虚拟网桥又通过宿主机的iptable进行转发。</p><p>我们每创建一个网络就相当于开了一个子网，可以自定义网关和子网范围</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>docker 能够从Dockerfile文件创建镜像，一般社区中的镜像大部分都是Dockerfile创建，Dockerfile是由一系列指令构成，每一个指令都会构建一层，指令不要太多，功能类似的指令尽量放到一层</p><ul><li>FROM 镜像基础来源，可以是另一个镜像</li><li>RUN 执行命令， 尽量将多个指令合并 &amp;&amp; \</li><li>COPY 复制目录或者文件到镜像中，支持linux通配符 COPY home* /user/src/home, 会自动创建目录，而且会保留文件的元数据（权限等）</li><li>ADD 如果是URL，会直接下载文件（权限600），如果是压缩包会解压。ADD指令不会缓存， 每次都会重新构建。总是使用COPY，需要解压时才使用ADD</li><li>CMD 容器的启动命令，容器总是需要一个默认启动命令 CMD [“nginx”, “-g”, “xx”]</li><li>ENTRYPOINT 如果指明了该项，CMD会作为ENTRYPOINT的参数拼接在后面，常用实现一个命令行工具，比如ENTRYPOINT实现指令 CMD实现参数</li><li>ENV配置镜像默认环境变量，</li><li>ARG 配置在构建过程中的环境变量，而且只在FROM后生效用于辅助构建。但是不会存在到镜像中。比如声明一些变量</li><li>VOLUME 定义匿名卷，VOLUME /data 将/data挂载到匿名卷中，如果容器启动时没有指明卷，就会匿名生成一个，所以不是很关注的卷不需要自己再挂载目录</li><li>EXPOSE 声明容器内部暴露的端口</li><li>WORKDIR 声明每个指令镜像内的工作目录（和build时分开），注意在dockerfile中下面不会工作，因为每条指令是单独的，不会共享<br>  RUN cd /app<br>  RUN echo “sdf” &gt; xx.txt </li><li>USER 指定当前指令之后所有的指令的user，同样也是要在FROM后，而且系统中必须要先创建这个角色</li><li>SHELL 指定RUN ENTRYPOINT CMD指令在哪个shell下运行。默认是[“/bin/sh”, “-c”]</li></ul><h4 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h4><p>如果不用多阶段构建，需要将上一个容器的内容拷贝(docker cp)到宿主机，再用COPY拷贝到下一个阶段的容器中去<br>FROM ubuntu:lasted as builder<br>WORKDIR /app/data<br>COPY ./test ./test<br>RUN npm build<br>FROM ubuntu:lasted as builder  // 需要和上面一个FROM相同<br>RUN npm run deploy</p><p>docker build -f xxxdockerfile -t nginx:tag ./xxx –target builder<br>注意最后一个./xx 表示构建过程中的上下文，比如COPY ./local/xxx /app 表示的是.local的相对位置， docker会将上下文目录中所有内容拷贝到镜像中，通过.dockerignore忽略部分文件</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h3><p>docker compose文件主要由两部分组成，公共部分和容器部分。公共部分指明当前compose需要创建的网络，数据卷等。容器部分和启动容器类似</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;经常用docker，但是从来没有系统性的总结过docker满足生产力需要掌握的内容&lt;/p&gt;
&lt;h3 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>脚本大全</title>
    <link href="https://blog.xunserver.cn/archives/b7b7cac5.html"/>
    <id>https://blog.xunserver.cn/archives/b7b7cac5.html</id>
    <published>2022-12-05T13:46:16.000Z</published>
    <updated>2022-12-05T13:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "registry-mirrors": [</span></span><br><span class="line"><span class="string">    "https://hub-mirror.c.163.com",</span></span><br><span class="line"><span class="string">    "https://mirror.baidubce.com"</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;'</span> &gt;&gt; /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">DOCKER_CONFIG=/usr/<span class="built_in">local</span>/lib/docker/cli-plugins</span><br><span class="line">sudo mkdir -p <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">sudo curl -SL https://download.fastgit.org/docker/compose/releases/download/v2.6.1/docker-compose-linux-x86_64 -o <span class="variable">$DOCKER_CONFIG</span>/cli-plugins/docker-compose</span><br><span class="line">chmod +x <span class="variable">$DOCKER_CONFIG</span>/cli-plugins</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker compose"></a>安装docker compose</h3><h3 id="部署jenkins"><a href="#部署jenkins" class="headerlink" title="部署jenkins"></a>部署jenkins</h3><p>命令行部署<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir jenkins</span><br><span class="line">chmod 777 jenkins</span><br><span class="line">cd jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录下面的密码</span></span><br><span class="line">docker run --name jenkins -p 8080:8080 -p 50000:50000 -v $PWD:/var/jenkins_home --rm -it jenkins/jenkins:lts-jdk11</span><br><span class="line">docker run --name jenkins -p 8080:8080 -p 50000:50000 -v $PWD:/var/jenkins_home -d --restart always jenkins/jenkins:lts-jdk11</span><br></pre></td></tr></table></figure></p><p>使用docker compose部署<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">    jenkins_home:</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    jenkins:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">jenkins/jenkins:lts-jdk11</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"50000:50000"</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="attr">            - jenkins_home:</span><span class="string">/var/jenkins_home</span></span><br></pre></td></tr></table></figure></p><h3 id="部署snoar"><a href="#部署snoar" class="headerlink" title="部署snoar"></a>部署snoar</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  sonarqube:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">sonarqube:community</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">sonarqube</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">sonarqube</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      SONAR_JDBC_URL:</span> <span class="attr">jdbc:postgresql://db:5432/sonar</span></span><br><span class="line"><span class="attr">      SONAR_JDBC_USERNAME:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">      SONAR_JDBC_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - sonarqube_data:</span><span class="string">/opt/sonarqube/data</span></span><br><span class="line"><span class="attr">      - sonarqube_extensions:</span><span class="string">/opt/sonarqube/extensions</span></span><br><span class="line"><span class="attr">      - sonarqube_logs:</span><span class="string">/opt/sonarqube/logs</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9000:9000"</span></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">postgres:12</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      POSTGRES_USER:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">      POSTGRES_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">      POSTGRES_DB:</span> <span class="string">sonar</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - postgresql:</span><span class="string">/var/lib/postgresql</span></span><br><span class="line"><span class="attr">      - postgresql_data:</span><span class="string">/var/lib/postgresql/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  jenkins:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">jenkins/jenkins:lts-jdk11</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"50000:50000"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">        - jenkins_home:</span><span class="string">/var/jenkins_home</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  sonarqube_data:</span></span><br><span class="line"><span class="attr">  sonarqube_extensions:</span></span><br><span class="line"><span class="attr">  sonarqube_logs:</span></span><br><span class="line"><span class="attr">  postgresql:</span></span><br><span class="line"><span class="attr">  postgresql_data:</span></span><br><span class="line"><span class="attr">  jenkins_home:</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">docker compose up </span><br><span class="line">docker compose start</span><br></pre></td></tr></table></figure><h3 id="搭建内网测速服务器"><a href="#搭建内网测速服务器" class="headerlink" title="搭建内网测速服务器"></a>搭建内网测速服务器</h3><pre><code>docker run -it --rm --name speedtest -p 9100:80 adolfintel/speedtestdocker run --name speedtest -p 9100:80 --restart always -d adolfintel/speedtest</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装docker&quot;&gt;&lt;a href=&quot;#安装docker&quot; class=&quot;headerlink&quot; title=&quot;安装docker&quot;&gt;&lt;/a&gt;安装docker&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>doc 和 git submodule</title>
    <link href="https://blog.xunserver.cn/archives/7bf438f9.html"/>
    <id>https://blog.xunserver.cn/archives/7bf438f9.html</id>
    <published>2022-12-02T09:31:02.000Z</published>
    <updated>2022-12-02T09:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于搞了一些开源工具，需要一个统一的文档管理，入了vitepress写文档的坑。目前的开源内容有一系列的config文件，集中在@xunserver/config 这个仓库中，通过pnpm管理，每个包都有自己的reameme.md 和changelog.md。<br>还有个仓库存放了icon,style和vui的代码，目前有下面的痛点。</p><ol><li>doc是一个单独仓库只存放文档，文档中还需要引入各个包的readme.md已经changelog。</li><li>除了changelog外，对vui的还需要进行组件的引入，对于style还需要样式的引入。</li><li>目前的doc和vui存放在一起通过pnpm的方式引入。</li></ol><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><p>git submodule 相当于将某个仓库的某个commit作为模块添加项目中，而且对项目透明，项目本身不能去修改。</p><h4 id="git-submodule-add"><a href="#git-submodule-add" class="headerlink" title="git submodule add"></a>git submodule add</h4><p>添加submodule到项目中，执行后git 会下载子模块到项目中。同时生成.gitmodule文件来记录关系</p><h4 id="git-submodule-init"><a href="#git-submodule-init" class="headerlink" title="git submodule init"></a>git submodule init</h4><p>根据.gitmodule文件下载子项目，通常用来父项目第一次拉取后</p><h4 id="git-submodule-deinit"><a href="#git-submodule-deinit" class="headerlink" title="git submodule deinit"></a>git submodule deinit</h4><p>清空子项目代码但是不删除.gitmodule中的关系</p><h4 id="git-submodule-update"><a href="#git-submodule-update" class="headerlink" title="git submodule update"></a>git submodule update</h4><p>根据.gitmodule 中记录的子项目的commit下载子项目的代码，通过git submodule update –remote 总是根据远端的来下载。通常情况下如果子项目更新后，父项目能够感知到子项目的最新commit，并且会生成一个差异文件，如果差异文件被提交。另一个合作伙伴需要根据最新的commit的下载代码</p><h4 id="git-submodule-foreach"><a href="#git-submodule-foreach" class="headerlink" title="git submodule foreach"></a>git submodule foreach</h4><p>批量操作子项目，git submodule foreach “echo $name”</p><h4 id="git-rm-path"><a href="#git-rm-path" class="headerlink" title="git rm path"></a>git rm path</h4><p>删除子项目</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>doc文档有两种情况是需要更新的</p><ol><li>相关的readme或者组件变更，doc本身无需变更。这种情况doc设置一个每天自动重新构建即可。</li><li>doc本身需要变更，变更部分内容。这种需要doc发布后触发重新构建</li><li>手动更新</li></ol><h3 id="doc文档"><a href="#doc文档" class="headerlink" title="doc文档"></a>doc文档</h3><p>doc文档使用的vitepress, 可以在文档中直接引入vue3代码，同时还支持markdown引用。这两个可以引入其他的包的说明文档和vui组件的文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于搞了一些开源工具，需要一个统一的文档管理，入了vitepress写文档的坑。目前的开源内容有一系列的config文件，集中在@xunse
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rollup</title>
    <link href="https://blog.xunserver.cn/archives/de3a6b85.html"/>
    <id>https://blog.xunserver.cn/archives/de3a6b85.html</id>
    <published>2022-12-02T09:04:00.000Z</published>
    <updated>2022-12-02T09:04:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>child_process</title>
    <link href="https://blog.xunserver.cn/archives/e4a9508d.html"/>
    <id>https://blog.xunserver.cn/archives/e4a9508d.html</id>
    <published>2022-12-02T02:20:01.000Z</published>
    <updated>2022-12-02T02:20:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>nodejs 提供创建操作子进程的能力，通过spawn exec fork execFile四个api。后面三个均是spawn的衍生。</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>shell是一个快捷启动进程的壳子，当我们在shell中敲命令（外部命令）时，实际是通过shell作为父进程创建了一个子进程比如 node xxx.js。所以当我们关闭shell窗口时，对应的命令也会kill。没登录一次shell窗口就会产生一个shell进程。具体是哪个shell使用用户自行配置的。</p><p>有时候我们写shell脚本会指定该脚本由哪个shell执行，流程是先打开对应的进程，对应的进程对脚本内容进行处理。</p><h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>nodejs本身在执行时也是一个进程，如果是被shell直接调用，则是shell的衍生进程。当nodejs通过child_process 创建子进程时，如果有些子进程还需要通过shell来启动，所以还能指定是否启动shell。 主进程关闭后子进程也会关闭。进程需要关注的是以下几个点</p><ol><li>stdout，stdin，stderr 表示进程输入，输出和错误。由于当前的默认情况子进程的stdout,stdin,stderr是pipe，意思是通过管道向外发射。也可以设置为和父进程共享，借助父进程来输入输出</li><li>还有一种IPC子进程，父子进程通过IPC通信，nodejs中是on(‘message’)和send。通过fork创建或者执行std是IPC。 IPC只能用都是node进程的情况下</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> child_process <span class="keyword">from</span> <span class="string">'child_process'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shelljs = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> child = child_process.spawn(<span class="string">'ls'</span>, &#123;</span><br><span class="line">        shell: <span class="literal">true</span></span><br><span class="line">    &#125;, (err, stdin, stdout) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程追加"><a href="#进程追加" class="headerlink" title="进程追加"></a>进程追加</h3><p>很多情况子进程都是启动后执行完毕就会自动关闭，每次执行上下文不共享。但是也可以启动一个常驻的进程，比如直接启动一个shell。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; spawn, spawnSync &#125; <span class="keyword">from</span> <span class="string">"child_process"</span>;</span><br><span class="line"><span class="keyword">const</span> mergeShellOptions = <span class="function">(<span class="params">...options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...options);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getGlobalShell = <span class="function">(<span class="params">(shell</span>) =&gt;</span> (option, config) =&gt; &#123;</span><br><span class="line">  shell = shell || Shell.createShell(option, config);</span><br><span class="line">  <span class="keyword">return</span> shell;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> getDefaultOption = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  shell: <span class="literal">true</span>,</span><br><span class="line">  stdio: [<span class="string">"pipe"</span>, <span class="string">"inherit"</span>, <span class="string">"inherit"</span>],</span><br><span class="line">  timeout: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> getBash = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">"win32"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">cmd</span>: <span class="string">"cmd"</span>, <span class="attr">arg</span>: <span class="string">"/C"</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">cmd</span>: <span class="string">"sh"</span>, <span class="attr">arg</span>: <span class="string">"-c"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultOption = getDefaultOption();</span><br><span class="line">  <span class="keyword">static</span> createShell(option, config) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Shell(option, config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> exec(cwd, option, config) &#123;</span><br><span class="line">    <span class="keyword">const</span> shell = getGlobalShell(option, config);</span><br><span class="line">    shell.exec(cwd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * shell示例的选项</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  shellOption;</span><br><span class="line">  shell;</span><br><span class="line">  <span class="keyword">constructor</span>(option, config) &#123;</span><br><span class="line">    <span class="keyword">this</span>.shellOption = mergeShellOptions(Shell.defaultOption, option);</span><br><span class="line">    <span class="keyword">this</span>.shell = spawn(getBash().cmd, <span class="keyword">this</span>.shellOption);</span><br><span class="line">  &#125;</span><br><span class="line">  exec(cwd) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cwd);</span><br><span class="line">    <span class="keyword">this</span>.shell.stdin.write(cwd + <span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close() &#123;</span><br><span class="line">    <span class="keyword">this</span>.shell.kill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Shell;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;nodejs 提供创建操作子进程的能力，通过spawn exec fork execFile四个api。后面三个均是spawn的衍生。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>npm包的CI和changeset</title>
    <link href="https://blog.xunserver.cn/archives/69a9cdfe.html"/>
    <id>https://blog.xunserver.cn/archives/69a9cdfe.html</id>
    <published>2022-11-30T03:28:44.000Z</published>
    <updated>2022-11-30T03:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前的config仓库按照monorepo的方式存放的，里面有完全不同种类的的config包，大部分包的依赖的都是独立的,也有部分公共的包比如typescript和prettier。同时各个仓库的发布阶段都是交给github-action在做CI如何设计。</p><h3 id="changeset"><a href="#changeset" class="headerlink" title="changeset"></a>changeset</h3><p>changeset生成能够被消耗的changeset描述文件, 开发自行调整描述文件， changeset version消耗描述文件，调整需要发布的包， changeset publish到各个包发布，流程很简单。<br>按照下面步骤描述下细节</p><ol><li><p>changeset init 初始化changeset配置</p></li><li><p>changeset add 对当前更改新增描述文件，changeset add 会自动的查找到当前的修改的包，前提是没有commit的情况下</p></li><li><p>选择包进入命令式的交互填写，主要写需要更新那些包。通过patch minor 或者major的方式更新包。</p></li><li><p>changeset version消耗刚才描述文件来对包进行version的更新。</p></li><li><p>changeset publish 会到各个包下面进行npm publish，这个步骤也可以通过自行publish实现</p></li></ol><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ol><li>本地修改代码，运行changeset add 生成消耗文件，可以不修改文件，强行生成changeset文件。</li><li>正常上传代码，github action 根据存在pub来决定是否打包</li><li>github action 运行 changeset version 消耗文件同时修改版本号</li><li>运行pnpm -F “[origin/xx]”… run build 来分别执行相关的包的build</li><li>运行pnpm publish -F “[origin/xxx]” 发布包或者[HEAD]…（当前分支比较）</li><li>使用<code>git add -A</code> git commit -m “” git push 推送包， 也可以通过merge来推送包避免多人修改时的问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;目前的config仓库按照monorepo的方式存放的，里面有完全不同种类的的config包，大部分包的依赖的都是独立的,也有部分公共的包比
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重绘回流</title>
    <link href="https://blog.xunserver.cn/archives/f9860ccd.html"/>
    <id>https://blog.xunserver.cn/archives/f9860ccd.html</id>
    <published>2022-11-29T05:10:59.000Z</published>
    <updated>2022-11-29T05:10:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="渲染层-renderLayer"><a href="#渲染层-renderLayer" class="headerlink" title="渲染层 renderLayer"></a>渲染层 renderLayer</h3><p>每一个DOM都会对应一渲染对象(renderObject)，每一个渲染对象在处于不同相同的坐标空间时，就会形成一个RenderLayers渲染层。下面的元素都会生成渲染层。不能开启渲染层的renderObject和其最近一个有渲染层的父节点共享。</p><ol><li>根元素</li><li>有明确定位的属性 position不为static</li><li>opacity &lt; 1</li><li>transform 存在</li><li>overflow 不为visible<h3 id="合成层"><a href="#合成层" class="headerlink" title="合成层"></a>合成层</h3>对于某些符合条件的渲染层会自动处理成合成层，每一个合成层都有一个独立的GraphicsLayer, 不满足和最近一个拥有图形层的共享。<br>下面这些条件能开启图形层</li><li>3D transforms</li><li>video canvas iframe // 即使video没有单独的渲染层，但是video在根元素下，也满足</li><li>will-change 属性</li><li>position:fixed</li><li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</li></ol><p>除了显示生成合成层外，还有部分隐式的情况，通过谷歌开发者工具render 和 layers可以看到图层的详细信息</p><p>隐式场景会导致合成层过多的情况下，浏览器出自动层压缩，会将能够合并的合成层压缩到一个图形层中</p><h3 id="图形层-GraphicsLayer"><a href="#图形层-GraphicsLayer" class="headerlink" title="图形层 GraphicsLayer"></a>图形层 GraphicsLayer</h3><p>图形层是最终输出到界面的布局，</p><h3 id="合成层的好处"><a href="#合成层的好处" class="headerlink" title="合成层的好处"></a>合成层的好处</h3><ol><li>合成层是GPU渲染，比较快</li><li>重绘时只会绘制合成层本身</li><li>transform 和 opacity 不会发出重绘</li></ol><h3 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h3><p>回流指的是layer的重新生成，有以下几种情况会导致回流，注意的回流都是对当前的合成层进行，不会影响到其他的</p><ol><li>首次渲染</li><li>浏览器窗口改变</li><li>元素的位置或者尺寸发生变化</li><li>新增删除可见元素</li><li>元素内容变换</li><li>元素的字体大小发生变化</li><li>激活伪类</li><li>设置style值    // 尽力改css类</li><li>查询元素边界大写</li></ol><p>重绘是指改变visible,outline，背景色等，不会影响的到元素位置的变化。</p><p>我们平常的说的重绘和回流都是针对某一个图形层来说的。 所以优化的思路从两个角度出发。</p><ol><li>尽可能避免回流操作，比如减少style直接js写值，减少对offset的读取。多个新增删除操作合并等。</li><li>如果没办法避免回流操作，尽量将回流的范围缩小，比如将改动的元素提升到合成层中，注意的合成层的条件是现有渲染层，合成层是从渲染层中来的。常见的生成合成的操作有transform: translate3D，或者简单粗暴添加will-change</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;渲染层-renderLayer&quot;&gt;&lt;a href=&quot;#渲染层-renderLayer&quot; class=&quot;headerlink&quot; title=&quot;渲染层 renderLayer&quot;&gt;&lt;/a&gt;渲染层 renderLayer&lt;/h3&gt;&lt;p&gt;每一个DOM都会对应一渲染对象(re
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>keep-alive</title>
    <link href="https://blog.xunserver.cn/archives/c5319648.html"/>
    <id>https://blog.xunserver.cn/archives/c5319648.html</id>
    <published>2022-11-28T08:26:36.000Z</published>
    <updated>2022-11-28T08:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>根据组件的tag和keys来生成具有LRU的缓存的map，通过添加abstract属性，避免出现在$parent链中，每次渲染时总是检查缓存是否存在，如果存在render函数直接返回之前的vnode并添加缓存。返回新的vnode后在keep-alive的patch阶段又会重新走createComponent子组件的操作，就会进入之前的缓存逻辑</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>组件的源码比较简单，有两个需要主要的点吗，设置abstract:true 还是能通过parent属性获取到keep-alive组件示例，对于手动的修改缓存队列或者在自定义缓存时有用。keep-alive的render实际是返回一个vnode，如果能够根据key查到缓存则返回之前的vnode。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> slot = <span class="keyword">this</span>.$slots.default</span><br><span class="line">  <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot) <span class="comment">// 找到第一个子组件对象</span></span><br><span class="line">  <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">  <span class="keyword">if</span> (componentOptions) &#123; <span class="comment">// 存在组件参数</span></span><br><span class="line">    <span class="comment">// check pattern</span></span><br><span class="line">    <span class="keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="comment">// 组件名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// 条件匹配</span></span><br><span class="line">      <span class="comment">// not included</span></span><br><span class="line">      (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">      <span class="comment">// excluded</span></span><br><span class="line">      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span> <span class="comment">// 定义组件的缓存key</span></span><br><span class="line">      <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">      <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">      ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">      : vnode.key</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123; <span class="comment">// 已经缓存过该组件</span></span><br><span class="line">      vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">      <span class="comment">// make current key freshest</span></span><br><span class="line">      remove(keys, key)</span><br><span class="line">      keys.push(key) <span class="comment">// 调整key排序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache[key] = vnode <span class="comment">// 缓存组件对象</span></span><br><span class="line">      keys.push(key)</span><br><span class="line">      <span class="comment">// prune oldest entry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="keyword">this</span>.max)) &#123; <span class="comment">// 超过缓存数限制，将第一个删除</span></span><br><span class="line">        pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="keyword">this</span>._vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnode.data.keepAlive = <span class="literal">true</span> <span class="comment">// 渲染和执行被包裹组件的钩子函数需要用到</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心在下面的createComponent中，针对keepAlive包裹的组件，在重新渲染时vnode因为是之前的vnode，会触发init额外的流程。进而直接到prepatch阶段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vnode指的是根据keep-alive render函数得到的包裹组件的vnode，拿到vnode。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> i = vnode.data;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">        <span class="comment">// isReactivated用来判断组件是否缓存。</span></span><br><span class="line">        <span class="keyword">var</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive;</span><br><span class="line">        <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">            <span class="comment">// 执行组件初始化的内部钩子 init，下面的componentVNodeHooks.init</span></span><br><span class="line">          i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">          <span class="comment">// 其中一个作用是保留真实dom到vnode中</span></span><br><span class="line">          initComponent(vnode, insertedVnodeQueue);</span><br><span class="line">          insert(parentElm, vnode.elm, refElm);</span><br><span class="line">          <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> componentVNodeHooks = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        vnode.componentInstance &amp;&amp;</span><br><span class="line">        !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">        vnode.data.keepAlive</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">        <span class="keyword">var</span> mountedNode = vnode; <span class="comment">// work around flow</span></span><br><span class="line">        componentVNodeHooks.prepatch(mountedNode, mountedNode);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 将组件实例赋值给vnode的componentInstance属性</span></span><br><span class="line">        <span class="keyword">var</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">          vnode,</span><br><span class="line">          activeInstance</span><br><span class="line">        );</span><br><span class="line">        child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 后面分析</span></span><br><span class="line">    prepatch: <span class="function"><span class="keyword">function</span> <span class="title">prepatch</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 新组件实例</span></span><br><span class="line">        <span class="keyword">var</span> options = vnode.componentOptions;</span><br><span class="line">        <span class="comment">// 旧组件实例</span></span><br><span class="line">        <span class="keyword">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">        updateChildComponent(</span><br><span class="line">            child,</span><br><span class="line">            options.propsData, <span class="comment">// updated props</span></span><br><span class="line">            options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">            vnode, <span class="comment">// new parent vnode</span></span><br><span class="line">            options.children <span class="comment">// new children</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;根据组件的tag和keys来生成具有LRU的缓存的map，通过添加abstract属性，避免出现在$parent链中，每次渲染时总是检查缓存
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>form-data的故事</title>
    <link href="https://blog.xunserver.cn/archives/ff59502f.html"/>
    <id>https://blog.xunserver.cn/archives/ff59502f.html</id>
    <published>2022-11-28T02:42:02.000Z</published>
    <updated>2022-11-28T02:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>前端请求中经常碰到content-type，主要需要关注的是以下几种<br>application/json 请求以json的形式上传，后端需要按照的json的方式解析body<br>application/x-www-form-urlencoded 按照key=name&amp;key=name的形式将参数拼接在body中。其中key和name需要用URLSearchParams处理(不能用urlEncodeComponent是历史遗留原因，application/x-www-form-urlencoded 需要将空格转义成+，urlEncodeComponent将空格转义成%20)<br>multipart/form-data boundary=xxxx 将请求按照xxxx分隔包围，每一段包括一个字段.<br>其中每一个keyvalue 也需要转义（空格转+）,这一块比较奇怪</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;前端请求中经常碰到content-type，主要需要关注的是以下几种&lt;br&gt;application/json 请求以json的形式上传，后端
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>diff算法</title>
    <link href="https://blog.xunserver.cn/archives/3387ce12.html"/>
    <id>https://blog.xunserver.cn/archives/3387ce12.html</id>
    <published>2022-11-23T03:26:05.000Z</published>
    <updated>2022-11-23T03:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单diff"><a href="#简单diff" class="headerlink" title="简单diff"></a>简单diff</h3><p>简单diff的思路是判断新列表的节点是否是递增的，如果不是递增的旧列表中的节点移动到新列表中节点的前一位的后面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactDiff = <span class="function">(<span class="params">prevVnodeList, newVnodeList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newVnodeList.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newVnode = newVnodeList[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newVnodeList.length; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevVnode = prevVnodeList[j];</span><br><span class="line">            <span class="keyword">if</span>(newVnode.key === prevVnode.key) &#123;</span><br><span class="line">                patchDom(prevVnode, newVnode)</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= lastIndex) &#123;</span><br><span class="line">                    lastIndex = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.insertBefore(newVnode.el, newChildren[i<span class="number">-1</span>].el.nextSibling)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双端diff"><a href="#双端diff" class="headerlink" title="双端diff"></a>双端diff</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单diff&quot;&gt;&lt;a href=&quot;#简单diff&quot; class=&quot;headerlink&quot; title=&quot;简单diff&quot;&gt;&lt;/a&gt;简单diff&lt;/h3&gt;&lt;p&gt;简单diff的思路是判断新列表的节点是否是递增的，如果不是递增的旧列表中的节点移动到新列表中节点的前一位的后
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="https://blog.xunserver.cn/archives/6098be36.html"/>
    <id>https://blog.xunserver.cn/archives/6098be36.html</id>
    <published>2022-11-22T14:07:22.000Z</published>
    <updated>2022-11-22T14:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础中需要注意的点"><a href="#基础中需要注意的点" class="headerlink" title="基础中需要注意的点"></a>基础中需要注意的点</h3><ol><li><p>如果通过path导航，总是回匹配到子路由，如果只想展示父路由，通过name的形式导航</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    name: <span class="string">'parent'</span>,</span><br><span class="line">    path: <span class="string">'/foo'</span>,</span><br><span class="line">    component: ParentComponent,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        name: <span class="string">'child'</span>,</span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        component: ChildrenComponent</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">'/foo'</span>&#125;)   <span class="comment">// 会渲染parentComponent 和 ChildComponent</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'parent'</span>&#125;) <span class="comment">// 只会渲染parentComponent，刷新后</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套路由中子路由如果使用绝对路径代表路由不嵌套，只嵌套组件。</p></li><li><p>新版本vue-router 支持正则表达式的匹配，同时取消了*匹配符，404页面使用正则来匹配</p></li><li><p>支持命令路由和命令视图, 大致意思是同一个url，可以渲染多个视图。<router-view name="slider"> ，路由配置中通过components: {default: xxx, slider: xxx} 形式配置</router-view></p></li><li><p>支持别名，即url显示一个地址，实际界面展示的是另一个路由url配置的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    url: <span class="string">'/'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    alias: <span class="string">'/home'</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="comment">// 直接浏览器导航到/home 也会展示/的界面</span></span><br></pre></td></tr></table></figure></li><li><p>支持相对重定向和动态重定向，相对重定向对于当前路由，绝对重定向通过传入一个函数实现</p></li><li><p>router-link 支持v-slot，将跳转能力自自定义。</p></li><li><p>同时router-view 也支持v-slot，能将路由页面进行包裹</p></li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li>组件内beforeRouterLeave</li><li>全局的beforeEach</li><li>路由的beforeEach</li><li>组件内的beforeEnter</li><li>全局的beforeResolve</li><li>全局的afterEach</li><li>新路由的beforeCreated到beforeMounted</li><li>老路由组件的销毁</li><li>新路由mounted</li></ol><h3 id="几个关键概念-RouterRecord-和-RouterLocation"><a href="#几个关键概念-RouterRecord-和-RouterLocation" class="headerlink" title="几个关键概念 RouterRecord 和 RouterLocation"></a>几个关键概念 RouterRecord 和 RouterLocation</h3><p>RouterRecord 表示路由表，指的是用户在配置路由时的定义，用户配置时RouterRecordRaw，vue-router内部补全成RouterRecordNormalized。理解成路由实例的构造器选项</p><p>RouterLocation是实际生效的路由，理解成路由的实例化。其中RouterLocationRaw用于push的参数，相当于根据RouterLocationRaw查找到具体的路由。在to和from以及matched中$route均是这个对象</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><ol><li>通过mixin添加在beforeCreated中添加绑定_currentRoot._router和_currentRoot._route 属性，在Vue.prototype中将两个$route和$router代理到上面两个属性上.</li><li>注册两个全局组件router-link 和 router-view</li><li>同时还添加了防止重复安装的判断</li></ol><h4 id="new-VueRouter-Routes"><a href="#new-VueRouter-Routes" class="headerlink" title="new VueRouter(Routes)"></a>new VueRouter(Routes)</h4><p>大致过程就是递归的根据的传入的RouteRecordRaw 生成路由记录表，并生成nameMap和pathMap，同时生成match函数，通过调用match函数获取当前匹配的路由表</p><h4 id="router-init"><a href="#router-init" class="headerlink" title="router.init()"></a>router.init()</h4><p>在安装插件时根据是否是根路由，对不同的路由模式添加监听，监听函数主要对url变化时，调整当前激活的路由写入到全局$route中</p><h4 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h4><p>router总是监听当前$route的变化并喧嚷路由对应的界面。通过添加$dataView参数标记自身，查找自身的深度来渲染matched数组的第几项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础中需要注意的点&quot;&gt;&lt;a href=&quot;#基础中需要注意的点&quot; class=&quot;headerlink&quot; title=&quot;基础中需要注意的点&quot;&gt;&lt;/a&gt;基础中需要注意的点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果通过path导航，总是回匹配到子路由，如果只想展示父路由，通过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>状态管理进阶和实战</title>
    <link href="https://blog.xunserver.cn/archives/6e558469.html"/>
    <id>https://blog.xunserver.cn/archives/6e558469.html</id>
    <published>2022-11-21T13:31:11.000Z</published>
    <updated>2022-11-21T13:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex是vue2中首选的状态管理工具，包括state、mutation、action 三大马车，大致是组件触发dispatch()或者commit()来修改state中的数据</p><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>redux包括state，所有的state必须要通过dispatch(action) 来触发，redux内部通过事先注册号的的reducer来处理dispath(action) 的动作。reducer是一个接受action的函数，通过action来改变当前的state并返回新的state。<br>可以看到，vuex是在redux将action和reducer的功能简化。对于同步的场景，mutation 中定义的其实就是reducer，mutation的名字作为action。vuex中将并未将action统一化，也有将action统一管理的。比如可以用create_action 来生成标志。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> unSubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = store.getState()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>实现一个简易版本的redux<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">const</span> listeners = [];</span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)  <span class="comment">// 取消订阅</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        <span class="keyword">this</span>.listeners.forEach(<span class="function"><span class="params">listen</span> =&gt;</span> listen())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        getState,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h3><p>createStore第二个参数设置applyMiddleware，applyMiddleware 大致理解成核心是compose，会返回一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(a, b =&gt; <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">    (...args) =&gt; fn1(fn2(...args))</span><br><span class="line">    (...args) =&gt; fn1(fn2(fn3(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFunc = compose(fn1, fn2, fn3)</span><br><span class="line">newFunc(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// applyMiddle</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> thunk = <span class="function">(<span class="params">next</span>) =&gt;</span> (action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> log = <span class="function">(<span class="params">next</span>) =&gt;</span> (action) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.end(<span class="string">'end'</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dispatch = compose(thunk, log)(store.dispatch) <span class="comment">// log(thunk(store.dispatch)) =&gt; (action)</span></span><br><span class="line">dispatch(action)  =&gt; log(action) =&gt; thunk(action) =&gt; log(action)</span><br></pre></td></tr></table></figure></p><p>完整版本的redux<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> middlewareApply = <span class="function">(<span class="params">...middleWares</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> reducer =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">        middleWares = middleWares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleWares(&#123;</span><br><span class="line">            dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args),</span><br><span class="line">            getState: store.getState</span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">const</span> dispatch = compose(...middleWares)(store.dispatch)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, storeEnhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(storeEnhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> storeEnhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> state</span><br><span class="line">    <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subScribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(listener)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line">    dispatch(&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        subScribe,</span><br><span class="line">        getState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> () =&gt; <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// next 理解为传递到下一个action处理器，其中dispatch也是一个处理器。</span></span><br><span class="line">    <span class="comment">// 不执行next表示中间件停止</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> action()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> log = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>, getState())</span><br><span class="line">    <span class="keyword">const</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>, getState());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, middlewareApply(thunk, log))</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: <span class="string">"ADD"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        store.dispatch(<span class="string">'ADD'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="vuex中的高级应用"><a href="#vuex中的高级应用" class="headerlink" title="vuex中的高级应用"></a>vuex中的高级应用</h3><ol><li><p>支持模块，默认情况下模块是全局注册的，在多个模块中同时注册相同的名字在触发时会被同时响应，添加namespace: true后会将所有的action 和 mutation添加模块前缀，触发时需要补上前缀(在命名空间下通过root: true 注册全局)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        foo: &#123;</span><br><span class="line">            namespace: <span class="literal">true</span></span><br><span class="line">            actions: &#123;  </span><br><span class="line">                add() &#123;  <span class="comment">// dispatch('foo/add', xxx)</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                del: &#123;   <span class="comment">// dispatch('del', xxx)</span></span><br><span class="line">                    root: <span class="literal">true</span>,</span><br><span class="line">                    handler() &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        boo: &#123;</span><br><span class="line">            actions: &#123;</span><br><span class="line">                del() &#123;&#125;  <span class="comment">// dispatch('del', xxx)  会同时触发两个模块</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>支持动态注册模块 registerModule()，适合于模块数据</p></li></ol><h3 id="vuex-插件机制和执行流程"><a href="#vuex-插件机制和执行流程" class="headerlink" title="vuex 插件机制和执行流程"></a>vuex 插件机制和执行流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> logPlugin = <span class="function">(<span class="params">pluginOptions</span>) =&gt;</span> &#123;  <span class="comment">// 日志组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">        store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;  <span class="comment">// 订阅每次mutation操作</span></span><br><span class="line">            <span class="built_in">console</span>.log(mutation.type, mutation.payload, state)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个持久化state的插件</span></span><br></pre></td></tr></table></figure><h3 id="vuex源码流程"><a href="#vuex源码流程" class="headerlink" title="vuex源码流程"></a>vuex源码流程</h3><ol><li><p>注册插件 Vue.use(Vuex)， 通过插件的形式在vue各个实例的beforeCreate前注入vuex.store 实例，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Vuex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> apply(Vue) &#123;</span><br><span class="line">        Vue.mixin(beforeCreate: VueInit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> VueInit = () &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.$parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$parent.$store   <span class="comment">// 如果当前是子节点，总是取父节点的，但是有个问题是如果当前节点还未挂载是没有$parent属性的，比如是new实例生成的的组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$options.store  <span class="comment">// 如果当前是根节点，取根节点传入的store</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行store构造函数，初始化各个state，各个mutation监听，各个action监听。生成dispatch函数和commit函数，再执行插件初始化，最后执行devtool</p><ol><li>installModule 安装当前module上的state和根state绑定(如果有),通过Vue.set() 添加新的子state到上级state上</li><li>forEachMutation， 将module中mutation绑定到根store中mutationMap上， 如果是命名空间还需要添加前缀。如果同名是推入数组</li><li>forEachAction 和 forEachGetter 同理</li><li>遍历子模块继续执行installModule</li></ol></li><li><p>初始响应式，将所有的state代理到new Vue({data: state})的实例上，getter代理到computed,这样获取state就会生成watcher进入dep，修改store中的state会触发所有的监听。</p></li></ol><p>插件的应用场景有如下几个。</p><ol><li>通过aop的方式处理action或者mutation的中执行错误，重写store.commit 或者 store.dispatch 函数实现</li><li>通过subscribe或者subscribeAction监听，实现日志或者持久化等操作，默认情况监听函数发生在action和mutation之前，通过参数prepend: true 添加到前面实现对state的再处理。</li><li>通过replaceState来初始化state，注意的是replace是替换根state，如果需要特殊的state，直接赋值即可</li><li>通过registerrModule 来注册一些业务外不关注的module</li></ol><h3 id="vuex-实例上需要关注的方法"><a href="#vuex-实例上需要关注的方法" class="headerlink" title="vuex 实例上需要关注的方法"></a>vuex 实例上需要关注的方法</h3><p>state, commit, dispatch, subscribe, subscribeAction, watch, registerModule, replaceState(storagePlugin中需要用到)</p><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h3&gt;&lt;p&gt;vuex是vue2中首选的状态管理工具，包括state、mutation、action 三大马车，大致是组件触发dispat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue中的高阶组件</title>
    <link href="https://blog.xunserver.cn/archives/f235dcea.html"/>
    <id>https://blog.xunserver.cn/archives/f235dcea.html</id>
    <published>2022-11-21T09:09:46.000Z</published>
    <updated>2022-11-21T09:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vue 中组件复用的方式有 mixin，extend，高阶组件和组合组件三种方式</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="如何创建一个全局单例组件"><a href="#如何创建一个全局单例组件" class="headerlink" title="如何创建一个全局单例组件"></a>如何创建一个全局单例组件</h4><p>const instance = new Vue(options), 通过这种方式能够实现部分命令方式调用组件。</p><h4 id="mixin-和-extend-的区别"><a href="#mixin-和-extend-的区别" class="headerlink" title="mixin 和 extend 的区别"></a>mixin 和 extend 的区别</h4><p>mixin 是对选项的混合，发生在生成 vue 实例之前，extend 是对 vue 实现继承，返回的是一个 vue 实例， 类似于 Object.create()</p><h4 id="HOC-实现一个-promise-组件"><a href="#HOC-实现一个-promise-组件" class="headerlink" title="HOC 实现一个 promise 组件"></a>HOC 实现一个 promise 组件</h4><p>代码中经常有请求一个 api，然后根据 api 显示不同逻辑的需求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-if=&quot;loading&quot;&gt;loading&lt;/div&gt;</span><br><span class="line">    &lt;div v-if=&quot;!loading&quot;&gt;</span><br><span class="line">      &#123;&#123; content &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content: &quot;&quot;,</span><br><span class="line">      loading: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getContent() &#123;</span><br><span class="line">      this.loading = true;</span><br><span class="line">      this.$api.get(&quot;/some&quot;).then((content) =&gt; &#123;</span><br><span class="line">        this.loading = false;</span><br><span class="line">        this.content = content;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过 HOC 将该组件的请求逻辑提取出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withPromise = <span class="function">(<span class="params">component, promiseFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        loading: <span class="literal">true</span>,</span><br><span class="line">        result: <span class="literal">null</span>,</span><br><span class="line">        error: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">      promiseFn()</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.result = data;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.error = error;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">const</span> loading = <span class="function"><span class="params">()</span> =&gt;</span> h();</span><br><span class="line">      <span class="keyword">const</span> error = <span class="function"><span class="params">()</span> =&gt;</span> h();</span><br><span class="line">      <span class="keyword">const</span> content = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        h(component, &#123;</span><br><span class="line">          loading: <span class="keyword">this</span>.loading,</span><br><span class="line">          content: <span class="keyword">this</span>.content,</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">"div"</span>, <span class="literal">null</span>, [</span><br><span class="line">        <span class="keyword">this</span>.loading ? loading() : <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">this</span>.error ? error() : <span class="literal">null</span>,</span><br><span class="line">        !<span class="keyword">this</span>.loading &amp;&amp; !<span class="keyword">this</span>.error ? content() : <span class="literal">null</span>,</span><br><span class="line">      ]);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newComponent = withPromise(view, getContent);</span><br></pre></td></tr></table></figure><p>上面实现还有几个问题没有解决</p><ol><li>请求函数的参数还没有，不能通过子组件自定义</li><li>子组件参数如果有变化，触发新的查询</li><li>外部组件对于子组件的 prop 等参数没有传递到子组件,包括插槽等</li></ol><p>第一个文件有两种方式拿到子组件的请求参数，第一个是静态的，通过在子组件选项或者定义上面绑定一个特殊的键值实现，或者将值绑定到子组件的实例上，通过 this.$refs 拿到子组件的实例后获取。</p><p>第二个问题需要在子组件上动态的添加 watch 函数，watch 函数监听子组件的查询参数并且触发的回调是父组件的请求函数</p><p>第三个问题，直接将 hoc 组件上的$attrs 和 $listeners 绑定到子组件的 props 和 $listeners 中，其中有个 v-bind 绑定的点，v-bind 总是会属性绑定到 props 中，对是否是 props 的处理，都是子组件的关心的，而不是父组件关心的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> withPromise = <span class="function">(<span class="params">component, promiseFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        loading: <span class="literal">false</span>,</span><br><span class="line">        content: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(component, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...this.attrs,</span><br><span class="line">          loading: <span class="keyword">this</span>.loading,</span><br><span class="line">          content: <span class="keyword">this</span>.content,</span><br><span class="line">        &#125;,</span><br><span class="line">        on: <span class="keyword">this</span>.$listeners,</span><br><span class="line">        ref: <span class="string">"component"</span>, <span class="comment">// 用于在mounted时获取实例</span></span><br><span class="line">        scopedSlot: <span class="keyword">this</span>.$scopedSlot</span><br><span class="line">      &#125;, <span class="keyword">this</span>.$children);  <span class="comment">// 注意 $children 和 $slot的区别</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getContent() &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">        promiseFn(<span class="keyword">this</span>.$refs.component.requestParams)</span><br><span class="line">          .then(<span class="function">(<span class="params">content</span>) =&gt;</span> (<span class="keyword">this</span>.content = content))</span><br><span class="line">          .finally(<span class="function"><span class="params">()</span> =&gt;</span> (<span class="keyword">this</span>.loading = <span class="literal">false</span>));</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.getContent();</span><br><span class="line">      <span class="keyword">this</span>.$refs.component.$watch(<span class="string">'requestParams'</span>, <span class="keyword">this</span>.getContent())</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newComponent = withPromise(view, getContent)</span><br><span class="line"><span class="comment">// &lt;newComponent onClick="xxx"&gt;xxxx&lt;/newComponent&gt;</span></span><br></pre></td></tr></table></figure><p>其实还有个问题，发现没有，就是还是没法将ref进行传递。 要想获取到子组件需要一直ref来使用。</p><h3 id="新增props处理"><a href="#新增props处理" class="headerlink" title="新增props处理"></a>新增props处理</h3><p>上面代码中对于props处理在每个HOC组件中都差不多类似。简单一点通过<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalProps = <span class="function">(<span class="params">vm</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        attrs: <span class="keyword">this</span>.vm.$attrs,</span><br><span class="line">        on: <span class="keyword">this</span>.vm.$listeners,</span><br><span class="line">        slotScopeds: <span class="keyword">this</span>.vm.$slotScopeds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h(compoennt, &#123;...normalProps(<span class="keyword">this</span>), <span class="attr">props</span>: &#123;&#125;&#125;, <span class="keyword">this</span>.$children)</span><br></pre></td></tr></table></figure></p><h2 id="组合优于HOC"><a href="#组合优于HOC" class="headerlink" title="组合优于HOC"></a>组合优于HOC</h2><p>组合的意识是通过compose的方式将原有的HOC  fn3(fn2(fn1))的方式变成compose(fn1, fn2, fn3)，将组件作为传递。如果withPromise没有参数，都不需要包装<br>compose(() =&gt; withPromise(), withLog)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vue 中组件复用的方式有 mixin，extend，高阶组件和组合组件三种方式&lt;/p&gt;
&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="https://blog.xunserver.cn/archives/e919cac4.html"/>
    <id>https://blog.xunserver.cn/archives/e919cac4.html</id>
    <published>2022-11-21T02:48:53.000Z</published>
    <updated>2022-11-21T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="axios-中间件"><a href="#axios-中间件" class="headerlink" title="axios 中间件"></a>axios 中间件</h3><p>axios将拦截函数处理成pormise的resolve和reject函数，通过promise链来完成中间件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        name: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        error: error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.use = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.interceptorsData.push(&#123;</span><br><span class="line">        resolve, reject</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    axios.interceptorsData.reduce(<span class="function">(<span class="params">promise, current</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(current.resolve).catch(current.reject)</span><br><span class="line">    &#125;)  <span class="comment">// 通过一次性构建promise链实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="vuex中间件"><a href="#vuex中间件" class="headerlink" title="vuex中间件"></a>vuex中间件</h3><p>vuex 中间通过aop的方式添加中间件，在原有处理逻辑上增加前置或者后置操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vuex.plugin = <span class="function">(<span class="params">&#123;before, after&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    vuex.dispatch.before(before)</span><br><span class="line">    vuex.dispatch.before(after)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        beforeFn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(thism, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="reduce中间件"><a href="#reduce中间件" class="headerlink" title="reduce中间件"></a>reduce中间件</h3><p>通过组合函数的形式，将函数的结果传入下一个函数，compose(fn1, fn2, fn3) = fn3(fn2(fn1()))，见store篇章</p><h3 id="koa中间件"><a href="#koa中间件" class="headerlink" title="koa中间件"></a>koa中间件</h3><p>有点像yeild的方式，每次调用中间件，都是把下一个中间的传入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">middleware.use(<span class="function">(<span class="params">ctx, next</span>)=&gt;</span> &#123;</span><br><span class="line">    ctx.xxx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.xxx)</span><br><span class="line">&#125;)</span><br><span class="line">middleware.run = <span class="function">(<span class="params">i=<span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = middleware.data[i]   <span class="comment">// 保存的所有中间件</span></span><br><span class="line">    <span class="keyword">if</span>(!current[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, middleware.run(i + <span class="number">1</span>)))  <span class="comment">// 通过这种方式实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本质上中间件是一个按照既定模板来实现流式编程的工具，通过这种方式，外部的代码可以侵入到内部实现去耦合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;axios-中间件&quot;&gt;&lt;a href=&quot;#axios-中间件&quot; class=&quot;headerlink&quot; title=&quot;axios 中间件&quot;&gt;&lt;/a&gt;axios 中间件&lt;/h3&gt;&lt;p&gt;axios将拦截函数处理成pormise的resolve和reject函数，通过pr
      
    
    </summary>
    
    
  </entry>
  
</feed>
