<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[umd,cmd,commonjs,esmodule学习教程]]></title>
    <url>%2Farchives%2F4986aa26.html</url>
    <content type="text"><![CDATA[amdamd Asynchronous Module Definition 异步模块化定义, requirejs实现了这套规范，思想是前置依赖，主要包括以下几个方法 require.config() 配置依赖 define([deps], callback)。定义模块 require([deps], callback)。引用模块12345678910111213141516171819202122232425262728293031// dependA.jsdefine([ 'dependB'], function(dependB) &#123; return &#123; start: function() &#123; document.write(dependB.name) &#125; &#125;&#125;);// dependB.jsdefine(function() &#123; return &#123; name: 'dependB' &#125;&#125;);// main.jsrequire.config(&#123; baseurl: '/static/umd', paths: &#123; "dependB": 'dependB', "dependA": 'dependA', &#125;&#125;)require(['dependA'], function(dependA) &#123; console.log(dependA) dependA.start()&#125;) 查看演示。requirejs 需要预先配置好所有依赖。不能动态获取所有 cmdcmd 通用模块定义（Common Module Definition）。seajs实现了这套规范，依赖是就近依赖，延迟执行。1234567891011121314151617181920212223// main.jsseajs.config(&#123; alias: &#123; dependB: './dependB.js' dependA: './dependA.js' &#125;&#125;)seajs.use('dependA')// dependA.jsdefine(function(require, exports, module) &#123; let dependB = require('dependB'); dependB.start()&#125;)// dependB.jsdefine(function(require, exports, module) &#123; 'use strict'; exports.start = function() &#123; document.write('dependB') &#125;&#125;); 查看演示。seajs通过正则解析，预先将当前文件的require的module加载，所以require可以同步加载 commonjscommonjs 是nodejs实现的一套模块化规范，和seajs类似。通过require、exports、module实现动态导入导出，不过不需要写define语句。123456// moduleA.jsconst a = require('A');exports.someA = function() &#123; console.log('someA')&#125; commonjs下，为什么我们可以在文件中使用dirname,filename, require，module,exports？nodejs会将js文件进行包裹。类似下面这种12345(function(exports, require, module, __dirname, __filename,...) &#123; exports.say = function() &#123; console.log('say') &#125;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[vercel白嫖教程]]></title>
    <url>%2Farchives%2Ff79d6af9.html</url>
    <content type="text"><![CDATA[简介vercel 可以托管静态资源，ssr，和serverless 函数。官网地址 https://vercel.com，首次使用需要邮箱注册，建议绑定github 账号，方便登录。 托管vue项目]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuex-db设计]]></title>
    <url>%2Farchives%2Fa8ae78e0.html</url>
    <content type="text"><![CDATA[分类系统存储，普通数据存储，用户数据存储，页面数据存储，页面用户数据存储，路由快照和路由用户快照。 系统存储用于存储用户打开的标签页，是否展开侧边栏，页面大小，主题等数据， 实现方案123456789101112import low from 'lowdb';import LocalStorage from 'lowdb/adapters/LocalStorage';import &#123; cloneDeep &#125; from 'lodash'const adapter = new LocalStorage('db'); // localstorage 名称const db = low(adapter);db.defaults(&#123; posts: []&#125;).write()db.get('posts').push(&#123; title: 'vue解密' &#125;).write() 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// util.db.jsimport low from 'lowdb';import LocalStorage from 'lowdb/adapters/LocalStorage';import utils from '@/utils'db .defaults(&#123; sys: &#123;&#125;, database: &#123;&#125; &#125;) .write()export default db/** * 初始化路径, 如果提供了默认值，会将默认值写入。如果已经存在值并且值校验出错，重新写入默认值 */export function pathInit(&#123; dbName = 'database', path = '' , user = user, validator = () =&gt; true, defaultValue = '' &#125;) &#123; const uuid = utils.cookies.get('uuid') || 'ghost-uuid'; const userPath = user ? `user.`$&#123;uuid&#125; : 'public'; const keyPath = path ? `.$&#123;path&#125;` : '' const finalPath = `$&#123;dbName&#125;.$&#123;userPath&#125;$&#123;keyPath&#125;` const value = db.get(finalPath).value(); if(value === undefined || !validator(value) ) &#123; db.set(finalPath, defaultValue).write() &#125; return finalPath;&#125;export function dbSet(&#123; dbName = 'database', path = '', user = true, value = ''&#125;) &#123; db.set(pathInit(&#123; dbName, path, user, &#125;), value) .write()&#125;/** * 获取db值，如果没有值，设置一个默认值并返回 */export function dbGet(&#123; dbName = 'database', path = '', user = true, defaultValue = ''&#125;) &#123; return cloneDeep(db.get(pathInit(&#123; dbName, path, user, defaultValue &#125;)).value())&#125;/** * 获取一个db对象，可以执行set, write操作 */export function database(&#123; dbName = 'database', path = '', user = true, defaultValue = '', validator = () =&gt; true&#125;) &#123; return db.get(pathInit(&#123; dbName, path, user, defaultValue, validator &#125;))&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// store/module/db.jsimport router from '@/router';import &#123; cloneDeep &#125; from 'lodash'import &#123; database as getDatabase, dbGet, dbSet &#125; from '@/utils/util.db.js'export default &#123; namespace: true, actions: &#123; set(ctx, &#123; dbName, path, value, user = false &#125;) &#123; return dbSet(&#123; dbName, path, value, user &#125;) &#125;, get(ctx, &#123; dbName, path, defaultValue, user = false &#125;) &#123; return dbGet(&#123; dbName, path, defaultValue, user &#125;) &#125;, database(ctx, &#123; user = false, defaultValue = &#123;&#125; &#125;) &#123; return getDatabase(&#123; user, defaultValue &#125;); &#125; databaseClear(ctx, &#123; user = false &#125;) &#123; return getDatabase(&#123;user, validator: () =&gt; false, defaultValue: &#123;&#125;&#125;) &#125; databasePage(ctx, &#123; user = false, basis = 'fullpath'&#125;) &#123; return getDatabase(&#123; path: `page.$&#123;router.app.$route[basis]&#125;`, user, defaultValue: &#123;&#125; &#125;) &#125; databasePageClear(&#123; user = false, basis = 'fullpath', &#125;) &#123; return getDatabase(&#123; path: `page.$&#123;router.app.$route[basis]&#125;`, user, validator: () =&gt; false, defaultValue: &#123;&#125; &#125;) &#125; &#125;,&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack-library]]></title>
    <url>%2Farchives%2F23360043.html</url>
    <content type="text"><![CDATA[###]]></content>
  </entry>
  <entry>
    <title><![CDATA[js编码规范]]></title>
    <url>%2Farchives%2Fe960579a.html</url>
    <content type="text"><![CDATA[Javascript 编码规范[TOC] 术语 原则: 必须坚持的指导思想 建议: 需要加以考虑的约定 不好示例: 反面教材，里面的都是错误示范 推荐示例: 正面教程，可以按照里面示例类推 命令文件建议: 不使用index文件实现逻辑，index用于聚合导出。避免componentA/index.js，然后在index.js 写component的逻辑，正确的写法是 componentA/componentA.js。 componentA/index.js 仅作导出。当你在浏览器resource查找文件就知道了-__-。 命名原则原则: 源文件编码格式（包括注释）必须是UTF-8大家一定被乱码的解释折磨过…. 原则: 方法、变量需要一个好名字好的名字有包括不局限以下特征: 清晰表达意图：使用有描述性的型单词，避免使用单个字母，或者自创缩写来表达，比如 let lastDay 比 let ld 要好 必须使用英文单词，不允许出现中文拼音（约定熟成除外）。中文拼音在多音字表现上会有歧义，而且不太利于团队以后成成长 避免误导性命名，有误导的命名比表达不清晰还要危险，比如 let nameArray 不是一个array类型，而是一个字符串。 能区分出意思，建议不要在变量后面加上data，info，object等一般意思的词。比如productInfo和productData有什么区别。 类原则: 构造函数、类命名都是用大驼峰推荐示例12function Kind() &#123;&#125;class People() &#123;&#125; 不好示例12function kind() &#123;&#125;class people() &#123;&#125; 原则: 方法命名使用动词、动宾结构，并遵守驼峰原则格式如下 get + 非布尔属性名 is + 布尔属性名 set + 属性名 has + 名字\形容词 动词 动词 + 宾语不好的示例12345function type() &#123;&#125;function Finished() &#123;&#125;function visible() &#123;&#125;function DRAW() &#123;&#125;function keyListener() &#123;&#125; 推荐示例:12345function getType() &#123;&#125;function isFinished() &#123;&#125;function setVisible() &#123;&#125;function draw() &#123;&#125;function addKeyListener() &#123;&#125; 原则: 方法名不能过长影响可读性方法名不能超过15个字符，可以采用去掉元音字符或者业界约定的缩写来表示。比如 function getCustomerInfomation() {} 可以改成 function getCustomerInfo() {} 建议: 私有属性或者方法， 建议以下划线_开头变量原则: 变量名遵循驼峰风格, 首字母大写，后续每个单词小写建议: 避免使用否定的布尔变量名对于否定的布尔变量名，当使用逻辑非运算符时，会出现双重否定，对阅读造成阻碍，比如!isNotError。 不好示例:12const isNotError = true; // 到底有没有错const inNotFinished = false; // 结束没有 推荐示例12const isError = false;const inNotFinished = true; 建议: 缩写词应该全部大写或者小写，不要混搭。原则: 不要用保留字作为键名或者变量名，使用同义词。为了兼容未来，虽然在语法上使用保留字作为键名是可以允许的。可以这样改class =&gt; klass， default =&gt; defaults，private =&gt; hidden 原则: 常量使用全部大写并且用下划线_分隔 不要魔鬼数字，比如错误码 response.code === &quot;0000&quot; || response.code === 5, 这种代码，不熟悉的人需要花时间去理解 5 是什么，&quot;0000&quot; 又是什么。 不要魔鬼常量，比如const NUM_FOUR = 4这种脱了裤子放屁行为;推荐示例123456const SUCCESS_CODE = '0000';if (response.code === SUCCESS_CODE) &#123; ....&#125;const MAX_GOODS_NUM = 4; 注释注释原则最好的注释就是没有注释注释的作用是解释代码。如果变量命令足够清晰，代码结构好就不需要注释。举个例子1234// 大于65岁并且是职工，或者性别是女可以领福利if ((person.flag === 0 &amp;&amp; person.age &gt; 65) || person.sex === 1) &#123; ....&#125; 别人审阅读代码时需要看注释才能知道if语句中含义。可以换成如下写法123if (isBenefits(person)) &#123; ...&#125; 直接通过阅读代码就可以理解到意思，如果需要深读判断逻辑，同时隔离的函数也方便阅读。 原则: 注释的作用是帮助理解代码，而不是误解代码无用的注释，过期的注释及时清理掉。如果一个注释和代码实现不一致，那么enummmm….。 原则: 不要出现todo代码，todo代码自己在个人备忘录记录。大家习惯把部分代码标记上todo，然后推到公共分支。如果某一天你不接手这个项目了，后面的人看到你写的todo，他到底需不要todo，这是个问题。 建议: 不要临时注释屏蔽代码，直接删除。临时注释屏蔽部分代码是大部分人常见的操作，可以直接删除。如果后续需要找回，git来帮忙。否则后面的人接手一看，这个代码屏蔽注释了，不知道啥原因，不敢动，久而久之，x山。 原则: 不要用注释记录文件修改信息都用git了， 不要在文件开头去记录xxx多久修改了啥。git信息里面都有。 注释风格原则: 单行注释使用 //, 多行注释 /** */, 文件注释用 / \/推荐大家使用jsDoc风格的注释规范 原则: 注释和描述的代码相邻，放在代码上方，并且和代码的缩进一致。原则: 注释要和上方的代码块有间隔，间隔一行。 // 后空两格。排版风格排版可以从下面的维度出发，给出每个维度的建议项和原由，各团队可以自行商议。 建议: 团队内风格应该保持一致，大家商量，抛弃个人喜好建议: 团队内将风格固化到IDE中，通过eslint，stylelint, editorConfig等来保证一致性。缩进原则: 禁止使用制表符作为缩进制表符在不同IDE或者代码阅读器上面表现的风格不一致，有可能产生对齐错乱的问题。空格在不会有这样的问题。我们在开发中常使用tab键实现缩进，需要把tab设置为缩进空格。 建议: 缩进使用2个空格缩进。缩进过大，在嵌套过深的情况，需要拖动横向滚动条条才能阅读代码，不方便阅读。 换行建议: 超长代码需要换行，换行时操作符放在前面推荐示例12345const resultA = xxx ? 'a' : 'b';const resultB = xxxxxxxxxxxxA &amp;&amp; xxxxxxxxxxB &amp;&amp; xxxxxxxxxxC 建议: 函数参数尽量在同一行，对于超长的场景每个参数独占一行。推荐示例1234567function someFunction(arg1, arg2, arg3, arg4) &#123;&#125;function someLongerFunction( xxxxxxxxxxA, xxxxxxxxxxB, xxxxxxxxxxC, xxxxxxxxxxD) &#123;&#125; 建议: 对象字面量超过4个，都应该换行不好的示例1const airticle = &#123; title: '中国之声', author: 'some people', date: '2012-02-01', preview: 999, total: 334343 &#125;; 推荐示例1234567const airticle = &#123; title: '中国之声', author: 'some people', date: '2012-02-01', preview: 999, total: 334343 &#125;; 建议: 链式调用对象时，一行最好不超过4个调用，可以改成每个独占一行。不好示例1someInstance.queryAll().find('classA').forEach((item) =&gt; handle(item)).map(item =&gt; item.name).end() 推荐示例123456someInstance .queryAll() .find('classA') .forEach((item) =&gt; handle(item)) .map(item =&gt; item.name) .end() 建议: else 和 if尾括号放在同一行，else if同理推荐示例12345if () &#123; ....&#125; else &#123; ....&#125; 不好示例123456if () &#123;&#125;else &#123;&#125; 建议: 设置每行的最大长度，超过最大行数需要换行。阅读代码最喜欢时从上到下阅读，不喜欢横向滚动条。推荐每行最大长度不超过180 建议: 条件语句过长的，可以将每个条件都放入当都一行，操作符放在开头空行原则: 不同的逻辑块之间空一行相对独立的代码块之间考虑换行（一般这个时候你需要提炼函数了-_-）。 建议: class中，方法和方法之间需要换行。不同逻辑区间的属性之间换行。12345678910111213141516171819class People &#123; age: 36, sex: 'male', career: 'teacher', isFlag: false, isRegisted: true children: [], parent: &#123;&#125; checkValid() &#123; ... &#125; handleError() &#123; ... &#125;&#125; 原则: 方法体、块语句、类的开始或者末尾不要有空行。建议: 一般情况下，不要使用连续空行。空格建议: 关键字周围空格一致性 在保留字(if, for while) 和左括号( 之间添加一个空格 else catch 与 关闭花括号 } 之间添加一个空格 在任何打开花括号前添加一个空格, (函数参数和模板中去除外) 1234// 下面这三种情况除外function too(&#123; name &#125;) &#123;&#125;function foo([ name ]) &#123;&#125;const str = `#$&#123;s&#125;`; 在任何三元或者二元操作符的两侧增加一个空格 数组和函数参数逗号, 后面添加一个空格，前面不要增加空格。 ; 前面不要空格 单行 {} 内侧需要一个空格 1const objA = &#123; name: 'xxx', total: 2 &#125; 数组[]内侧不要有空格 [a, b, c]，不要[ a, b ]。 禁止出现多个空格，除注释和缩进外。 花括号建议: 总是给代码执行体添加{}while, if, for, do，即使执行语句只有一行。1if (result) foo++; 上面这种看着很酷，如果需要多写一个语句，就需要三行的改动，如果我们事先添加好花括号。改动只有一行，出错的机率大幅度减低。血的教训——__——。 建议: 花括号要和语句在一行123class Xxx &#123; ...&#125; 不好示例1234class Xxx &#123; ....&#125; 建议: 对象字面量和数组中使用拖尾逗号,12345const obj = &#123; keyA: 'xxx', keyB: 'xxx', // 拖尾逗号&#125;const someArray = ['xxxA', 'xxxB',] 建议: 每行代码句后添加分号。123456789101112// 这个代码会被解析 some = 'xxx'; 而不是 some = getSome;function getSome(arg1) &#123; return arg1; &#125;const some = getSome(()=&gt; &#123; return 'xxx'&#125;)()// 这个代码会被解析成 return; &#123; .... &#125;;return &#123; ....&#125; 建议: 单文件长度最好不要超过1500行，尽可能的考虑拆分建议: 单个方法长度不要超过50行建议: 圈复杂度不要超过20建议: 块嵌套深度不超过4层。if语句判断等建议: 回调深读不超过4层。变量原则: 优先使用const，其次let。非特殊场景不使用var原则: 在使用地方申明变量，且尽快初始化原则: 每行申明一个变量，结构和for循环除外 方便阅读 在debug模式下，可以按行阅读。单行代码无法优美的查看（大雾）。不好示例1const varA = 'nb', B = 123; 推荐示例12345678const varA = 'nb';const varB = 123;for (let i = 0, len = arr.length; i &lt; len; i++) &#123; ...&#125;const [varA, varB] = ['nb', 123] 建议: 申明阶段禁止连续赋值建议: 变量不需要使用undefined来初始化未赋值的变量会默认有一个undefined的初始值(????) 建议: 非特殊情况一般使用基础类型的字面量来初始化，而不是封装类型。不好的示例1234567891011121314const stringA = new String('A');const numberB = new Number(123);console.log(numberB + 1) // 124;// 会有语义上的不明确const arrA = new Array(3, 4, 5); // [3, 4, 5]const arrA = new Array(4) // [empty * 4] 语义不明确const arrC = new Array('4') // ['4'] // 语义不明确// 考虑可读性和冗余性，对象也是const objA = new Object(&#123; keyA: 'longfor', keyB: 123&#125;) 建议: 内部作用域变量不要覆盖外部作用域变量会导致更深层次的代码无法获取到想要的变量，在后续变更操作中，增加出错风险。 不好示例12345678910111213function a() &#123; const aa = 1; function b() &#123; const aa = 2; function c() &#123; // 如果c函数需要知道a函数中aa咋办??????? console.log(aa) &#125; c() &#125; b()&#125;a() 参数建议: 方法的参数不超过5个超过5个的参数，将逻辑关联的参数放入对一个对象中。 建议: 函数参数指定默认参数，不是使用 || 指定默认参数不好示例1234// 如果 a = false 或 a = ''；enummmmm.....function test(a) &#123; a = a || true&#125; 建议: 永远不要改变参数的值。 如果函数中新增加一个功能，需要用到参数的原始值，想要一下需要改动的地方有多少。 如果参数是引用传参，改变参数的属性会导致修改传入外部，造成一些不必要的问题。建议: 默认参数放在最后面默认参数放在前面，需要写undefined来占位，放在后面可以不用。不好示例12function test(argA = &#123;&#125;, argB) &#123;&#125;test(undefined, 'test'); 推荐示例12function test(argB, argA = &#123;&#125;) &#123;&#125;test('test'); // cool....。 建议: es6不要使用arguments, 请rest替代 箭头函数不存在arguments arguments只是类数组，操作不方便 建议: 对于外部API，始终对参数进行校验。为了保证健壮性，防御性编程不可少(大雾) 建议: 优先使用参数结构申明与实现原则: 函数申明一致性函数有表达式声明和function申明。有如下区别 function申明会将申明提升到作用域顶级，可以在申明前调用 表达式申明不会提升，在申请前使用会出错(not a function)团队应该选择统一的风格来实现，推荐使用表达式申明。 建议: 匿名函数优先使用箭头函数普通函数和箭头函数性能和开销没有太大差别，但是匿名函数没有this的困扰(^-^)。 原则: 箭头函数参数风格一致性有下面有两种风格 只有一个参数的情况下去参数括号。 1const test = argA =&gt; argA * 2; 总是添加参数括号 1const test = (argA) =&gt; argA * 2; 推荐第二种方式，没有花括号的方式会有阅读上的停顿。 原则: 箭头函数return风格一致性同上，方法体只有一个return 语句，是不是需要添加花括号。推荐总是添加花括号，丑一点但是方便断点调试。 建议: 函数有多个返回参数时使用对象解构优先使用对象结构而不是数组解构。不然冷不丁出现这种const [a,,b,,c] = [1,1,1,1,1,1] 类与对象类建议: 优先采用class定义类 class关键字定义类简洁，而且逻辑更易于阅读。 不仅仅时语法糖，class的构造函数有特殊的内部属性[[IsClassConstructor]]: true, 可以防止被作为普通函数使用。 String(SomeClass) 会得到什么? – class SomeClass {} 建议: 使用extends来实现继承。原则: 构造函数中禁止在super() 前调用this或者super.xx建议: 在构造函数中申明所有的属性和方法。不要在类实例化后再动态添加属性, 如果一个属性实在执行时被赋值的，也需要先申明，方便VM优化。 字符串建议: 优先使用单引号当你创建一个包含html代码时候就知道了 建议: 字符串使用模板字符串可阅读性，一堆 + 很难阅读，特别时字符串中带有 + 时。 原则: 不使用\字符串行连续符号。当你在\ 后面加个空格时，找代码会找的你怀疑人生。 直接写在一行，大部分IED会处理用多行来显示一行。 数组建议: 添加元素使用数组的push方法，而不是索引赋值数组的length有长度限制，push会检查并抛错，赋值没有。极限情况下出现length不更新问题。 建议: 不在数组定义非数字索引有特殊场景需要添加，建议替换成map或者set。 建议: 数组遍历优先使用数组上方法建议: 除特殊场景， 不要使用for in遍历数组。建议: forEach中不要对数组进行增加删除操作对象建议: 对象字面量属性名统一风格，不加引号。非特殊场景不使用混搭风格不好示例1234567const objA = &#123; 'name': 'AAA', title: 'welcome to AAA', // 特殊情况 'some-one': '123'&#125; 建议: 尽量在申明时将所有属性申明好，少动态添加。建议: 对象字面量中，方法使用简写。推荐示例123456const objA = &#123; key: 'a', getKey() &#123; return this.key; &#125;&#125; 不好示例123456const objA = &#123; key: 'a', getKey: function() &#123; return this.key; &#125;&#125; 建议: 推荐使用对象字面量中使用简写属性推荐示例1234567const key = 'a'const objA = &#123; key, getKey() &#123; return this.key; &#125;&#125; 不好示例1234567const key = 'a'const objA = &#123; key: key, getKey() &#123; return this.key; &#125;&#125; 建议: 使用.号来访问属性方法，只有动态情况或者数字索引下采用[]访问原则: get 和 set 必须成对出现，否则没有意义。如果只有get，表示该属性只可读，不可写。如果只有set，表示该属性只可写，不可读。 原则: 禁止在对象上使用Object.proptotype 的内置属性，用call代替如果一个来自外部的JSON resData = { hasOwnProperty: 1 }; 如果调用resData.hasOwnProperty() 就会出现安全风险。用Object.proptotype.hasOwnProperty.call(resData) 则不会。 建议: for in循环对象需要约束for in 会将原型链上的属性包括进来，建议使用Object.prototype.hasOwnProperty() 过滤，或者直接使用Object.keys转成数组循环。 建议: 严禁对内置的类型添加修改属性方法。常见在String.prototype 上面添加方法等。 运算和表达式条件表达式建议: 条件表达式中，变量在先，表达式在后。有种观点时变量在后面，为了防止 if (a = 1) {}这种低级错误出现。不过为了可阅读性，我们推荐变量的在前面，配合现在IDE，可以避免这种错误。 建议: 总使用 === 和 !==， 不使用 == 和 !===和!=对于新人来说难以掌握，而且也不利于阅读。所有 == 和 != 的场景都可以用 === 和 !== 表示出来。 建议: 条件语句尽量简单不好示例12if (isValid === true) &#123;&#125;const isFinished = condition ? true : false; 建议: 不要在一个复杂的条件表达式最前面添加否定!不好示例123if (!((person.flag === 0 &amp;&amp; person.age &gt; 65) || person.sex === 1)) &#123; // 来读读这个是啥意思 ....&#125; 需要否定的地方，用数学知识处理一下，解开括号。原则是 AND-OR互换，!抵消。括号加在 OR 中，从左到右依赖删除括号。对!(!conditionA || !conditionB &amp;&amp; conditionC) 举例。 AND-OR互换: !!conditionA &amp;&amp; !!conditionB || !conditionC ! 抵消: conditionA &amp;&amp; conditionB || !conditionC 括号加在 OR 中 conditionA &amp;&amp; (conditionB || !conditionC) 观察是否能够消除括号，这个例子不能消除括号。建议: 非特殊场景，if else 条件判断不要否定在前 建议: 禁止使用嵌套的三元表达式嵌套的三元表示式需要用栈的思维来阅读。建议多写几个if替代。 建议: 混合条件表示式，使用括号来标记运算顺序。建议: 每个switch语句总是有default，即使default里面为空防御性编程意识不可少，当定义了default，就会想switch的错误场景。 建议: 非特殊场景，总是给每个case添加break建议: 总是给每个case的执行体添加花括号{}switch中，每个case都在switch代码块，作用域共享。为了防止出错，建议给每个case添加花括号形成块作用域。 推荐示例123456switch (code) &#123; case: '0000': &#123; .... break &#125;&#125; 正则原则: 正则表达式中不要出现连续空格不好示例1const testReg = /test test/; // 你能直接知道是几个空格吗 推荐示例1const testReg = /test &#123;4&#125;test/ 建议: 总是使用具名捕获组比如 &#39;web-doc&#39;.match(/-(?&lt;customName&gt;\w)/).groups，可以得到 { customName: &#39;d&#39; } 一些特性作用域建议: 不要在顶层作用域申明函数变量一般情况下，大部分人会忘记顶层作用域就是全局作用域。如果要申明，应该显示的申明到windows或者global上。 建议: 谨慎添加window上属性。尽可能用命名空间实现，给windows挂载一个特殊的属性，剩下的挂在在这个属性下面。参考jquery 或者underscore 数字建议: 禁止省略小数点前后的0好好写嘛 不好示例123const numA = .5;const numB = 2.;const numC = -.9; 原则: 使用isNaN() 来检查NaN异常建议: 异常的原则 异常总是Error子类或者Error 优先考虑内置异常， 不满足情况下使用自定义异常 捕获的异常不处理需要注释说明 建议: promise中reject总是返回异常，而不是其他;Promise rejct 返回 Error可以看到错误栈，方便调试，断点神器。 异步原则: 不要 return await写法直接return，async 本身会返回Promise对象。 杂谈建议: 一般不使用eval，如果需要，务必需要多人评审。原则: 防止出现隐形evalsetTimeout 和 setInterval第一个参数为字符串时，和eval一样。不过大部分浏览器会拦截这个漏洞。 原则: 非特殊场景不用withwith可以提升性能，如果掌握不好会有一定的安全风险，比如在语义不明的情况，开发可能错误的执行了某个对象上的方法。建议团队评估后使用。 建议: 类型转换都用显示的方法处理，不要短符号实现。 布尔类型: 用 Boolean(numA) 代替 !!numA 数字类型: 用 Number(strA) 代替 +strA 其余类推 原则: DOM卸载时，务必移除事件绑定。不然哪天内存泄漏都找不到原因，引用计数GC的浏览器有这个问题。 原则: 及时清理定时器和延时器同样会导致内存泄漏，还要]]></content>
  </entry>
  <entry>
    <title><![CDATA[github-action]]></title>
    <url>%2Farchives%2F355afdd9.html</url>
    <content type="text"><![CDATA[术语workflow: 一次持续集成 job: 一次workflow包含一个或者多个job，在没有依赖的情况下，多个job异步执行 step: 每个job 由多个step组成，同步执行 action: 每个step可以执行一个或者多个action 简单例子12345678910111213141516171819202122232425262728name: github pageson: push: branches: - masterjobs: build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@master - name: build uses: actions/setup-node@v1 with: node-version: '10.x' - run: | npm install npm run hexo g - name: deploy uses: peaceiris/actions-gh-pages@v2.5.0 env: ACTIONS_DEPLOY_KEY: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; EXTERNAL_REPOSITORY: xunserver/xunserver.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue查漏补缺]]></title>
    <url>%2Farchives%2F98f4c1bc.html</url>
    <content type="text"><![CDATA[动态编译 Vue.compile(str)完整版情况可以将模板加载成render函数，实现远程加载功能 阉割版的响应数据 Vue.observable(obj)创建一个可响应对象，目前我们的可以响应对象在data，watch,computed 中， 这个阉割版的可以响应对象用于渲染函数和计算属性中 watch可以监听一个数组，也可以是一个方法123456789101112watch: &#123; a: 'someMethod' // vm实例中方法, b: [ &#123; handler: function () &#123;&#125;, deep: true, immediate: true &#125;, function () &#123;&#125;, 'someMethod' ]&#125; 插槽新功能 v-slot v-slot:slotName 指定具名插槽 v-slot在单个插槽的情况下可以绑定非template，其余必须绑定到组件上 v-slot可以简写为#, 认插槽需要#defaultv-bind 支持对象绑定, 动态绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 绑定一个 attribute --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定一个全是 attribute 的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt; v-pre 手动指定这个元素和其子元素不需要编译。直接展示原始标签不需要响应式的数据记得冻结，比如表格数据1234567891011121314151617&lt;script&gt; export default &#123; data() &#123; retur: &#123; data: [] &#125; &#125;, async beforeMounted() &#123; this.data = await this.getData() &#125;, methods: &#123; async getData() &#123; return Object.freeze(someData) &#125; &#125; &#125;&lt;/script&gt; 静态内容尽量使用template模板渲染， 不使用jsx或者render函数。提高性能complie 会优化render 函数，直接写没有优化过程。 组件会在每个生命周期触发事件，比如’hook:mounted’ 这种。尽量使用受控组件，优先选择函数组件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[filerun搭建和配置]]></title>
    <url>%2Farchives%2Fcecf9a65.html</url>
    <content type="text"><![CDATA[安装docker参考docker安装和配置 1234$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun$ sudo systemctl enable docker #开机启动$ sudo systemctl start docker # 打开服务 安装docker-compose123$ sudo curl -L https://download.fastgit.org/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose$ chmod u+x /usr/local/bin/docker-compose 修改docker-compose.yml 配置12345678910111213141516171819202122232425262728293031323334version: '2'services: db: image: mariadb:10.1 environment: MYSQL_ROOT_PASSWORD: root # 替换 MYSQL_USER: filerun # 替换 MYSQL_PASSWORD: filerun # 替换 MYSQL_DATABASE: filerun # 替换 volumes: - /root/filerun/db:/var/lib/mysql web: image: afian/filerun environment: FR_DB_HOST: db FR_DB_PORT: 3306 FR_DB_NAME: filerun # 替换 FR_DB_USER: filerun # 替换 FR_DB_PASS: filerun # 替换 APACHE_RUN_USER: www-data APACHE_RUN_USER_ID: 33 APACHE_RUN_GROUP: www-data APACHE_RUN_GROUP_ID: 33 depends_on: - db links: - db:db ports: - 80:80 volumes: - /root/filerun/html:/var/www/html # 挂载到宿主的目录 - /root/filerun/user-files:/user-files # 网盘文件，需要将CIFS挂载到此目录 挂载CIFS硬盘选择CIFS共享，不是NFS，NFS权限难搞。1$ mount -t cifs -o username=share,password=share,gid=tape,uid=33 //bijiben1.home/share /root/filerun/user-files 修改/etc/fstab 实现开机自动挂载1//bijiben1.home/share /root/filerun/user-files cifs username=share,password=share,gid=tape,uid=33 0 0 启动docker-compose docker-compose up -d 配置filerun 初始化用户密码是superuser/superuser 中文界面需要自行下载语言包上传。 语言包]]></content>
  </entry>
  <entry>
    <title><![CDATA[let-encrypt 域名证书申请]]></title>
    <url>%2Farchives%2F63bb46e5.html</url>
    <content type="text"><![CDATA[下载certbot-autowget https://dl.eff.org/certbot-auto chmod a+x ./certbot-auto 单域名证书申请新建nginx 配置1234567891011server &#123; listen 80; server_name cloud.jiaxuan.site; charset utf-8; root /opt/www/cloud.jiaxuan.site; index index.html index.htm; access_log /var/log/nginx/cloud.jiaxuan.site_access.log; error_log /var/log/nginx/cloud.jiaxuan.site_error.log;&#125; 申请单域名证书 ./certbot-auto certonly –email 1358925129@qq.com –domains cloud.jiaxuan.site]]></content>
  </entry>
  <entry>
    <title><![CDATA[hyper-v]]></title>
    <url>%2Farchives%2F320b54d3.html</url>
    <content type="text"><![CDATA[下载固件下载lede 虚拟机专用固件, 下载名称为generic-squashfs-combined-efi.vmdk的固件。 转盘使用转盘工具 StarWind Software V2V Image Converter。转盘工具可以转换.img .vmdk .vhd .vhdx格式，将固件转换成 vhdx 格式镜像，或者并且支持动态动态扩展大小的格式。 虚拟交换机配置配置 Wan新建虚拟交换机 =&gt; 外部网络 =&gt; 选择需要绑定的网卡 =&gt; 取消允许管理操作系统共享此网络适配器 如果取消允许管理操作系统共享此网络适配器，宿主机不能通过此网卡上网，必须要通过内部 lan =&gt; 软路由 =&gt; wan , 共享情况下是直接 =&gt; wan 如果需要多拨的，重复上述步骤 配置 lan-x新建虚拟交换机 =&gt; 外部网络 =&gt; 选择需要绑定的网卡 =&gt; 取消允许管理操作系统共享此网络适配器 重复上述步骤添加其余 lan 虚拟机配置 虚拟机存储位置指的是虚拟机相关的配置保存路径，不是磁盘路径 虚拟机代数，已知 lede 可以用二代；高恪，爱快二代显示镜像未找到，暂无方法，只能用第一代，第二代可以用 efi 镜像 第一代第二代磁盘使用不一致，第二代只能用 scsi 控制器添加硬盘驱动器。 硬盘驱动器第一代选择 IDE 控制器 1 虚拟磁盘选择转盘后的文件，使用文件前，先扩容到 2G。虚拟磁盘理解成一个隔离的真实磁盘 网卡配置按照 内部网络 =&gt; lan =&gt; wan 口的形式配置。外部网络需要在高级设置中启动 mac 地址欺骗 取消安全性检查 bios 启动顺序，使用硬盘优先 最好禁用检查点 启动设备使用 192.168.1.1 访问软路由管理界面。因为添加了内部 lan，否则只能设置外部 lan 网卡的网关到 192.168.1.1 直通教程 查看所有设备 Get-PnpDevice 获取 InstanceId Get-PnpDevice -FriendlyName “设备名称”| select InstanceId 禁用设备 Disable-PnpDevice -InstanceId “设备 InstanceId” 获取设备 LocationPaths Get-PnpDeviceProperty -InstanceId “设备 InstanceId” -KeyName DEVPKEY_Device_LocationPaths 通过 LocationPaths 下线设备 Dismount-VMHostAssignableDevice -Force -LocationPath “设备 LocationPaths” 查看被下线的设备 Get-VMHostAssignableDevice 通过 LocationPaths 添加设备到虚拟机 Add-VMAssignableDevice -VMName “虚拟机名称” -LocationPath “设备 LocationPaths” 可以直接通过 设备管理器 =&gt; 设备 =&gt; 设备详细信息查看 InstanceId 和 LocationPaths。LocationPaths=位置路径 InstanceId=设备实例路径 踩坑事项 外部网络不能并用，所以不能同一个外部网络不能分配到两个虚拟机上。 外部网络设备互斥，不能讲同一个设备分配到两个外部网络上。 出现 boot loader 加载失败，原因是没有禁用安全性启动 出现镜像未找到原因是，部分固件不支持二代虚拟机，需要用第一代的形式]]></content>
  </entry>
  <entry>
    <title><![CDATA[react和vue的生命周期]]></title>
    <url>%2Farchives%2F27ee65e3.html</url>
    <content type="text"><![CDATA[vue beforeCreate （ &lt;=初始化事件和生命周期） created （&lt;= prop 注入完成） beforeMount 编译 template 模板或者 render， 并收集依赖 mouted （挂载到 dom 上面） beforeUpdate =&gt; 不能在里面更新 data =&gt; 开始 diff render beforeDestory =&gt; 解除绑定，解除事件，销毁子组件。 destoryed =&gt; 删除完回调 react初始化阶段 defaultProp =&gt; prop initState componentWillMount render componentDidMount 运行阶段react 的变化需要自己手动更新，包括 props 和 state 的变化 props 变化通过 componentWillReceiveProps 获得， state 的变化通过 setState 方法来实现 均会触发 shouldComponentUpdate 钩子，如果钩子返回 false 表示不更新。然后会触发 componentWillUpdate 构造重新调用 render 函数， 渲染界面触发 componentDidUpdate 钩子， 销毁钩子 componentWillUnmount]]></content>
  </entry>
  <entry>
    <title><![CDATA[react开发采坑之路]]></title>
    <url>%2Farchives%2F5bca6e8e.html</url>
    <content type="text"><![CDATA[父组件给子组件设置 className 也需要通过 props 传递1&lt;div className=&#123;`$&#123;this.props.className&#125; otherClassName`&#125;&gt; jsx 属性命名原则React DOM 使用 camelCase（小驼峰命名）来定义属性的名称]]></content>
  </entry>
  <entry>
    <title><![CDATA[英语学习]]></title>
    <url>%2Farchives%2F3f43dc72.html</url>
    <content type="text"><![CDATA[I come across below behavior 我遇到了下面这些问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[ts+react环境搭建]]></title>
    <url>%2Farchives%2F3a1fbb86.html</url>
    <content type="text"><![CDATA[package.json 初始化 npm init webpack 安装配置webpack 安装 npm i -D webpack webpack-cli 配置文件 新建config/base.config.js 1234567891011121314151617const path = require("path")module.exports = &#123; entry: &#123; main: path.resolve(__dirname, "../src/main.tsx") &#125;, output: &#123; path: path.resolve(__dirname, "../dist"), filename: "[name]-[hash].js" &#125;, module: &#123; rules: [ &#123; test: /\./ &#125; ] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习scss]]></title>
    <url>%2Farchives%2Ff800a64.html</url>
    <content type="text"><![CDATA[变量 用于定义属性值（不能是属性名） 美元符$开头，具有块级作用域 可以引用其他变量 $light-border: 1px solid \$ligth-color 变量中命令不区分 下划线和中横线，一般统一风格就行 属性嵌套12345678910111213141516div &#123; border: &#123; // 冒号隔开 width: 1px solid; left: 0; right: 0; &#125;&#125;div &#123; border: width: 1px solid &#123; // 冒号隔开 left: 0; right: 0; &#125;&#125; @import导入文件中定义的变量和混合器, 如果在这个文件中重新定义变量会影响后面所有的变量值 如果 a.scss 定义了\$a, b 引入 a.scss 并重写了， 后面再次引用 a.scss 的文件均是 b 重写过的 解决方案 使用默认值定义 \$width: 400px !default（这样不会覆盖） 使用嵌套引入，将引入的作为局部变量 div {@import “”} @mixin将片段 复用，理解成讲这个片段完整拷贝到@include 位置 @mixin name {xxxxx} 定义 @include name; 使用 可以使用 &amp; 可以包含块 可以带参数 @mixin name($arg1, $arg2), @include name(red,blue) 具名参数 @mixin name($arg1, $arg2), @include name({$arg2: blue, $arg1: red) 默认参数 @mixin name($arg1: red, $arg2: \$agr1) 可以对形参进行引用 @extends继承其他选择器的属性, 仅是那个选择器， 不会包括选择器子元素那些 继承在 BEM 中实战 123456789101112131415.nav &#123; background-color: steelblue; &amp;__container &#123; display: flex; justify-content: space-between; &#125; &amp;__item &#123; color: white; &amp;--active &#123; @extend .nav__item; border-bottom: 1px solid red; &#125; &#125;&#125;// 可以在html中直接 .nav__item--active 而不需要使用 .nav__item .nav__item--active 变量的数据类型修正之前变量的错误认识 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif，同时包含（空格 ，）时分解为子数组 maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) #{}插值语句可以避免运算，直接编译 &amp;的理解理解成一个特殊的变量 1234567891011@mixin does-parent-exist &#123; @if &amp; &#123; &amp;:hover &#123; color: red; &#125; &#125; @else &#123; a &#123; color: red; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960$light-theme: ( border-color: #eceeef, font-color: #323232, font-secondary: #c2c6d0, background-color: #fff, bg-title: #d3e6fb, bg-oddList: #f3f3f3, bg-listHover: #c5dffe);//深色主题$dark-theme: ( border-color: #000, font-color: #c2c6d0, font-secondary: #aaa, background-color: #131925, bg-title: #293248, bg-oddList: #171e2c, bg-listHover: #0d3a70);//定义映射集合$themes: ( light: $light-theme, dark: $dark-theme);@mixin themify($themes: $themes) &#123; @each $theme-name, $map in $themes &#123; .theme-#&#123;$theme-name&#125; &amp; &#123; $theme-map: () !global; @each $key, $value in $map &#123; $theme-map: map-merge( $theme-map, ( $key: $value ) ) !global; &#125; @content; $theme-map: null !global; &#125; &#125;&#125;@function themed($key) &#123; @return map-get($theme-map, $key);&#125;#app &#123; font-family: "Avenir", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; @include themify($themes) &#123; background: themed("background-color"); color: themed("font-color"); &#125;&#125; @each12@each $item, $index in $list &#123;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划学习（大雾）]]></title>
    <url>%2Farchives%2F89e50cbe.html</url>
    <content type="text"><![CDATA[过程 划分状态 状态表示 状态转移 确定边界 套路 自底向上 自顶向下]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树学习]]></title>
    <url>%2Farchives%2Ffeb19258.html</url>
    <content type="text"><![CDATA[红黑树红黑树是二叉平衡树的一种，包括 5 种性质 根节点是黑色 节点颜色要么黑色，要么红色 每个叶子节点是黑子 任意节点到每个叶子节点的路径中包含的黑节点树 相等 每个红色节点的两个子节点的一定都是黑色（不能有两个连续的红节点） 红色树通过左旋，右旋，变色来实现平衡 左旋: 旋转节点的右节点变成父节点，选择节点变成右节点的左节点，右节点的左节点变成选择节点的右节点 右旋: 旋转节点的左节点变成父节点，旋转节点变成左节点的右节点，左节点的右节点变成旋转节点的左节点 插入流程]]></content>
  </entry>
  <entry>
    <title><![CDATA[三次握手四次挥手的奇怪理解]]></title>
    <url>%2Farchives%2F6c3aac24.html</url>
    <content type="text"><![CDATA[三次握手 向妹子招手(SYN=1, seq = X) 妹子回应(ACK=X+1) (此时你知道妹子回应你，你知道妹子的意思了) 并通知向你招手(seq=Y syn =1) 你回应妹子的招手(ACK=Y+1, seq = Z) (此时妹子也知道你的意思了) 四次挥手主动方: FIN=1 ACK=Z seq=X被动方: ACK=X+1 seq=Z被动方：FIN=1 ACK=X seq=Y;主动方：ACK=Y seq=X]]></content>
  </entry>
  <entry>
    <title><![CDATA[垂直居中]]></title>
    <url>%2Farchives%2Fa1ccf0ca.html</url>
    <content type="text"><![CDATA[父元素高度已知, 子元素高度未知line-height + vertical-align 父元素高度和 line-height 一致 父元素高度已知，子元素高度已知position: absolute 和 margin-top: -50%position: absolute 和 transform: translateY: -50%;position: absolute; top: 0; bottom: 0 ; margin: auto父元素高度未知, 子元素高度未知align-item: center;table table-cellgrid align-items:center;]]></content>
  </entry>
  <entry>
    <title><![CDATA[passport学习]]></title>
    <url>%2Farchives%2Fb4605e3d.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[开发中学习nest.js]]></title>
    <url>%2Farchives%2F65be6a2e.html</url>
    <content type="text"><![CDATA[新建配置服务安装依赖 1234npm i -S dotenvnpm i -D @types/dotenvnpm install -S @hapi/joinpm install -D @types/hapi__joi 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// config.service.tsimport * as dotenv from "dotenv"import * as fs from "fs"import * as Joi from "@hapi/joi"const configSchema = &#123;&#125;export type EnvConfig = Record&lt;string, string&gt;export class ConfigService &#123; private readonly envConfig: Record&lt;string, string&gt; // 配置的合并顺序 // .env.[type].local =&gt; .env.[type] =&gt; .env constructor(filePath?: string) &#123; if (filePath) &#123; this.envConfig = dotenv.parse(fs.readFileSync(filePath)) &#125; else &#123; // 读取默认配置 .env // 读取[type].env 配置 // 读取 local.[type].env配置 let defaultEnvConfig let typeEnvConfig = &#123;&#125; let localEnvConfig = &#123;&#125; try &#123; defaultEnvConfig = dotenv.parse(fs.readFileSync(".env")) typeEnvConfig = dotenv.parse( fs.readFileSync(`$&#123;process.env.NODE_ENV&#125;.env`) ) localEnvConfig = dotenv.parse( fs.readFileSync(`local.$&#123;process.env.NODE_ENV&#125;.env`) ) &#125; catch (err) &#123;&#125; if (!defaultEnvConfig) &#123; throw new Error("默认配置文件未找到!") &#125; this.envConfig = Object.assign( defaultEnvConfig, typeEnvConfig, localEnvConfig ) &#125; // todo // this.envConfig = this.validateConfig(this.envConfig); &#125; private validateConfig(envConfig: EnvConfig): EnvConfig &#123; const envVarSchema: Joi.ObjectSchema = Joi.object(configSchema) const &#123; error, value: validateEnvConfig &#125; = envVarSchema.validate(envConfig) if (error) &#123; throw new Error("配置文件验证出错") &#125; return validateEnvConfig &#125; get(key: string): string &#123; return this.envConfig[key] &#125;&#125;// config.module.tsimport &#123; Module &#125; from "@nestjs/common"import &#123; ConfigService &#125; from "./config.service"@Module(&#123; providers: [ &#123; provide: ConfigService, useValue: new ConfigService() &#125; ], exports: [ConfigService]&#125;)export class ConfigModule &#123;&#125;// .envPORT = 3000 注册到全局模块 mysql typeorm 集成安装依赖1npm i -S @nestjs/typeorm typeorm mysql ### mysql typeorm curd 集成1npm i --save @nestjsx/crud @nestjsx/crud-typeorm class-transformer class-validator 默认情况下 module 是单列的，意味着模块中 提供者也是单列认证12npm install --save @nestjs/passport passport passport-localnpm install --save-dev @types/passport-local JWT 功能12npm i -S @nestjs/jwt passport-jwtnpm i -S @types/passport-jwt 请求的执行顺序客户端请求 —&gt; 中间件 —&gt; 守卫 —&gt; 拦截器之前 —&gt; 管道 —&gt; 控制器处理并响应 —&gt; 拦截器之后 —&gt; 过滤器 重点：在示例给出了它们的写法，注意全局管道、守卫、过滤器和拦截器，只能 new，全局中间件是纯函数，全局管道、守卫、过滤器和拦截器，中间件都不能依赖注入。中间件模块注册也不能用 new，可以依赖注入。管道、守卫、过滤器和拦截器局部注册可以使用 new 和类名，除了管道以为其他都可以依赖注入。拦截器和守卫可以写成高阶方法来传参，达到定制目的 泛型中&amp;是啥意思&amp;指的是并集类型， | 指的是交集类型 别人的项目结构main.ts 入口main.hmr.ts 热更新入口app.service.ts APP 服务（选择）app.module.ts APP 模块（根模块，必须）app.controller.ts APP 控制器（选择）app.controller.spec.ts APP 控制器单元测试用例（选择）config 配置模块core 核心模块（申明过滤器、管道、拦截器、守卫、中间件、全局模块）feature 特性模块（主要业务模块）shared 共享模块（共享 mongodb、redis 封装服务、通用服务）tools 装饰器的集中写法1234567891011121314151617181920declare type ClassDecorator = &lt;TFunction extends Function&gt;( target: TFunction) =&gt; TFunction | voiddeclare type PropertyDecorator = ( target: Object, propertyKey: string | symbol) =&gt; voiddeclare type MethodDecorator = &lt;T&gt;( target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | voiddeclare type ParameterDecorator = ( target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; void 动态模块中 service 如何被注册到其他动态模块上1configModule 是个动态模块， 现在需要注册到typeormModule 上面, 最好的方式直接申明全局模块 采坑记录ConfigModule 不能读取 module 目录下的 json 配置文件开发代码都在 src 里，生成代码在 dist (打包自动编译)，typescript 打包只会编译 ts 到 dist 下，静态文件 public 和模板 views 不会移动，所以需要放到根目录下， 同理，配置 json 需要放在根目录下。 管道安装 npm i -S class-validator class-transformer 直接在 DTO 中装饰器定义 12345// create-cat.dto.tsexport default CreateCatDto &#123; @IsString() readonly name: string;&#125; 配置管道控制器中使用方法装饰器注入@UsePipes(new ValidationPipe({transform: true})) class-validator 装饰器大全@Length@contains(‘text’) entity 中定义类型和装饰器相比优先级低12345@CreateDateColumn(&#123; comment: '创建时间' &#125;)createdAt: Date@UpdateDateColumn(&#123; comment: '更新时间' &#125;)updatedAt: boolean // 这样也是可以的， 最后也会被解释成 datetime 类型的]]></content>
  </entry>
  <entry>
    <title><![CDATA[开发中学习typescript]]></title>
    <url>%2Farchives%2F71eabda7.html</url>
    <content type="text"><![CDATA[Record 类型将一个类型的所有属性值都映射到另一个类型上并创造一个新的类型 12345678910111213141516171819202122232425262728293031323334type Record&lt;k extends keyof any, T&gt; = &#123; [P in K]: T&#125;type petsGroup = "dog" | "cat" | "fish"interface IPetInfo &#123; name: string age: number&#125;type IPets = Record&lt;petsGroup, IPetInfo&gt;/** * IPets = &#123; * dog: IPetInfo * cat: IPetInfo * fish: IPetInfo * &#125; **/const animalsInfo: IPets = &#123; dog: &#123; name: "dogName", age: 2 &#125;, cat: &#123; name: "catName", age: 3 &#125;, fish: &#123; name: "fishName", age: 5 &#125;&#125; 联合类型一个值可以是几种类型之一如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 12345678910111213141516171819202122type unionType = number | stringinterface Bird &#123; fly() layEggs()&#125;interface Fish &#123; swim() layEggs()&#125;type Animal = Bird | Fishfunction getPet(): Animal &#123; if (xxx) &#123; return bird &#125; else &#123; return fish &#125;&#125;let pet = getPet()pet.fly() // error 类型保护与区分类型枚举枚举是 enum 关键定义的数据 123456789101112enum enumVar = &#123; x, y&#125;// enumVar.x = 0// enumVar[0] = 'x'enum enumVar = &#123; x = 'x' y = 'y'&#125;// enumVar.x = 'x'// enumVar['x'] = 'x' 高级类型Partial 123type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[p]&#125; Required 123type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P]&#125; ReadOnly 123type ReadOnly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P]&#125; Pick 123type Pink&lt;T, K extands keyof T&gt; = &#123; [P in K]: T[P]&#125; Record 123type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T&#125; Type 123interface Type&lt;T&gt; extends Function &#123; new (...arg: any): T // 表示T只能被new 调用， 不能直接调用&#125; 可以看到 type 是不能继承的，而且写法是赋值, interface 更像是申明 装饰器装饰器经计算后必须返回一个函数，就包括两种形式，一是直接返回函数，另一种是函数工厂 123456function decorator(target) &#123; return ...&#125;function decoratorFactory() &#123; return function(target) &#123;&#125;&#125; 装饰器会在 class 定义期间执行，无须等到 new 上至下依次对装饰器表达式求值(工厂函数会被执行)。 求值的结果会被当作函数，由下至上依次调用 123@g@f// g(f(x)) 类装饰器(constructor) 方法装饰器(constructor, key,) 属性装饰器 参数装饰器 ReadonlyArray&lt;&gt; 和 Array&lt;&gt;用于固定数组， 保证数组不能被修改或者被引用到另一个变量上 interface 理解是对结构的描述 12345678910111213141516171819interface Test &#123; test(): boolean // 描述对象的中函数 (a: string): boolean // 函数体的描述 new (test: string): someInstanceInterface // 对构造函数的额描述 [prop: number]: string // 索引签名&#125;interface Test1 extends Test // 接口是可继承的interface Counter &#123; // 混合类型，类比有属性的函数 (start: number): string; interval: number; reset(): void;&#125;interface SomeConstructor &#123; // 对构造器进行描述，描述构造器和构造器上面的静态属性 new (a: string): Counter test() propA: string&#125; 对象字面量传参问题对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误 1234567interface Config &#123; width?: string height?: string&#125;function test(config: Config): &#123; width: string &#125; &#123;&#125;test(&#123; height: 123, a: 123 &#125;) // a会报错 解决方法是提前为 额外的属性进行 定义 1234interface Config &#123; ... [prop: string]: string&#125; 函数的 interface 仅用于表达式声明中1234interface Func &#123; (arg1: string, arg2: number): void // 对函数体描述&#125;let func: Func = function(a: string, b: string): void &#123;&#125; // 参数名可以和接口不一致 可索引的类型仅包括数字索引和字符串索引， 数字索引的值必须是字符串索引的子类型，因为 JavaScript 中 a[100]===a[‘100’] 1234interface SomeInterface &#123; [prop: string]: number [prop: number]: string&#125; readOnly 的理解针对对象的属性名进行锁定，在索引签名中，可以对索引锁定readonly [prop: string]: string，对象不能在新增加属性 interface 的种类 对象类型 函数类型 class 类型 class interface 的写法123456789101112131415161718192021222324252627282930313233// ? PersonConstructor 是用来检查静态部分的interface PersonConstructor &#123; new (name: string, age: number) // ✔️ 这个是用来检查 constructor 的 typename: string // ✔️ 这个是用来检查静态属性 typename 的 logname(): void // ✔️ 这个用来检查静态方法 logname 的&#125;// ? PersonInterface 则是用来检查实例部分的interface PersonInterface &#123; // new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的 log(): void // : 这里定义了实例方法 log&#125;// class Person implements PersonInterface, PersonInterface &#123; ❌ 这样写是错误的const Person: PersonConstructor = class Person implements PersonInterface &#123; name: string age: number static typename = "Person type" // 这里定义了一个名为 typename 的静态属性 static logname() &#123; // 这里定义了一个名为 logname 的静态方法 console.log(this.typename) &#125; constructor(name: string, age: number) &#123; // constructor 也是静态方法 this.name = name this.age = age &#125; log() &#123; // log 是实例方法 console.log(this.name, this.age) &#125;&#125;const Person: PersonConstructor 接口可以继承 class当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 1interface someInterface extends someClass // 会继承class中所有的成员，实例属性和方法 对上一条的理解 当我们比较带有 private 或 protected 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则 就是说需要都是某一个基类的子类才行 受保护的构造函数对构造添加 protected，pretected 能被子类访问， private 不能被子类访问 类中的 readonly你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 typeof class返回一个 类的 静态成员信息和实例化对象的构造函数信息 （静态信息部分） 1234567891011121314151617181920class Greeter &#123; static standardGreeting = "Hello, there" greeting: string greet() &#123; if (this.greeting) &#123; return "Hello, " + this.greeting &#125; else &#123; return Greeter.standardGreeting &#125; &#125;&#125;var greeter1: Greetergreeter1 = new Greeter()alert(greeter1.greet())var greeterMaker: typeof Greeter = Greeter // Greeter 包括了静态信息部分和动态信息部分，所以满足typeofgreeterMaker.standardGreeting = "Hey there!"var greeter2: Greeter = new greeterMaker() // new greeterMaker返回动态信息，所以蛮子 Greeter， 是class 本生作为类型， 应该指的是示例部分alert(greeter2.greet()) 函数定义类型详情参见函数类型写法 在申明时给每个参数和返回标记处类型，并写函数体 123function a(arg1: string): booleanlet a: (arg1: string) =&gt; boolean = func 使用 type 3. 12345678910111213// 写法一function Func(a: string)=&gt;boolean;// 写法二let a: (b: string) =&gt; boolean = function(a: string) &#123; return true&#125;// 写法三interface Func1 &#123; (a: string): boolean&#125; TypeScript 里的每个函数参数都是必须的不能传 null 和 undefined interface 可以缩写， 直接在用的地方定义12345678interface SomeInterface &#123; (a: string): boolean&#125;let a: &#123; (a: string): boolean &#125; = function(a: string) &#123; // 这两种是等价的、 return false&#125; 泛型在定义中函数或者 interface 前面， 使用时在后面 12345678910111213141516// 泛型接口interface &#123; &lt;T&gt;(a: T): T&#125;// 泛型类class Add&lt;T&gt; &#123; value: Array[T] consturctor(value:T) &#123; this.value= [value] &#125;&#125;// 泛型约束interface With&lt;T, name&gt; &#123; name: T&#125;class Add&lt;T extends WithNumber&lt;string, "number"&gt;&gt; 泛型仅包括泛型接口和泛型类ts 需要区分运行时和编译时interface 和 const enum 就会在编译时被抹掉, enum 会被计算到生成的代码中， interface 仅作为检查。 12345678const enum EnumA &#123; A, B, C&#125;const test = [EnumA.A]// =&gt; 生成的js 代码const test = [0] typeof 变量可以推导出变量 A 的类型， 用于复制某一变量的类型 1type typeA = typeof varA]]></content>
  </entry>
  <entry>
    <title><![CDATA[严格模式]]></title>
    <url>%2Farchives%2F7108a574.html</url>
    <content type="text"><![CDATA[如何使用“use strict” 指令只允许出现在脚本或函数的开头。推荐在函数定义中开头放置 ‘use strict’ ，而不是在脚本开头 为什么要使用严格模式消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 严格模式体现了 Javascript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在严格模式中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在严格模式下将不能运行。掌握这些内容，有助于更细致深入地理解 Javascript，让你变成一个更好的程序员。 规则 this 的指向不再默认指向 全局 不允许删除变量、对象、函数 不能使用 8 进制， 转义字符串 不能使用 with； eval 是沙盒模式 保留一些关键字 禁止使用 arguments.callee 开发中如何规范使用 eslint 等静态代码检查工具，提前扫描。 常用套路123(function(window) &#123; "use strict"; // 防止合并代码代码导致严格模式失效的情况&#125;)(window);]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码盒子]]></title>
    <url>%2Farchives%2F2aa90bba.html</url>
    <content type="text"><![CDATA[Array.prototype.sort12;[3, 1, 4].sort((a, b) =&gt; a - b) // 1,3,4;[3, 1, 4].sort((a, b) =&gt; b - a) // 4,3,1 currying 柯里化函数123456789101112131415161718192021function currying(fn) &#123; // 通用的柯里化函数 var args = [] return function() &#123; if (arguments.length === 0) &#123; return fn.apply(this, args) &#125; else &#123; args.push(arguments) return arguments.callee &#125; &#125;&#125;var cost = currying(function() &#123; let result = 0 let len = arguments.length while (len--) &#123; result += arguments[len][0] &#125; return len&#125;) 惰性代码12345678910function isEnterKey(keyCode) &#123; var finalCode // 遥控器 确认按键 if (keyCode === 13 || keyCode === 14) &#123; finalCode = keyCode isEnterKey = function(keyCode) &#123; return finalCode === keyCode &#125; &#125;&#125; addEventListener 兼容优化写法1234567891011121314151617function addEvent(element, eventName, callback, options) &#123; if (element.addEventListener) &#123; // 重写函数 addEvent = function(element, eventName, callback, options) &#123; return element.addEventListener(eventName, callback, options) &#125; &#125; else if (element.attachEvent) &#123; addEvent = function(element, eventName, callback, options) &#123; element.attachEvent("on" + eventName, callback, options) &#125; &#125; else &#123; addEvent = function() &#123; element["on" + eventName] = callback &#125; &#125; addEvent(element, eventName, callback, options)&#125; 同理解绑函数也是同上 123456789function _off(el, event, fn) &#123; if (el.removeEventListener) &#123; el.removeEventListener(event, fn, false) &#125; else if (el.detachEvent) &#123; el.detachEvent("on" + event, fn.bind(el)) &#125; else &#123; el["on" + event] = null &#125;&#125; 为元素添加 on 和 trgger 方法12345678910// onElement.prototype.on = Element.prototype.addEventListenerNodeList.prototype.on = function(event, fn) &#123; Array.prototype.forEach.call(this, el =&gt; &#123; el.on(event, fn) &#125;) return this&#125;// trigger 使用代理的单例模式12345678910111213function Man() &#123;&#125;function createSingleClass(Fn) &#123; var instance return function newFn() &#123; if (this instanceof newFn) &#123; if (!instance) &#123; instance = new Fn(...arguments) &#125; return instance &#125; &#125;&#125; 翻转数字12345 =&gt; 54321 123456789function reverserNumber(number) &#123; var newNumber = 0 while (number &gt;= 1) &#123; var pop = number % 10 number = Math.floor(number / 10) newNumber = newNumber * 10 + pop &#125; return newNumber&#125; 找到第一个未重复的字符123456789function findFirstNumber(str) &#123; var i = -1, s while ((s = str[++i])) &#123; if (str.lastIndexOf(s) === i) &#123; return i &#125; &#125;&#125; 限制并发数并尽快的完成任务需要上传多张，要求尽快的上传完成，但是同时上传的格式为 m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function loadImg(url) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`$&#123;url&#125; is loaded`) resolve(url) &#125;, url * 100) &#125;)&#125;// promise 版本async function limitLoadAwait(urls, handler, limit) &#123; let sequence = [].concat(urls) let result = [] let promises = sequence.splice(0, limit).map(async (url, index) =&gt; &#123; result.push(await handler(url)) return index &#125;) await sequence.reduce(async (pCollect, url, currentIndex) =&gt; &#123; await pCollect let fastIndex = await Promise.race(promises) promises[fastIndex] = handler(url).then(res =&gt; &#123; result.push(res) return fastIndex &#125;) return promises &#125;, Promise.resolve()) await Promise.all(promises) return result&#125;// async await 版本async function limitLoadAwait(urls, handler, limit) &#123; let sequence = [].concat(urls) let result = [] let promises = sequence.splice(0, limit).map(async (url, index) =&gt; &#123; result.push(await handler(url)) return index &#125;) await sequence.reduce(async (pCollect, url, currentIndex) =&gt; &#123; await pCollect let fastIndex = await Promise.race(promises) promises[fastIndex] = handler(url).then(res =&gt; &#123; result.push(res) return fastIndex &#125;) return promises &#125;, Promise.resolve()) await Promise.all(promises) return result&#125; 巧妙结合 promise 和 reduce需要连续调用三个接口， 如果接口返回 true，继续调用下个接口。直到返回 false 或者到末尾 123456789101112131415161718192021function uploadImg(url) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(url) &#125;, 1000) &#125;)&#125;function uploadOneByOne(urls, handler) &#123; return urls.reduce((p, url) =&gt; &#123; return p.then(res =&gt; &#123; if (res) &#123; return handler(url) &#125; else &#123; return Promise.resolve(false) &#125; &#125;) &#125;, Promise.resolve(true))&#125;uploadOneByOne([true, true, true, false, true], uploadImg).then(console.log) 上述方法缺点是不能提前跳出 循环队列的思考和实现传统方式实现队列, 借助数组的 pop 和 unshift 方法 123456789function Queue() &#123; var _data = [] this.enQueue = function(value) &#123; _data.push(value) &#125; this.deQueue = function() &#123; return _data.unshift() &#125;&#125; 这种方法的弊端是每次入队出队都需要挪动整个队列。考虑引入头部指针和尾指针 123456789101112131415function Queue() &#123; var _data = [] var head = 0, tail = 0 this.enQueue = function(value) &#123; _data[head++] = value &#125; this.deQueue = function() &#123; if (_data.length === 0) &#123; return new Error("队列为空") &#125; else &#123; return _data[tail++] &#125; &#125;&#125; 这种策略空间换时间的方案，长时间使用后会溢出。所以有循环队列的方案 12345678910111213141516171819202122232425262728293031323334353637383940function Queue(initLength) &#123; var _data = new Array(initLength), tail = -1, head = -1, length = 0 dataLength = initLength this.enQueue = function(value) &#123; console.log(value, head, tail) if (length === dataLength) &#123; // 溢出 this.resetQueue() &#125; head = (head + 1) % dataLength _data[head] = value length++ &#125; this.deQueue = function() &#123; if (length === 0) &#123; throw new Error("empty") &#125; tail = (tail + 1) % dataLength length-- var result = _data[tail] _data[tail] = undefined return result &#125; this.resetQueue = function() &#123; // 扩容 dataLength = dataLength * 2 _data.length = dataLength // 如果 if (head &lt; tail) &#123; var headList = _data.splice(0, head + 1) _data.splice(tail, 0, ...headList) &#125; &#125; this.toString = function() &#123; console.log(_data) &#125;&#125; 动态的去扩大长度，还有 deQueue 应该动态减少长度 经典算法-洗牌算法12345678function shuffleArray(arr) &#123; var len = arr.length while (len--) &#123; var index = Math.floor(Math.random() * len) ;[arr[index], arr[len]] = [arr[len], arr[index]] &#125; return arr&#125; 位运算详解与或非异或 判断是否为奇数 n &amp; 1n | 0 === n n ^ n === 0 n ^ 0 === n~~表示向 0 取整 123function power(n) &#123; return 1 &lt;&lt; n&#125; n &gt;&gt;&gt; 0 的含义toNumber（不能转成 number 的变成 1） =&gt; 整数(~~n) =&gt; toUint32(负数 + 2 的 30 次方) GC 那些事儿 引用计数法. 对每个开辟的空间进行引用计数， 缺点是回带来内存溢出（循环引用的情况） 标记回收法：从根开始，递归的标记能访问的对象，标记完成后，去虽有未标记的对象进行回收 常见的内存泄露情况及处理方案 被遗忘的定时器 意外的全局变量(使用严格模式) 脱离 dom 的引用 闭包 脱离的 dom 的引用举例123456&lt;script&gt; let div = document.getElementById("fa") document.body.removeChild(div) // dom删除了 //div=null //切断div对div的引用 console.log(div)&lt;/script&gt; 一行代码实现 flat 函数123function flat(arr) &#123; return [].concat.apply([], arr)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端误区]]></title>
    <url>%2Farchives%2Fa2e48826.html</url>
    <content type="text"><![CDATA[引用值作为属性名情况先 toString 再 valueOf，使用独一无二的 key 使用 symbol 1234var a = &#123;&#125;var b = &#123;&#125;b[a] = 123b[a] === a["[object object]"] // true es6 中可以使用 Map 或者 weakMap constructor 误区constructor 是继承的构造函数的 prototype.constructor 属性。对象的__proto__属性指向函数的 prototype 属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Person(name) &#123; this.name = name&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;// 原型链继承function Woman(sex) &#123; this.sex = sex&#125;Woman.prototype = new Person("yan")let woman1 = new Woman("female")woman1.sayName() // yan/* --------------------------------- */// 构造函数function Man(name, sex) &#123; Person.call(this, name) this.sex = sex&#125;let man1 = new Man("xun", "male")man1.sayName() // error// 组合继承function Man(name, sex) &#123; Person.call(this, name) this.sex = sex&#125;Man.prototype = new Person() // 问题 Man.prototype.contructor === Person man1.contructor !== ManMan.prototype.contructor = Man // 修正 contructor, 修复instanceOflet man1 = new Man("xun", "fale")man1.sayName() // xun// 原型式继承function extend1(o) &#123; // 等价于 Object.create(o) let Fn = function() &#123;&#125; Fn.prototype = o return new Fn()&#125;// let const 和 var 绑定变量的区别区别是 let const 不会绑定在 window 上面。 var 会。 还有严格模式下函数中的 this 模式不会指向 window 1234let a = 1console.log(window.a) // undefinedvar b = 2console.log(window.b) // 2 this 永远指向最后调用它的那个对象a.b.c() c 中 this 指向的是 b，除了显示调用 this，其余都是 123456789101112function foo() &#123; console.log(this.a) return function() &#123; console.log(this.a) &#125;&#125;var obj = &#123; a: 1 &#125;var a = 2foo.call(obj)()// 1// 2 // 还是指向的window 函数作为参数可以这样写12345678910111213function test(fn) &#123; console.log(typeof fn)&#125;test( function() &#123; console.log(this.a) &#125;.call(&#123; a: 1 &#125;))// 输出// 1// undefined setTimeout 使用 undefined 作为参数的情况什么也不会发生 箭头函数 this 问题里面的 this 是由外层作用域来决定的，且指向函数定义时的 this 而非执行时。 ps 这句话是错误的， 应该从函数调用栈的观点来看待 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined 特殊例子 12345678910111213141516171819var obj = &#123; name: "obj", foo1: () =&gt; &#123; console.log(this.name) &#125;, foo2: function() &#123; console.log(this.name) return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var name = "window"obj.foo2.call(&#123; name: 3 &#125;)()// 3// 3// 所以箭头函数的this 应该是执行时向父作用域的this看齐。 执行代码是应该是加上父作用域的执行情况 箭头函数的 this 不能通过 bind,apply,call 来更改，因为箭头函数自身没有 this，依赖的是父作用域中的 this，所以只能通过修改父作用域来修改 this。 更加的迷惑的行为 1234567891011121314151617181920212223var name = "window"var obj1 = &#123; name: "obj1", foo1: function() &#123; console.log(this.name) return () =&gt; &#123; console.log(this.name) &#125; &#125;, foo2: () =&gt; &#123; console.log(this.name) return function() &#123; console.log(this.name) &#125; &#125;&#125;var obj2 = &#123; name: "obj2"&#125;obj1.foo1.call(obj2)() // obj2 obj2obj1.foo1().call(obj2) // obj1 obj1 迷惑： 因为返回箭头函数，所以形成了闭包， 需要再次引用父作用域的thisobj1.foo2.call(obj2)() // window windowobj1.foo2().call(obj2) // window obj2 浏览器端 even loop 执行顺序 一开始整个脚本作为一个宏任务执行 执行中，同步代码直接执行，宏任务进入宏任务队列， 微任务进入本次宏任务的微任务队列 宏任务执行，微任务执行 UI 线程 渲染进行 web worker 进行 重复第二点 宏任务包括 script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering 微任务包括 process.nextTick promise.then MutationObserver 微任务会被添加到本次宏任务的末尾， 而宏任务会到下一次执行 promise 误区1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve("success") // 如果promise 没有 resolve .then 不会生效。 打印结果是 1 2 4 console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4)// 1 2 4 3 一开始进入宏队列 123456789101112console.log("1")setTimeout(() =&gt; &#123; // 放入下一个宏队列 console.log("2")&#125;)Promise.resolve().then(() =&gt; &#123; // 属于本次宏任务的微任务 console.log("3")&#125;)console.log("4")// 1 4 3 2 影响性能的可能因素 === 性能优于 !== if 语句都需要化简为=== while 循环性能优于 for 养成 while 循环的好习惯 while(len--) 不能使用++a, 性能比直接先++ 弱 charAt 和 直接字符串下标的区别charAt 是 es3 方法， 下标是 es5+方法。 charAt 在越界时返回 “”。字符串下标会让人误以为是可写的。 实际不能写。 promise 再次理解先上结论 Promise 的状态一经改变就不能再改变。 .then 和.catch 都会返回一个新的 Promise。catch 也会返回一个 resolve 状态的 Promise。如果 catch 没有抓到错， 也会返回一个新 promise，是调用 catch 的副本。同理上层有 reject 状态时，.then 也会一直返回一个 rejected 状态的副本 catch 不管被连接到哪里，都能捕获上层的错误。(见 3.2) 在 Promise 中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如 return 2 会被包装为 return Promise.resolve(2)。 Promise 的 .then 或者 .catch 可以被调用多次, 当如果 Promise 内部的状态一经改变，并且有了一个值，那么后续每次调用.then 或者.catch 的时候都会直接拿到该值。(见 3.5) .then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。(见 3.6) .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。(见 3.7) .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。(见 3.8) .then 方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为 catch 是.then 第二个参数的简便写法。(见 3.9) .finally 方法也是返回一个 Promise，他在 Promise 结束的时候，无论结果为 resolved 还是 rejected，都会执行里面的回调函数。 1234567// 证明第二点 每次调用.then .catch 都是返回的新的promise，状态由上一个promise的状态决定 。除了.then 一个 rejected状态的promise返回rejected状态的promise，其余都返回resolved状态var a = new promise(res =&gt; res(2))console.log(a) // promise resolved:2var b = a.then(console.log) // 2 promise resolved:2console.log(b === a) //falseconsole.log(a) // 同上个ab.then(console.log) // 2 promise resolved:2 证明 catch 返回的 promise 123456var a = Promise.reject(2) // reject: 2var b = a.catch(console.log) // 2 resolve： undifinedvar c = a.then(console.log)console.log(c) // reject: 2console.log(c === a) // falseconsole.log(b) // resolve： undifined 验证返回的 promise 副本是深拷贝还是浅拷贝。下面例子证明是”浅拷贝” 1234var a = &#123;&#125;var b = Promise.resolve(a);var c = = b.catch().then(res=&gt;console.log(res===a)) // trueconsole.log(b.catch() === b) // false promise .then .catch 参数非法的情况1234Promise.resolve(1) .then(2) // 只生成副本 .then(Promise.resolve(3)) // 只生成副本 .then(console.log) // 1 await 误区和正确阅读123456789101112async function async1() &#123; console.log("async1 start") await async2() console.log("async1 end")&#125;async function async2() &#123; console.log("async2")&#125;async1()console.log("start")// 之前错误的观点 start =&gt; async1 start" =&gt; async2 =&gt; async1 end// 实际运行结果 async1 start =&gt; async2 =&gt; start =&gt; async2 所以可以理解为 await 函数是当前函数.then 的一个语法糖。 然后 async 理解成一个 promise 的封装，所以 await 需要是 resolved 或者 rejected 状态的才行。 1234var a = new Promise(res =&gt; &#123; console.log&#125;)// pending 状态的。 奇特的 Promise resolve12345678910111213function a(fn) &#123; setTimeout(() =&gt; &#123; fn(123) console.log(1234) &#125;, 3000)&#125;var a = new Promise(res =&gt; &#123; a(res)&#125;)a.then(console.log)// 1234// 123 其实也不奇特，函数是引用传递 vue 中碰到浏览器死循环的问题，可以换个浏览器试试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[炫酷的CSS]]></title>
    <url>%2Farchives%2Fb29594f7.html</url>
    <content type="text"><![CDATA[若隐若现的发光字 background-image： line background-position: -500% =&gt; 500%]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端编码的故事]]></title>
    <url>%2Farchives%2F5f877c4e.html</url>
    <content type="text"><![CDATA[前言本文记录自己理解 ascii、unicode、utf-8 的含义和区别 ascii 编码ascii 编码使用一个字节代表一个字符，比如 A，二进制就是 0100 0001，十进制就是 65。目前来说 ascii 只有 128 个字符，所以第一位都统一为 0 unicode 编码ascii 编码只有 128 种状态，表示英语字符能够，但是表示其他国家语言字符时就不够用， 所以 unicode 编码就是在 ascii 上面扩展到多个字节。所以 unicode 编码将世界上所有符号包括在内。 unicode 只是定义的符号集，但是有些字符需要多字节存储。这个时候有个问题，如何区分多个独立字节表示的多个符号还是表示的一个符号。 有个解决方式都统一成 4 字节或者更高，这个也有个问题是，英语字符需要一个字节，补位会导致存储空间明显变大。 utf-8为了解决这个问题，出现 UTF-8、UTF-16、UTF-32 这些解决方案。大部分 unicode 字符都是 2 字节UTF-8 是一种可变长得编码方式， 可以使用 1-4 个字节来表示一个符号。编码规则只有两条 如果是单字节，第一位是 0，剩下用 unicode 编码补齐 如果字节是 n(n&gt;1), 前 n 位 1，n+1 位 0, 剩下的每个字节的前两位一律 10， 没有提及的位数使用 unicode 编码补全，]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法-递归优化]]></title>
    <url>%2Farchives%2F15477400.html</url>
    <content type="text"><![CDATA[前言本文简单记录算法学习中， 递归优化的一些方法 尾调用简单来说就说一个函数末尾返回另一个函数 123456789function a() &#123; ... return a() // 这种就属于尾调用&#125;function a() &#123; ... return n+b() // 这种不属于， 因为return 了其他计算式&#125; 尾调用优化当尾调用的不依赖当前函数时就是尾调用优化，调用栈尽可能少。 12345678910function a(n) &#123; ... function b(n) &#123; return n+x &#125; return b(n) // 这个是尾调用， 但不是尾调用优化。 // 因为执行 return 时 a依然在调用栈中&#125; 尾调用优化例子 保证是一个尾调用 保证调用栈尽可能的,return 的函数无副作用 123456789101112131415161718192021222324252627// 阶乘函数function f1(n) &#123; if (n === 1) return n; return n * f1(n - 1);&#125;function f2(n, total) &#123; if (n === 1) &#123; return total; &#125; return arguments.callee(n - 1, n * total);&#125;// 斐波拉契函数function fb1(n) &#123; if (n &lt;= 2) &#123; return 1; &#125; return arguments.callee(n - 2) + arguments.callee(n - 1);&#125;function fb2(n, a1, a2) &#123; if (n === 1) &#123; return a2; &#125; return arguments.callee(n - 1, a2, a1 + a2);&#125; 缓存值的方式优化通过把函数中值缓存起来，加快速度，这种仅限于结果集固定的情况 12345678910111213function memoizer(fn, cache = &#123;&#125;) &#123; return function(arg) &#123; if (!(arg in cache)) &#123; cache[arg] = fn(arg); &#125; return cache[arg]; &#125;;&#125;let fac = memoizer(function(n) &#123; if (n === 1) return n; return n * arguments.callce(n - 1);&#125;);fac(5); 尾调用转 栈 + 迭代的通用方案阮一峰书中看到的方案，可以对任意尾调用进行优化, 只能尾调用形式的递归 12345678910111213141516function tco(fn) &#123; var value; var active = false; var accumulated = []; return function() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = fn.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125; 缓存值优化方案12345678910111213141516171819function fb(n) &#123; if (n === 1 || n === 2) &#123; return 1; &#125; return fb(n - 1) + fb(n - 2);&#125;// 优化function optimizeRecursion(fn) &#123; var cache = &#123;&#125;; return function() &#123; var arg = Array.prototype.join.call(arguments, "."); if (arg in cache) &#123; return cache[arg]; &#125; return (cache[arg] = fn.apply(this, arguments)); &#125;;&#125; 斐波拉契数列 转迭代 动态规划123456789var climbStairs = function(n) &#123; const dp = []; dp[0] = 1; dp[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;; 递归时间复杂度和空间复杂度计算规则递归次数和计算函数的时间的乘积 二叉树的最大深度普通迭代方案 123456function maxDeep(node) &#123; if (node === null) &#123; return 0; &#125; return Math.max(maxDeep(node.left), maxDeep(node.right)) + 1;&#125; 总结 二叉树数组的关系 深度 log2 (length+1) i 行第一个元素和最后一个: 第一个 2^i - 1 最后一个 2^(i+1) - 2 ， i 从 0 开始 i 行元素个数 2 ^ i 左节点 2 * i + 1 右节点 2 * i + 2]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器追踪]]></title>
    <url>%2Farchives%2Fbfdd4d38.html</url>
    <content type="text"><![CDATA[前言本文适用同机器同浏览器追踪。分为 5 个大指标：browser_fp canvas_fp webgl_fp audio_fp webrtc。采集指标需要具有稳定性， 即多次采集值不会变 场景 匿名用户系统 未登录的用户 广告 ID 浏览器指纹webdriver cpuClass deviceMemory UserAgent platform123456return navigator.webdriver; // 这个可以检测 自动化测试工具（puppeteer, selenium）return navigator.cpuClass; // cpu等级return navigator.deviceMemory; // 设备内存大小 8return navigator.UserAgent; // 浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言) 渲染引擎标识 版本信息return navigator.hardwareConcurrencyKey; // cpu核心数 4核几线程return navigator.platform; // Win32 languagenavigator 里面有两个关于 language 的 一个 language，一个是 languages, language 是不是和 languages 相等，来判断用户是不是改过语言，同时需要结合 ip 时区归属地来标记异常用户 12345678var getLanguage = function() &#123; return ( navigator.language || navigator.userLanguage || navigator.browserLanguage || navigator.systemLanguage );&#125;; colorDepth screenResolution devicePixelRatio1234return window.screen.colorDepth; // 颜色深度return [window.screen.width, window.screen.height]; // 设备分辨率return [window.screen.availHeight, window.screen.availWidth]; // 可用分辨率return window.devicePixelRatio; // 视网膜屏比例 timezone 时区判断 ip 是否和时区一致 123var getTimezone = function() &#123; return new window.Intl.DateTimeFormat().resolvedOptions().timeZone;&#125;; timezoneOffset 时区偏移和上面类似 123var getTimezoneOffset = function() &#123; return new Date().getTimezoneOffset();&#125;; sessionStorage localStorage IndexedDB openDatabase1234return !!window.localStorage;return !!window.sessionStorage;return !!window.indexedDB;return !!window.openDatabase; doNotTrack 浏览器设置的不追踪标记1return navigator.doNotTrack || navigator.msDoNotTrac || window.doNotTrack; plugins 浏览器插件1234567891011121314151617181920212223242526272829navigator.plugins; // 非IE// IEvar names = [ "AcroPDF.PDF", // Adobe PDF reader 7+ "Adodb.Stream", "AgControl.AgControl", // Silverlight "DevalVRXCtrl.DevalVRXCtrl.1", "MacromediaFlashPaper.MacromediaFlashPaper", "Msxml2.DOMDocument", "Msxml2.XMLHTTP", "PDF.PdfCtrl", // Adobe PDF reader 6 and earlier, brrr "QuickTime.QuickTime", // QuickTime "QuickTimeCheckObject.QuickTimeCheck.1", "RealPlayer", "RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)", "RealVideo.RealVideo(tm) ActiveX Control (32-bit)", "Scripting.Dictionary", "SWCtl.SWCtl", // ShockWave player "Shell.UIHelper", "ShockwaveFlash.ShockwaveFlash", // flash plugin "Skype.Detection", "TDCCtl.TDCCtl", "WMPlayer.OCX", // Windows media player "rmocx.RealPlayer G2 Control", "rmocx.RealPlayer G2 Control.1"];try &#123; new new window.ActiveXObject(names[i])(); // 通过是否能够成功构造对象来区分&#125; devices1navigator.mediaDevices.enumerateDevices().then(); canvas_fp画布指纹原理是通过 canvas 绘制图片，绘制的图片由于不同设备， 不同浏览器绘制的图片 base64 不相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 关于canvas的几个指标var result = [];var canvas = document.createElement("canvas");canvas.width = 2000;canvas.height = 200;canvas.style.display = "inline";var ctx = canvas.getContext("2d");ctx.rect(0, 0, 10, 10);ctx.rect(2, 2, 6, 6);result.push(&#123; name: "canvas winding", value: ctx.isPointInPath(5, 5, "evenodd") === false&#125;);ctx.textBaseline = "alphabetic";ctx.fillStyle = "#f60";ctx.fillRect(126, 1, 62, 20);ctx.fillStyle = "#069";ctx.font = "11pt no-real-font-123";ctx.fillStyle = "rgba(102, 204, 0 ,0.2)";ctx.fileText("QWEtyioio asdgh sad, ~! \ud83d\ude03", 4, 45);ctx.fileText("QWEtyioio asdgh sad, ~! \ud83d\ude03", 16, 56);ctx.globalCompositeOperation = "multiply";ctx.fillStyle = "rgba(255, 0, 255)";ctx.beginPath();ctx.arc(50, 50, 50, 0, Math.PI * 2, true);ctx.closePath();ctx.fill();ctx.fillStyle = "rgb(0,255,255)";ctx.beginPath();ctx.arc(100, 50, 50, 0, Math.PI * 2, true);ctx.closePath();ctx.fill();ctx.fillStyle = "rgb(255,255,0)";ctx.beginPath();ctx.arc(75, 100, 50, 0, Math.PI * 2, true);ctx.closePath();ctx.fill();ctx.fillStyle = "rgb(255,0,255)";// canvas winding// http://blogs.adobe.com/webplatform/2013/01/30/winding-rules-in-canvas/// http://jsfiddle.net/NDYV8/19/ctx.arc(75, 75, 75, 0, Math.PI * 2, true);ctx.arc(75, 75, 25, 0, Math.PI * 2, true);ctx.fill("evenodd");if (canvas.toDataURL) &#123; result.push(&#123; name: "img", value: canvas.toDataURL() &#125;);&#125; webgl_fp通过生成 webgl 图像来区分fp2.js 关于 webgl 实现 audio_fp通过生成的处理后音频来区分fp2.js 关于 audio_context 的 实现 webrtc参考 fingerprintjs2 Canvas,WebGL 以及 AudioContext 指纹原理 真正的感知：Web 客户端追踪技术 人的唯一性识别 everycookie]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuepress踩坑记录]]></title>
    <url>%2Farchives%2Ff8e87dde.html</url>
    <content type="text"><![CDATA[alias 设置需要使用 resolve 12345678910const path = require('path')module.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; '@public': path.resolve(__dirname, './public'), &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker-swarm]]></title>
    <url>%2Farchives%2F8f65.html</url>
    <content type="text"><![CDATA[防火墙配置2377/tcp：用于客户端与 Swarm 进行安全通信。7946/tcp 与 7946/udp：用于控制面 gossip 分发。4789/udp：用于基于 VXLAN 的覆盖网络。]]></content>
  </entry>
  <entry>
    <title><![CDATA[开发小技巧]]></title>
    <url>%2Farchives%2F129533de.html</url>
    <content type="text"><![CDATA[查看端口是否开启 12345678910111213141516# Connection successful:$ timeout 1 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/google.com/80'$ echo $?0# Connection failure prior to the timeout$ timeout 1 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/sfsfdfdff.com/80'bash: sfsfdfdff.com: Name or service not knownbash: /dev/tcp/sfsfdfdff.com/80: Invalid argument$ echo $?1# Connection not established by the timeout$ timeout 1 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/google.com/81'$ echo $?124]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫]]></title>
    <url>%2Farchives%2F7ade1d5c.html</url>
    <content type="text"><![CDATA[泄露 500, 5000, 50000 个人信息关键数据库 ！！！！脱敏]]></content>
  </entry>
  <entry>
    <title><![CDATA[etcd使用]]></title>
    <url>%2Farchives%2F19889329.html</url>
    <content type="text"><![CDATA[介绍 分布式键值对存储仓库（基础使用） 配置共享和服务发现（高级场景）其他场景 使用软件版本 v3.4.3 下载解压12wget https://github.com/etcd-io/etcd/releases/download/v3.4.3/etcd-v3.4.3-linux-amd64.tar.gztar xzvf etcd-v3.4.3-linux-amd64.tar.gz 单机单节点部署1./etcd 参数说明参数支持命令行参数和 yaml 配置文件形式 1234567name // 节点名称 默认为defaultdata-dir // 存储目录 ;initial-advertise-peer -urls; // 初始化通信地址 默认 http://localhost:2380listen-peer-urls; // 通信地址 默认 http://localhost:2380initial-cluster; // 集群节点配置信息 node1=http://192.168.1.10:2380,node2=...listen-client-urls // 客户端地址advertise-client-urls // 对外公告的地址 发现模式123$ curl http://discovery.etcd.io/new?size=3http://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de$ ./etcd -discovery http://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de 扩展节点1234# 旧节点启动$ ./etcdctl member add node --peer-urls http://192.168.10.12# 新节点加入 initial-cluster-state 设置为 existing]]></content>
  </entry>
  <entry>
    <title><![CDATA[踩坑日记]]></title>
    <url>%2Farchives%2F8d485cf3.html</url>
    <content type="text"><![CDATA[data url 和 base 64 的区别网页上使用 data-url， 对文件进行 base64 编码data-url =&gt; data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAbase64 =&gt; R0lGODlhAwADAIAAAP///8zMzCH5BAAAA jsx 中千万不要把 slot 渲染写在 computed 中， 会导致无法响应]]></content>
  </entry>
  <entry>
    <title><![CDATA[js真值，隐形转换，比较]]></title>
    <url>%2Farchives%2F3c778964.html</url>
    <content type="text"><![CDATA[假值的情况 &quot;&quot;是假 数字 0，+0，-0，NaN 是假，其余是真 Symbol 是真 undefined、null 是假 除以上的情况，所有都是真值 真假值使用的情况 if语句 !取反 == 情况分析 NaN 均不== undefined和null相等 一个是boolean，另一个是Number或String， boolean转成数字 一个是对象，对象先valueOf再toString。变换成基本类型比较 关系运算符（&gt;、&lt;、==、!=…） ===、!==：同时对比类型和值，两个都为真才返回真 ==、!=: 若两边均为对象，对比它们的引用是否相同 逻辑非(!): 将其后变量或表达式转为布尔值 对比字符串：从头至尾扫描逐个比较每个字符的unicode码，直到分出大小 其他情况下，两边均转为数值类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试基础篇（二）]]></title>
    <url>%2Farchives%2F234b714a.html</url>
    <content type="text"><![CDATA[js 正在表达式高级用法记忆 非捕获 (?:x) x 参与匹配但是不参与捕获 断言 x(?=y) y 参与匹配， 但是不出现在匹配的子串中 /x(?=y)/.exec(“xy”)[0]=”x”, 和非捕获的差别是 /x(?=y)/.exec(“xy”)[0]=”xy” x(?!y) 表示 x 后面不跟 y (?&lt;=y)x x 前面是 y (?&lt;!y)x x 前面是不是 y 正则默认是贪婪匹配，在数量词后? 表示非贪婪匹配 正则表达式事深度优先原则，先一路到底，再回溯。如果出现了回溯，会使性能大幅度影响，尽量少出现回溯，数量词尽量明确。大型子串匹配时很容易出现回溯。 正则回溯举例12/a\d&#123;1,3&#125;0/.test("a220");// 这种情况会出现一次回溯， \d&#123;1,3&#125; 贪婪匹配, 220 ，然后再匹配0，不复活， 回溯成\d&#123;1,3&#125; 匹配22 正则表达式 | 的理解1/99|55/; // 匹配的应该是 99 或者55 而不是 9(9|5)5 正则 exec 和 g 修饰符理解123456789var reg = /\w/;reg.exec("abc"); // areg.exec("abc"); // areg.exec("abc"); // avar reg = /\w/g; // 必须是变量的方式reg.exec("abc"); // areg.exec("abc"); // breg.exec("abc"); // c match 和 replace 中 g 修饰符match(//g) 返回的是匹配的每个子串组成的数组，不加 g 同 execreplace 同上， 但是使用字符串模式时， $` $’ 需要注意]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端常用布局 - 两列布局]]></title>
    <url>%2Farchives%2F8930074f.html</url>
    <content type="text"><![CDATA[前言本编主要讲常用布局 两列布局，两列布局有两种，一是左边固定右边自适应，另一种是右边固定，左边自适应。只讲我认为最优的方案 左侧固定演示12&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="slide"&gt;slide&lt;/div&gt; 123456789101112.slide &#123; float: left; width: 100px; margin-left: -100%;&#125;.main &#123; float: left; padding-left: 100px; box-sizing: border-box; width: 100%; &#125; 右侧固定演示12&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="slide"&gt;slide&lt;/div&gt; 123456789101112.slide &#123; float: left; width: 100px; margin-left: -100%;&#125;.main &#123; float: left; padding-left: 100px; box-sizing: border-box; width: 100%; &#125; flex这个方案最简单，也最容易理解使用 order + flex 属性即可 table使用table也行， 兼容性高于flex。父：display: table;子：display: table-cell; 绝对定位比较简单容易理解123456789.slide &#123; position: absolute; top: 0; bottom: 0; width: 200px;&#125;.main &#123; margin-left: 200px;&#125; float + margin1234567.slide &#123; float: left; width: 200px;&#125;.main &#123; margin-left: 200px;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常用布局 - 三列布局]]></title>
    <url>%2Farchives%2Fe924f8d1.html</url>
    <content type="text"><![CDATA[前言收集了常用的3列布局方案，左右固定，中间自适应方案，其中圣杯布局和双飞翼需要慢慢琢磨原理， 琢磨不透直接记下来用。 浮动演示1234567891011&lt;div class="content"&gt; &lt;div class="left"&gt; left &lt;/div&gt; &lt;div class="right"&gt; right &lt;/div&gt; &lt;div class="main"&gt; main &lt;/div&gt;&lt;/div&gt; 123456789101112.left &#123; float: left; width: 200px;&#125;.right &#123; float: right; width: 200px;&#125;.main &#123; margin-left: 200px; margin-right: 200px;&#125; BFC演示1234567891011&lt;div class="content"&gt; &lt;div class="left"&gt; left &lt;/div&gt; &lt;div class="right"&gt; right &lt;/div&gt; &lt;div class="main"&gt; main &lt;/div&gt;&lt;/div&gt; 1234567891011.left &#123; float: left; width: 200px;&#125;.right &#123; float: right; width: 200px;&#125;.main &#123; overflow: auto;&#125; 定位演示1234567891011&lt;div class="content"&gt; &lt;div class="main"&gt; main &lt;/div&gt; &lt;div class="left"&gt; left &lt;/div&gt; &lt;div class="right"&gt; right &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.content &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; width: 200px;&#125;.right &#123; position: absolute; top: 0; right: 0; width: 200px;&#125;.main &#123; margin-left: 200px; margin-right: 200px;&#125; 双飞翼布局演示12345&lt;div class="content"&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; 1234567891011121314151617181920.left &#123; float: left; width: 200px; margin-left: -100%; &#125;.right &#123; float: right; width: 220px; margin-left: -230px&#125;.content &#123; float: left; width: 100%;&#125;.main &#123; clear: both; margin-left: 110px; margin-right: 220px;&#125; 圣杯布局演示12345&lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.container &#123; margin-left: 200px; margin-right: 200px;&#125;.left &#123; float: left; width: 200px; position: relative; margin-left: -100%; left: -200px;&#125;.right &#123; float: left; width: 200px; position: relative; right: -200px; margin-left: -200px&#125;.main &#123; float: left; width: 100%;&#125; flex演示12345&lt;div class="container"&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 123456789101112131415.container &#123; display: flex;&#125;.left &#123; order: 0; flex: 0 0 200px;&#125;.right &#123; order: 2; flex: 0 0 200px;&#125;.main &#123; order: 1; flex: 1 0 auto;&#125; table演示12345&lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 123456789101112131415.container &#123; display: table; width: 100%;&#125;.left &#123; display: table-cell; width: 200px;&#125;.right &#123; display: table-cell; width: 200px;&#125;.main &#123; display: table-cell;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试基础篇（一）]]></title>
    <url>%2Farchives%2F135d9d92.html</url>
    <content type="text"><![CDATA[前端 SEO 注意情况 title &gt; description &gt; keywords 搜索引擎从上到下，重要内容放前面 内容不用 js 动态输出 搜索引擎会跳过 frame 非装饰图片使用 alt post 和 put 区别put 是幂等的，多次操作不会新增数据条数，可以理解为修改某条数据。post 是非幂等的，多次操作会增加多条数据，理解为新增接口。建议管理系统不做区分， 都用 post。 优化的一些点 静态资源分布到多域名下 控制资源大小，小文件合并。 css 和 js 单独放置为文件 压缩图片，减少位深。 iframe 问题 阻塞主页面 onload 事件，通过 动态添加 src 或更优的 createElmenet 的形式来添加 iframe 和主页面同域共享连接池，会影响主页面资源加载 采用多个域名存储资源的原因 突破浏览器并发限制 节约 cookie 带宽 节约主域名连接数 电商图片处理 小图标 雪碧图 加载缩略图 懒加载，滚动位置再加载 BFC overflow 不为 visible; position: absolute || fixed; display: inline-block || table-cell || flex float 不为 none html 元素 清除浮动12345678910.clearfloat &#123; zoom: 1;&#125;.clearfloat:after &#123; display: block; clear: both; content: ''; visibility: hidden; height: 0;&#125; css 优先级!important &gt; 内联 &gt; id &gt; class &gt; tag 消除 display: inline-block 间隙 父元素 font-size: 0; 父元素 word-spacing: 0; // 单词间隙 删除空格 letter-spacing: 0 // 字母间隙 动画间隔时间保证 30fps 1000/30 = 33.333ms bind 注意bind 是强绑定的， 绑定后不能更换 this 浏览器缓存 强制缓存 =&gt; 根据 Expired(http1.0)(通过服务端返回有效时间) ， 或者 Cache-control 来控制， 一般使用 max-age： 1h。 强制缓存是直接从浏览器获得请求，一个是 from memory cache(页面刷新的缓存)，一个是 from disk cache（页面关闭再打开）js 和图片等文件 当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache 协商缓存 =&gt; 强制缓存失效时， 就会启用协商缓存 last-modified(第一次响应) =&gt; if-modified-since（浏览器再次请求） =&gt; 服务端和本地文件进行对比 Etag 和 if-none-match返回 etat =&gt; if-none-match =&gt; 对比 etag viewport 的值有哪些1234&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0 user-scaleable=yes"/&gt; 如何判断一个单链表是否有环使用快慢指针, 快指针追上慢指针表示有环，快指针到末尾还未追上， 表示没环。 如何判断环的长度和环的起点设置一个指针从 head 开始， 一个从相遇点开始，知道两个指针重合， 就是起点环的长度，可以通过快指针和慢指针下次相遇的，操作步数 两个无环链表，判断是否相交和相交节点是多少将任意一个链表守卫相接，然后从另一个链表开始， 如果是有环的，证明必然有环 xss 和 csrfxss 跨站脚本攻击，网站内容被插入了 js 代码。包括在 url 里面被植入 例如 javascript: alert()这种代码。 转义csrf 跨站请求伪造， 直接在 B 网站上发送请求 A 网站的请求。 禁止跨站访问，根据 referer 来判断。 点击劫持 嵌套 iframe, 服务端配置禁止被引用。 深拷贝 递归拷贝引用类型 循环引用的情况，每次检测是否某个对象的字段是本身对象或祖先对象 平级引用，使用 weakMap 检测有个属性是否在 weakMap 存在]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css显示显示更多功能]]></title>
    <url>%2Farchives%2Fca5e0d7a.html</url>
    <content type="text"><![CDATA[前言需要实现文本显示不超过两行，超过的两行的部分，用显示更多按钮，点击后显示展开全部文本。用html+css实现单行效果两行效果多行效果展开效果 实现html 部分12345678910111213141516171819202122232425262728&lt;div class="pay-info"&gt; &lt;input id="onekey-payInfoCheckbox" type="checkbox" style="display: none;" /&gt; &lt;p class="pay-info-text"&gt; &lt;span class="pay-info-text-detail" &gt;###***！！气asd asd 阿斯达阿达啊1 3阿达阿斯达暗杀是大法官地方甘道夫古典风格的公司的暗杀撒旦防守对方是否是是防守对方斯蒂芬撒旦放。&lt;/span &gt; &lt;span class="pay-info-text-detail1" &gt;###***！！气asd asd 阿斯达阿达啊1 3阿达阿斯达暗杀是大法官地方甘道夫古典风格的公司的暗杀撒旦防守对方是否是是防守对方斯蒂芬撒旦放。&lt;/span &gt; &lt;span class="pay-info-shade"&gt;&lt;/span&gt; &lt;/p&gt; &lt;label for="onekey-payInfoCheckbox" class="pay-info-text-con pay-info-text-open" &gt;&lt;span class="arrow-download"&gt;&lt;/span &gt;&lt;/label&gt; &lt;label for="onekey-payInfoCheckbox" class="pay-info-text-con pay-info-text-close" &gt;&lt;span class="arrow-up"&gt;&lt;/span &gt;&lt;/label&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677.pay-info &#123; position: relative; margin-top: 12px;&#125;.pay-info-text &#123; /* width: 100%; */ position: relative; font-size: 14px; max-height: 40px; /* min-height: 40px; */ overflow: hidden; transition: max-height 0.25s; color: #999999;&#125;.pay-info-text-detail &#123; font-size: 14px; line-height: 1.4; color: #999999;&#125;.pay-info-text-detail1 &#123; position: absolute; top: 0; left: 0; right: 0; z-index: 101; height: 20px; font-size: 14px; line-height: 1.4; color: #999999; overflow: hidden; background: white;&#125;.pay-info-shade &#123; position: absolute; right: 0; width: 16px; height: 16px; padding: 4px; background: #fff; z-index: 99;&#125;:checked ~ .pay-info-text .pay-info-shade &#123; display: none;&#125;:checked ~ .pay-info-text &#123; max-height: 250px; /* ä¸€ä¸ªè¶³å¤Ÿå¤§çš„æœ€å¤§é«˜åº¦å€¼ */&#125;.pay-info-text-con &#123; position: absolute; right: 0; /* left: 0; */ width: 16px; height: 16px; cursor: pointer; bottom: 0; text-align: right; padding: 4px; color: #000;&#125;.pay-info-text-open &#123; background: rgba(255, 255, 255, 0.5);&#125;.pay-info-text-close &#123; display: none;&#125;:checked ~ .pay-info-text-open &#123; display: none;&#125;:checked ~ .pay-info-text-close &#123; display: inline-block; bottom: -24px;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[记一次正则表达式的坑]]></title>
    <url>%2Farchives%2F636ae7c5.html</url>
    <content type="text"><![CDATA[开始问题如下123let regx = new RegExp("^[0-9]+(\.[0-9]&#123;0,2&#125;)?$") regx.test('0') // ?? =&gt; trueregx.test('0x') // ?? =&gt; true 这个结果就很奇怪了。 还以为是执行环境出错了。去查阅了一波MDN文档。有这么一句话使用 new RegExp(&quot;pattern&quot;) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。 1let newRegx = new RegExp("^\\b+(\.\\b&#123;0,2&#125;)?$") //解决]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>正则表达式</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript原型和constructor理解]]></title>
    <url>%2Farchives%2Fd0b04a7b.html</url>
    <content type="text"><![CDATA[前言前几日被同事问到js继承方面的东西，想来想去就知道是通过prototype来实现，具体实现也搞不清了。赶紧回去翻红宝书复习下。对原型这块的理解又更深了一步。 new 的理解：伪代码从下方可以看到 js继承是原型继承， 不是类继承。1234567 new Person("John") = &#123; var obj = &#123;&#125;; obj.__proto__ = Person.prototype; // 此时便建立了obj对象的原型链： // obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null var result = Person.call(obj,"John"); // 相当于obj.Person("John") return typeof result === 'object' ? result : obj; // 如果无返回值或者返回一个非对象值，则将obj返回作为新对象&#125; function 的constructor是什么默认情况下是指的是定义本身。 是对象上一个指向构造函数的引用。用来辅助 instanceof 等关键字的实现。下方例子看一看到，没什么用。F.prototype.constructor === f.__proto__.constructor === F123456789101112 function People(name) &#123; this.name = name &#125; People.prototype.constructor === People // true console.log(new People('yangmanman')) // yangmanman // 重新指向 People.prototype.constructor = function(name) &#123; this.name = "123" &#125; console.log(new People('yangmanman').name) // yangmanman 修改没用// ---------------------- 分割线 ----------------------------- 如何理解原型继承使用的是指向和call这种东西。 参考资料 JavaScript深入之继承的多种方式和优缺点 JavaScript 原型精髓 #一篇就够系列 小邵教你玩转JS面向对象]]></content>
      <categories>
        <category>javascript 基础</category>
      </categories>
      <tags>
        <tag>prototype</tag>
        <tag>原型</tag>
        <tag>constructor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css世界读书笔记（1）]]></title>
    <url>%2Farchives%2Fb78f1e6b.html</url>
    <content type="text"><![CDATA[前言上次去整了本张鑫旭大佬编的《CSS世界》，一直没有时间研读，仅记录一些之前未接触的内容。 块级元素粗略理解为 display 值为 table，block，list-item等值元素。具有独占一行水平流的功能，可以使用clear 属性。 list-item 出现项目符号理解元素可以理解为多个盒子构成，外在盒子，容器盒子（内在盒子），标记盒子（这个是list-item独有的盒子）。可以按照每种盒子具有自身的display来理解行为。block =&gt; block-flow inline-block =&gt; inline-block 理解width：auto 充分利用可用空间：表现在div，p等元素上，会尽可能扩伸。 收缩与包裹：表现在table，inline-block上面，收缩到合适。有种根据内容来设置min-width的感觉。 收缩到最小：table-layout：auto 会出现 超出限制：长连续的英文和数字会出现。还有 white-space:nowrap设置后的内联元素 元素的宽度是由什么决定的？外部尺寸指的是元素自身就能决定宽度 正常流，div，p等元素，总是尽可能扩伸。按照流来理解 position为absolute，fixed等情况下对边属性都存在时。可以理解为，自身把自身拉开 显式设置宽度 内部尺寸指的是元素的尺寸由内部元素决定 包裹性的元素：下方inline-block宽度为123宽度 12345&lt;div style="display: inline-block;"&gt; &lt;div&gt; 123 &lt;/div&gt;&lt;/div&gt; 首选最小宽度：当父元素宽度设置为0时，子元素表现出最小宽度 伪元素::after ::before 的定义命中元素的最后|最前一个子元素 宽度分离当需要限定宽度时，把宽度定义单独提取出一个元素，box-sizing: border-content功能相同 宽度100% 和 高度100%width：100% auto = 无效 height：100% auto = 无效。但是宽度这种未定义行为各个厂商把auto视为包含块的最小宽度来处理的。要明白其中的原因要先了解浏览器渲染的基本原理。首先，先下载文档内容，加载头部的样式资源（如果有的话），然后按照从上而下、自外而内的顺序渲染 DOM 内容。套用本例就是，先渲染父元素，后渲染子元素，是有先后顺序的。因此，当渲染到父元素的时候，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素宽度已经固定，此时的 width:100%就是已经固定好的父元素的宽度。宽度不够怎么办？溢出就好了，overflow 属性就为此而生的 如何让高度支持100%position: absolute; 不过注意的是绝对定位的宽高百分比计算是相对于 padding box 的 超越! important和超越最大权重优先级 min- &gt; max- &gt; ! important 任意高度的展开动画效果通过过度 max-* 来实现效果12345678.element &#123; max-height: 0; overflow: hidden; transition: max-height .25s;&#125;.element.active &#123; max-height: 666px; /* 一个足够大的最大高度值 */&#125; 幽灵空白节点在 HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 高度为span空白节点的高度 内联元素的定义可以看做外在盒子是 inline 的元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css元素尺寸</tag>
        <tag>css世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openssl学习笔记]]></title>
    <url>%2Farchives%2Fc76c6f1c.html</url>
    <content type="text"><![CDATA[概念公钥端：C 私钥端：S — RS：非对称加密 AES：对称加密公钥加密，私钥解密。 私钥数字签名私钥端：将内容（A）hash内容（A-&gt;B），私钥加密内容（B-&gt;C），将内容（A）和加密后的内容(C) 发送给公钥端公钥端：使用公钥解开加密后的内容C，获得hash内容（C-&gt;B），将内容（A）hash后检查，如果相同，表示未被修改，否则表示修改。 合格公钥构成找一个信任的第三方介入，首先第三方将自己的公钥给C端，然后第三方将S端的公钥合一些信息用自己的私钥加密发送给C端，C使用私钥解密后就能获取S端的公钥，这样就可以实现保证C端拿到的的确是S端的公钥， 防止C端拿到错误的公钥后C端被冒名顶替。 https 构成浏览器发送请求公钥请求，服务器将签名（CA中心用私钥加密的内容）发送给浏览器， 浏览器使用CA拿到的公钥解开信息，验证服务器真伪，验证通过后，浏览器端和服务器协商加密等级，确定一个 公开密钥。至此安全连接建立，应用层通信时，内容会通过这个公开密钥进行对称加密，因为对称加密的方式远远快于非对称加密。 openssl 生成公私钥 生成RSA私钥：openssl genrsa -out private.key 2048 生成RSA公钥：openssl rsa -in private.key -pubout -out rsa_public.key, 通过私钥生成公钥 使用aes方式：openssl genrsa -aes256 -passout pass:yangmanman -out rsa_aes_private.key 2048，对生成的私钥进行 aes 加密，这种方式生成公钥时需要输入密码 使用aes方式生成公钥：openssl rsa -in ./rsa_aes.private.key -passin pass:yangmanman -pubout -out rsa_aes_public.key，生成公钥需要密码 密钥操作加密私钥转换为未加密状态open rsa -in rsa_aes_private.key -passin pass:yangmanman -out rsa_private.key私钥加密open rsa -in rsa_private.key -aes256 -passout pass:yangmanman -out rsa_aes_private.key默认私钥生成 PKCS#1, 转换为PKCS#8 pkcs8 默认需要加密openssl pkcs -topk8 -in rsa_private.key -passout pass:yangmanman -out pkcs8_private.key 证书操作服务器自建证书操作过程生成自签名的CA的证书，生成服务器证书请求，使用CA的证书，私钥对服务器证书请求进行签发，输出服务器证书 自签名的CA证书，并生成密钥1openssl req -newkey rsa:2048 -nodes -keyout ca_rsa_private.key -x509 -days 365 -out ca.crt -subj "/C=CN/ST=GD/L=SZ/O=vihoo/OU=dev/CN=xunserver.cn/emailAddress=xunserver.cn" 使用已有密钥生成 opensll req -new -x509 -days 365 -key rsa_private.key -out ca.crt 生成服务器私钥 openssl rsa -ase256 -passout pass:yangmanman -out server_private.key 2048 生成服务器csr签名 openssl req -new -key server_private.key -out servre.csr [-subj=&quot;/C=CN/ST=GD/L=SZ/O=vihoo/OU=dev/CN=xunserver.cn/emailAddress=xunserver.cn&quot;] 使用ca证书，私钥对服务器csr签名，签发x509证书openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca_private.key -passin:yangmanman -CAcreateserial -out server.crt 至此，服务器证书完全获取到，crt是证书，csr证书签名请求（可以认为是服务器的公钥） 证书操作查看证书细节openssl x509 -in cert.crt -noout -text转换证书编码格式openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem 合成 pkcs#12 证书(含私钥) // 将 pem 证书和私钥转 pkcs#12 证书 openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:111111 -password pass:111111 -out server.p12 //其中-export指导出pkcs#12 证书，-inkey 指定了私钥文件，-passin 为私钥(文件)密码(nodes为无加密)，-password 指定 p12文件的密码(导入导出) // 将 pem 证书和私钥/CA 证书 合成pkcs#12 证书 openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:111111 \ -chain -CAfile ca.crt -password pass:111111 -out server-all.p12 // 其中-chain指示同时添加证书链，-CAfile 指定了CA证书，导出的p12文件将包含多个证书。(其他选项：-name可用于指定server证书别名；-caname用于指定ca证书别名) // pcks#12 提取PEM文件(含私钥) openssl pkcs12 -in server.p12 -password pass:111111 -passout pass:111111 -out out/server.pem 仅提取私钥 openssl pkcs12 -in server.p12 -password pass:111111 -passout pass:111111 -nocerts -out out/key.pem 仅提取证书 openssl pkcs12 -in server.p12 -password pass:111111 -nokeys -out out/key.pem 仅提取ca证书 openssl pkcs12 -in server-all.p12 -password pass:111111 -nokeys -cacerts -out out/cacert.pem 仅提取server证书 openssl pkcs12 -in server-all.p12 -password pass:111111 -nokeys -clcerts -out out/cert.pem openssl 命名1. 命名格式 1) asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) 2) ca: ca用于CA的管理 openssl ca [options]: 2.1) -selfsign 使用对证书请求进行签名的密钥对来签发证书。即&quot;自签名&quot;，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个密钥对来进行&quot;自签名&quot; 2.2) -in file 需要进行处理的PEM格式的证书 2.3) -out file 处理结束后输出的证书文件 2.4) -cert file 用于签发的根CA证书 2.5) -days arg 指定签发的证书的有效时间 2.6) -keyfile arg CA的私钥证书文件 2.7) -keyform arg CA的根私钥证书文件格式: 2.7.1) PEM 2.7.2) ENGINE 2.8) -key arg CA的根私钥证书文件的解密密码(如果加密了的话) 2.9) -config file 配置文件 example1: 利用CA证书签署请求证书 openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key 1) req: X.509证书签发请求(CSR)管理 openssl req [options] &lt;infile &gt;outfile 3.1) -inform arg 输入文件格式 3.1.1) DER 3.1.2) PEM 3.2) -outform arg 输出文件格式 3.2.1) DER 3.2.2) PEM 3.3) -in arg 待处理文件 3.4) -out arg 待输出文件 3.5) -passin 用于签名待生成的请求证书的私钥文件的解密密码 3.6) -key file 用于签名待生成的请求证书的私钥文件 3.7) -keyform arg 3.7.1) DER 3.7.2) NET 3.7.3) PEM 3.8) -new 新的请求 3.9) -x509 输出一个X509格式的证书 3.10) -days X509证书的有效时间 3.11) -newkey rsa:bits 生成一个bits长度的RSA私钥文件，用于签发 3.12) -[digest] HASH算法 3.12.1) md5 3.12.2) sha1 3.12.3) md2 3.12.4) mdc2 3.12.5) md4 3.13) -config file 指定openssl配置文件 3.14) -text: text显示格式 example1: 利用CA的RSA密钥创建一个自签署的CA证书(X.509结构) openssl req -new -x509 -days 3650 -key server.key -out ca.crt example2: 用server.key生成证书签署请求CSR(这个CSR用于之外发送待CA中心等待签发) openssl req -new -key server.key -out server.csr example3: 查看CSR的细节 openssl req -noout -text -in server.csr 1) genrsa: 生成RSA参数 openssl genrsa [args] [numbits] [args] 4.1) 对生成的私钥文件是否要使用加密算法进行对称加密: 4.1.1) -des: CBC模式的DES加密 4.1.2) -des3: CBC模式的DES加密 4.1.3) -aes128: CBC模式的AES128加密 4.1.4) -aes192: CBC模式的AES192加密 4.1.5) -aes256: CBC模式的AES256加密 4.2) -passout arg: arg为对称加密(des、des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节) 4.3) -out file: 输出证书私钥文件 [numbits]: 密钥长度 example: 生成一个1024位的RSA私钥，并用DES加密(密码为1111)，保存为server.key文件 openssl genrsa -out server.key -passout pass:1111 -des3 1024 1) rsa: RSA数据管理 openssl rsa [options] &lt;infile &gt;outfile 5.1) -inform arg 输入密钥文件格式: 5.1.1) DER(ASN1) 5.1.2) NET 5.1.3) PEM(base64编码格式) 5.2) -outform arg 输出密钥文件格式 5.2.1) DER 5.2.2) NET 5.2.3) PEM 5.3) -in arg 待处理密钥文件 5.4) -passin arg 输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话) 5.5) -out arg 待输出密钥文件 5.6) -passout arg 如果希望输出的密钥文件继续使用加密算法的话则指定密码 5.7) -des: CBC模式的DES加密 5.8) -des3: CBC模式的DES加密 5.9) -aes128: CBC模式的AES128加密 5.10) -aes192: CBC模式的AES192加密 5.11) -aes256: CBC模式的AES256加密 5.12) -text: 以text形式打印密钥key数据 5.13) -noout: 不打印密钥key数据 5.14) -pubin: 检查待处理文件是否为公钥文件 5.15) -pubout: 输出公钥文件 example1: 对私钥文件进行解密 openssl rsa -in server.key -passin pass:111 -out server_nopass.key example:2: 利用私钥文件生成对应的公钥文件 openssl rsa -in server.key -passin pass:111 -pubout -out server_public.key 1) x509: 本指令是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作 openssl x509 [args] 6.1) -inform arg 待处理X509证书文件格式 6.1.1) DER 6.1.2) NET 6.1.3) PEM 6.2) -outform arg 待输出X509证书文件格式 6.2.1) DER 6.2.2) NET 6.2.3) PEM 6.3) -in arg 待处理X509证书文件 6.4) -out arg 待输出X509证书文件 6.5) -req 表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发 6.6) -days arg 表明将要签发的证书的有效时间 6.7) -CA arg 指定用于签发请求证书的根CA证书 6.8) -CAform arg 根CA证书格式(默认是PEM) 6.9) -CAkey arg 指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有 6.10) -CAkeyform arg 指定根CA私钥证书文件格式(默认为PEM格式) 6.11) -CAserial arg 指定序列号文件(serial number file) 6.12) -CAcreateserial 如果序列号文件(serial number file)没有指定，则自动创建它 example1: 转换DER证书为PEM格式 openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem example2: 使用根CA证书对&quot;请求签发证书&quot;进行签发，生成x509格式证书 openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt example3: 打印出证书的内容 openssl x509 -in server.crt -noout -text 1) crl: crl是用于管理CRL列表 openssl crl [args] 7.1) -inform arg 输入文件的格式 7.1.1) DER(DER编码的CRL对象) 7.1.2) PEM(默认的格式)(base64编码的CRL对象) 7.2) -outform arg 指定文件的输出格式 7.2.1) DER(DER编码的CRL对象) 7.2.2) PEM(默认的格式)(base64编码的CRL对象) 7.3) -text: 以文本格式来打印CRL信息值。 7.4) -in filename 指定的输入文件名。默认为标准输入。 7.5) -out filename 指定的输出文件名。默认为标准输出。 7.6) -hash 输出颁发者信息值的哈希值。这一项可用于在文件中根据颁发者信息值的哈希值来查询CRL对象。 7.7) -fingerprint 打印CRL对象的标识。 7.8) -issuer 输出颁发者的信息值。 7.9) -lastupdate 输出上一次更新的时间。 7.10) -nextupdate 打印出下一次更新的时间。 7.11) -CAfile file 指定CA文件，用来验证该CRL对象是否合法。 7.12) -verify 是否验证证书。 example1: 输出CRL文件，包括(颁发者信息HASH值、上一次更新的时间、下一次更新的时间) openssl crl -in crl.crl -text -issuer -hash -lastupdate –nextupdate example2: 将PEM格式的CRL文件转换为DER格式 openssl crl -in crl.pem -outform DER -out crl.der 1) crl2pkcs7: 用于CRL和PKCS#7之间的转换 openssl crl2pkcs7 [options] &lt;infile &gt;outfile 转换pem到spc openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc https://www.openssl.org/docs/apps/crl2pkcs7.html 1) pkcs12: PKCS#12数据的管理 pkcs12文件工具，能生成和分析pkcs12文件。PKCS#12文件可以被用于多个项目，例如包含Netscape、 MSIE 和 MS Outlook openssl pkcs12 [options] http://blog.csdn.net/as3luyuan123/article/details/16105475 https://www.openssl.org/docs/apps/pkcs12.html 1) pkcs7: PCKS#7数据的管理 用于处理DER或者PEM格式的pkcs#7文件 openssl pkcs7 [options] &lt;infile &gt;outfile http://blog.csdn.net/as3luyuan123/article/details/16105407 https://www.openssl.org/docs/apps/pkcs7.html 2. openssl list-message-digest-commands(消息摘要命令) 1) dgst: dgst用于计算消息摘要 openssl dgst [args] 1.1) -hex 以16进制形式输出摘要 1.2) -binary 以二进制形式输出摘要 1.3) -sign file 以私钥文件对生成的摘要进行签名 1.4) -verify file 使用公钥文件对私钥签名过的摘要文件进行验证 1.5) -prverify file 以私钥文件对公钥签名过的摘要文件进行验证 verify a signature using private key in file 1.6) 加密处理 1.6.1) -md5: MD5 1.6.2) -md4: MD4 1.6.3) -sha1: SHA1 1.6.4) -ripemd160 example1: 用SHA1算法计算文件file.txt的哈西值，输出到stdout openssl dgst -sha1 file.txt example2: 用dss1算法验证file.txt的数字签名dsasign.bin，验证的private key为DSA算法产生的文件dsakey.pem openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt 1) sha1: 用于进行RSA处理 openssl sha1 [args] 2.1) -sign file 用于RSA算法的私钥文件 2.2) -out file 输出文件爱你 2.3) -hex 以16进制形式输出 2.4) -binary 以二进制形式输出 example1: 用SHA1算法计算文件file.txt的HASH值,输出到文件digest.txt openssl sha1 -out digest.txt file.txt example2: 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的private key为RSA算法产生的文件rsaprivate.pem openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt 3. openssl list-cipher-commands (Cipher命令的列表) 1) aes-128-cbc 2) aes-128-ecb 3) aes-192-cbc 4) aes-192-ecb 5) aes-256-cbc 6) aes-256-ecb 7) base64 8) bf 9) bf-cbc 10) bf-cfb 11) bf-ecb 12) bf-ofb 13) cast 14) cast-cbc 15) cast5-cbc 16) cast5-cfb 17) cast5-ecb 18) cast5-ofb 19) des 20) des-cbc 21) des-cfb 22) des-ecb 23) des-ede 24) des-ede-cbc 25) des-ede-cfb 26) des-ede-ofb 27) des-ede3 28) des-ede3-cbc 29) des-ede3-cfb 30) des-ede3-ofb 31) des-ofb 32) des3 33) desx 34) rc2 35) rc2-40-cbc 36) rc2-64-cbc 37) rc2-cbc 38) rc2-cfb 39) rc2-ecb 40) rc2-ofb 41) rc4 42) rc4-40]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>linux</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp内网穿透]]></title>
    <url>%2Farchives%2Fc067e7e3.html</url>
    <content type="text"><![CDATA[下载安装github搜索frp star最多的项目，到release中根据系统下载响应压缩包 传送门，压缩包中包含frps（公网服务端），frpc（需要被穿透的客户端）.ini 结尾是配置文件，full.ini 是全部的配置文件 启动服务端和客户端./fprs -c ./frps.ini // 到公网服务器启动 ./frpc -c ./frpc.ini // 需要被穿透的机器上执行 服务器配置官网文档支持中文，更多细节查看官方文档 [common] # 通信端口 bind_port = 7000 # 外网访问端口 vhost_http_port=80 vhost_https_port=443 # 二级域名 subdomain_host=frp.xunserver.cn # 连接密码 token=adadadadad # 管理服务器 密码用户端口 dashboard_port=7500 dashboard_user=admin dashboard_pwd=adadadadad # 连接池 # max_pool_count=5 客户端管理[common] # 服务器地址 server_addr = xx.xx.xx.xx # 服务器配置中 bind_port 字段 server_port = 7000 # 本地管理 admin_addr = 127.0.0.1 admin_port = 7400 admin_user = admin admin_passwd = admin # 连接密码 token=xxxxx # 连接池 pool_count = 5 # 日志 log_file = ./frpc.log # 客户端名字，必须和其他客户端名字不同 [migu-http] type = http # 类型 local_port = 80 # 映射到本地端口 subdomain= migu # 子域名 # 同上 [migu-https] type = https local_port = 443 subdomain= migu https 配置由于frp 是全部转发，所以https的配置在应用上，可以在nginx上配置。具体参考 nginx-https配置 ssh 连接在客户端配置， 执行==ssh -oPort=6000 username@x.x.x.x== [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok内网穿透]]></title>
    <url>%2Farchives%2F64ba60b1.html</url>
    <content type="text"><![CDATA[下载安装github 搜索 ngrok star 最多的项目，clone 到本地，解压。 证书配置证书配置，没有证书的使用自签名证书。有证书的跳过这一步 自签名证书使用openssl 生成证书，openssl安装 查看opnessl 学习笔记 12345678910// 生成自签名证书私钥 ca.keyopenssl genrsa -out ca.key 2048// 根据 ca.key 生成自签名的CA证书openssl req -x509 -new -nodes -key ca.key -subj "/CN=domain.name" -days 5000 -out root.crt // 生成服务器私钥openssl genrsa -out server.key 2048// 生成服务器 csropenssl req -new -key server.key -subj "/CN=domain.name" -out server.csr// ca 颁发证书openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 5000 替换官方证书将官方证书替换掉, 官方的证书放在 assets/中, 具体替换下面3个 替换ca ———- assets/client/tls 替换服务器公钥 ———– assets/server/tls 替换服务器证书 ———— assets/server/tls 重新编译服务端和客户端编译需要安装go语言环境yum insatll golang，设置不同系统环境变量编译 1GOOS=[windows | linux] GOARCH=[386 | amd64] make [release-server | release-client] 启动服务器端123/usr/local/ngrok/bin/ngrokd [-tlsKey=/usr/local/ngrok/assets/server/tls/snakeoil.key] [-tlsCrt=/usr/local/ngrok/assets/server/tls/snakeoil.crt] -domain=xxx.xxxx.xx -httpAddr=:81 -httpsAddr=:4443 -tunnelAddr=:4445// -tlsKey 和 -tlsCrt可选，表示使用自己的证书和 key，-damain 绑定的域名； http 和https 监听的端口； -tunnelAddr 客户端通信端口 启动客户端根据平台下载对应的 ngrok程序新建配置文件，添加如下内容 12server_addr: "xxx.xxxx.xxx:port" // port 为服务器 -tunnelAddr 端口值 trust_host_root_certs: false // 如果是自签名证书，此项为false 新建log文件，前期调试用 log.log启动客户端,具体配置可以通过 ngrok -h 查看12ngrok -config config.cfg -log log.log -subdomain subdomainname port// ngrok -config config.cfg -log log.log -subdomain ngrok 80]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客（下）]]></title>
    <url>%2Farchives%2Fce3dc320.html</url>
    <content type="text"><![CDATA[前言本文主要记录在安装hexo主题next中遇到的一些坑 区分两个配置文件hexo 根目录下有个_config.yml，这个叫站点配置文件，目录/themes/xx/_config.yml这个叫主题配置文件，站点配置文件只有一份，而主题配置文件按目录可见是多份。配置时候注意看配置在哪个文件中配置。 接入评论系统折腾了好几种方案，本以为gitment最为轻松，不过也是需要自己的服务器，喜欢折腾的可以参考解决gitment错误。我选用的是畅言评论，这个需要网站备案。还好网站是备案过的。在主题配置中找到 chanyan，修改如下：1234changyan: enable: true appid: xxx # 在畅言中新建应用后可以查询到id和key appkey: xxxxx 更新 valine 评论系统偶然发现一个匿名评论的好东西valine，这个可以匿名评论，不得说不说leancloud大法好。hexo中已经集成valine组件，但是主题配置中_config.yml 配置项有问题，修改如下： 12345678910valine: enable: true appid: xxxxx # 这个字段，官方默认写的是app_id 需要改成 appid appkey: xxxxx # app_key 改成 appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 保存系统可以新建一个私有仓库来保存hexo配置和相关内容，这样可以在多台机器上编写博客。 自定义域名 + 强制https 首先需要一个域名。国内域名大多需要备案，可以到国外购买域名，需要折腾的也可以在国内购买。 将需要定义的域名指向xxx.github.io(xxx为github用户名)。添加CNAME记录可以完成。 新建文件/source/CNAME，写入域名。重新部署。 到github仓库中设置Enforce HTTPS选项。 如果设置成功后页面无效果，清除缓存后重试即可]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>教程</tag>
        <tag>githubpage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客（上）]]></title>
    <url>%2Farchives%2F7681a445.html</url>
    <content type="text"><![CDATA[前言本文章属于入门级别的，图文较多，大佬勿喷。为了时效性，基本工具安装都是指向其他教程。善于记录才能提升。 要求 PC github 帐号 git 安装nodejs，githexo是基于nodejs的框架，先安装nodejs 安装教程博客需要上传到github，需要安装git 安装教程，需要注意的是安装完需要配置git 12git config --global user.name "runoob" git config --global user.email test@runoob.com github准备工作 上传SSH凭证打开 Git GUI(可在开始菜单搜索找到) , 点击菜单中 Help =&gt; show ssh key如果没有key，点击 generate Key 生成公钥。复制下方生成的公钥打开页面https://github.com/settings/keys，点击New SSH Key 填写刚才生成的公钥 新建仓库新建一个仓库来保存博客页面，到https://github.com/new,按照下图提示新建 至此准备工作完成 安装初始化hexo12345npm i -g hexo # 全局安装hexo# 下列步骤均在项目根目录下执行hexo init # 初始化hexo npm i # 重新安装依赖npm i -S hexo-deployer-git # 安装git上传工具 配置git上传工具修改根目录下_config.yml文件，在末尾添加下面内容1234deploy: type: git repo: git@github.com:xxxx/xxxx.github.io.git # xxxx修改为github的用户名 branch: master 写博客上传博客使用markdown来编写的。不习惯的可以去下载可视化markdown编辑器 首先启动本地预览服务器hexo s，在localhost:4000可以看到预览效果 新建文章 hexo new xxx，xxx是博客的title，执行后在/source/_posts/下面可以看到刚生成的文章模版 编写好博客保存后，执行hexo d -g可将博客推送到github，在http://username.github.io可以看到博客已经推送到线上 后续后续记录hexo安装next主题]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>教程</tag>
        <tag>githubpage</tag>
      </tags>
  </entry>
</search>
