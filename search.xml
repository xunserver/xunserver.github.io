<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[chrome调试通关笔记]]></title>
    <url>%2Farchives%2Fa6025488.html</url>
    <content type="text"><![CDATA[基础代码在平台运行时会通过backend对外通过调式协议暴露出运行时各种状态，各种调试工具通过解析调试协议实现UI界面（frontend）。chrome使用的是CDP(chrome devtools protocol)。 谷歌浏览器中有些devtool插件，比如vue devtools 和 react devtool。浏览器插件分为两个部分，一个是可以注入到当前页面的content script，一个是常驻的background部分。此外如果是扩展的devtool部分，还可以有一个devtool page部分。devtool插件通过content script向当前页面注入backend.js（负责收集运行时数据）,页面的backend.js 通过background通道暴露调试协议，devtool page解析调试协议形成页面。 vscode也可以调试chrome和nodejs中运行时代码，同理vscode也实现了一个frontend，只不过vscode在解析协议上还做了一层adapter，因为vscode不止可以调试js代码。 chrome devtool protocolchrome通过ws暴露协议，vscode中配置文件如下,主要有两种方式启动chrome调试，request: “launch” 表示启动一个新的chrome示例，默认配置好ws端口。 request: “attach”表示关联到现有的浏览器示例，这个需要在启动浏览器时指定参数（–remote-debugging-port=9222 –user-data-dir=你自己创建的某个目录） 需要注意的是如果我们手动启动浏览器需要指定–user-data-dir，这个目录保存了当前浏览器的所有配置缓存插件等,而且一个浏览器实例只能同时使用一个数据目录。所以我们在使用launch模式时需要注意，useDataDir的指定，false 表示使用默认（如果已经开了其他实例，启动会失败）,true使用临时目录(默认值)或者指定一个目录 通过下载金丝雀版本的chrome可以解决这个问题 12345678910111213141516171819202122232425// .vscode/launch.json&#123; "configurations": [ &#123; "name": "Launch Chrome", "request": "launch", // attach "type": "chrome", "url": "http://localhost:3000", "webRoot": "$&#123;workspaceFolder&#125;", // 相当于指定pathMapping: &#123;"/":"$&#123;workspaceFolder&#125;/"&#125; "port": 9222, // 如果type: attach需要指定 "runtimeExecutable": "canary", // type修改成 pwd-chrome "useDatadir": false, // 使用默认用户目录 // "type": "pwd-chrome" "runtimeArgs": "--auto-open-devtools-for-tabs", // 额外的启动参数 --auto-open-devtools-for-tabs 自动打开控制台 --incognito 匿名启动 // 某些情况下sourcemap解析的文件地址和本地目录结构不一致，需要重新修正 "sourceMapPathOverrides": &#123; // bunld.js =&gt; source =&gt; localfile "webpack://?:*/*": "$&#123;workspaceFolder&#125;/*" // ?:* 表示匹配不映射， * 表示匹配并映射。 该规则表示 &#125;, // 针对静态文件重新调整 "pathMapping": &#123; "static/js/": "src/js/" &#125; &#125;, ]&#125; sourcemapsourcemap是对源码的描述，大部分dev tool都实现了sourcemap的解析，格式如下123456789&#123; version : 3, // 版本 file: "out.js", sourceRoot : "", sources: ["foo.js", "bar.js"], // 多个源文件 names: ["a", "b"], mappings: "AAgBC,SAAQ,CAAEA;AAAEA", // 最重要的描述文件 sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)'] // 原始代码&#125; 存在一个问题，webpack中开发环境可能会使用eval函数模拟require，eval函数中无法针对字符串实现断点。如果在eval中添加sourceUrl=xxx，会直接添加eval函数的内容到根目录下的xxx，可以实现对eval执行断点。同时，sourceMap可以递归，eval映射出的文件还可以再次指定sourceMapUrl映射到其他目录。 针对线上环境，打包时生成sourceMap文件，但是放在本地，在浏览器调试时使用filesystem将对线上的sourcemap映射到本地，实现本地调试线上环境(待实验),或者重定向到本地代码 sourceMap配置参考这个正则表达式/^(eval-|inline-|hidden-)?(noresources-)?(cheap-(module-)?)?source-map?$/eval：在eval函数中添加sourceUrl在调试环境中添加文件。inline：在bundle.js 中sourceMapUrl直接跟sourceMap内容。hidden: 表示不在bundle在关联sourceMap，但是要生成。noresource: 不在sourcemap中包含原始代码cheap: sourcemap只定位到行错误，不到列错误module: sourcemap生成时会包含每个loader处理的sourceMap（关键配置） vue中sourceMap存在hash问题使用eval会使映射添加hash后缀，最好的办法是不使用hash, 修改devtool: ‘source-map’，或者使用sourceMapPathOverrides重新映射（未成功实现） 线上问题如何调试目前有几种方案解决 线上环境使用noresources构建sourcemap，通过vscode的detools连接到浏览器实现调试 把本地的sourcemap文件添加到filesystem，然后对出错的代码文件右键添加sourcemap，选择filesystem中对应sourcemap文件。这种方式不要设置hidden-source-map 打包后服务器手动删除所有sourcemap文件，本地保留一份。这样请求map时总是会404， 然后把本地的sourcemap文件添加到filesystem 生产环境正常打包sourcemap，但是在请求.map文件时无权限人员加载404，有权限人员能请求，这样既可以在vscode调试，也能在浏览器调试。不过也有问题，每个bundle中会存在sourceUrl，会增大一点包的体积 在打包时对每个chunk和map生成一个映射表（hidden方案），在请求chunk时，通过代理对每个chunk后面添加sourcemap语句，sourcemap指向对应的服务（本地或者远端，或者filesystem），这种方式可以在vscode和浏览器。 每次打包时总是生成两份dist,一份配置（hidden方案）,另一份正常配置sourcemap(输出目录配置成线上域地址)，通过overrides将线上的请求代理到本地，这样请求的bundle文件就是本地的带有sourcemap的文件，filesystem添加带有sourcemap的文件夹到调试环境中。这种方式不能在vscode中实现调试 针对客户浏览器出现的问题，搜集客户代码报错的行和列，通过sourcemap文件反向查找出错误地址，如果sourcemap配置了sourceContent，还可以直接定位具体的文件。 目前最优的方案还是针对不同的用户，展示不同bundle文件。 pathMapping 和 sourceMapPathOverrides的区别前者是对network中是在的请求资源的映射（会自动忽略查询参数），后者是对sourcemap生成的源文件的映射(sourcemap生成文件在请求中是不存在的)。 filesystem 和 overrides区别浏览器请求时总是先对overrides进行查找，然后是服务端，再对filesystem查找。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sass-less]]></title>
    <url>%2Farchives%2Fa8f35e34.html</url>
    <content type="text"><![CDATA[scss@import支持webpack导入，如果导入的文件是_开头，则导入内容不会编译，只会引用变量 变量约定$name: value 形式的为变量。支持字符串（带有空格需要引号包裹），数字，数组（逗号或者空格分隔），对象（(key: value, key2: value2)），boolean。 变量区分为代码块内变量和代码块外变量。默认情况下，后申明的变量会覆盖前置变量（同作用域），通过$var: xxx !default 这种方式可以前置变量覆盖后置。12$color: green;$color: red !default; // 不添加!default red 会覆盖前面，添加!default 后面声明的不会覆盖green &amp;在嵌套中选择父元素 @mixin和@include通过@mixin 定义代码片段，通过@include引入片段实现复用。@mixin相当于代码片段的生成器，支持参数和默认参数。 @extend如果需要对某个类实现继承，使用@extend .classname 实现，会继承该类所有实现。该功能唯一用处是在该类实现比较多的场景。 #{xxx}插值表达式前面变量都是用在属性值上，#{}可以用在选择器或者属性名上面，实现动态生成类或者属性。 lessless解析时区大概两个步骤 按照层级确定变量 根据变量赋值变量@name: value 形式声明变量，变量用在css属性值、属性、类定义包括动态变量中12345678@error: red;@color: color;@red: blue;.error &#123; color: @error; // 属性值 background-@&#123;color&#125;: @@&#123;error&#125;; // 作为属性时需要@&#123;&#125;包裹，作为动态变量需要@@&#125; less支持在块中将属性作为变量名，规则同变量。总是先变量整个快作用域确定变量，然后再赋值。12345678910.error &#123; color: red; .success &#123; color: green; background-color: $color &#125; color: yellow;&#125; less 支持lazy load，可以先使用变量再声明变量。这种特性总是后声明的覆盖前面。]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端大文件上传]]></title>
    <url>%2Farchives%2Fcbd08800.html</url>
    <content type="text"><![CDATA[前言最近弄公司的大文件上传，实现了分片、暂停、继续、断点续传和秒传，记录一些过程中的细节。 buffer、blob和arrayBuffer所有文件都可以按照二进制解析，js宿主环境提供了对二进制的处理。 buffer nodejs提供的二进制缓冲区 blob和file 浏览器提供的二进制对象，通过操作对象来操作二进制 arrayBuffer 浏览器提供的一个具有窗口的二进制对象。 file完全继承了blob所有的特性并添加了部分特性。1const blob = new Blob() TODO:]]></content>
  </entry>
  <entry>
    <title><![CDATA[系统样式设计]]></title>
    <url>%2Farchives%2F60273c5f.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[规范团队项目]]></title>
    <url>%2Farchives%2F95508531.html</url>
    <content type="text"><![CDATA[几个角度规范项目开发 eslint 对js、ts以及在vue项目中的js代码进行质量和风格的检查。 stylelint 对css代码，包括sass，less等代码的风格和质量进行检查。 prettier 专注于对代码风格的修复，可以结果上面两个插件对代码进行自动修复。 editorconfig用于编辑器的默认行为，比如新建一个文件、新起一行、一个tab键的默认格式等。 .gitconfig 用于配置当前项目git的默认行为，比如下载的代码是lf还是crlf（mac和windows同学最对碰到的问题）,如果使用个人电脑，需要不同的项目对应不同user.name 等需要配置。.git/config文件。 cz工具能够对commit信息进行编辑。 husky通过对git add、commit和publish过程的介入，对项目本地化规范。 eslinteslint通过在项目根目录配置eslintrc.*文件。通过parse选项对文件进行分析。eslint 会从当前文件依次向上检查配置文件，直到文件系统根目录或则碰到一个root: true 的配置文件，利用这个可以给mono配置不同的配置检查，配置文件主要包含一下内容 env 和 globals 针对全局变量中的检查，比如window变量，document变量等，nodejs的__dirname等等。env 相当于globals的合集。 parse 和 parseOptions 解析器和解析器选项。 默认是esprima,可以配置成@babel/eslint-parser的 ，支持ts @typescript-eslint/parser 和 支持vue的eslint-plugin-vue。 rule 配置不同归的规则，key、value形式的对象。value 0 1 2 表示禁用，警告和错误。支持数组的形式调用。数组第二项是rule的参数。 extends，返回一个有config属性的对象。config属性对应的是配置文件，见后文如何提供一个eslint-plugin。extends都是由插件导入。 plugins 提供rules的解析，和extends的区别是plugin 提供的是rule规则，但是还未配置。所以一般使用plugin后需要配置相应的extend。plugin 还提供了processor 能力。 processor 是由plugin 提供，能对非js文件中的js片段提取进行eslint检查。一般都是对应Plugin的extend配置提供。 overrides 可以覆盖默认的配置，会和全局的定义的配置进行合并 eslint-plugin-vue https://eslint.vuejs.org/rules/ 下面配置vue3 eslint为例 npm i -D eslint-plugin-vue123456789101112131415161718192021222324module.exports = &#123; env: &#123; node: true, browser: true &#125;, globals: [ '__webpack_public__path__', // 忽略代码中webpack相关变量 ] parse: 'vue-eslint-parse', // 解析vue中template parseOptions: &#123; parse: '@typescript-eslint/parse', sourceType: 'module' // ... 其余@typescript-eslint/parse parseOptions &#125;, plugins: [ 'vue' // eslint会默认添加eslint-plugin-vue '@juqery/test', // @juqery/eslint-plugin-test '@test' // @test/eslint-plugin @开头总是会处理成组织名 ], extends: [ 'plugin:vue' // 去eslint-plugin-vue 包中导入config对象 'test', // eslint-config-test包中导入 // 默认前缀是eslint-config ]&#125; plugin浅解析123456789101112131415161718192021222324252627282930313233// 包 eslint-plugin-xunservermodule.exports = &#123; rules: &#123; 'xxxx': () =&gt; &#123; // rule 定义 create() &#123; &#125;, meta() &#123; &#125; &#125; &#125; config: &#123; vue3: &#123; // 使用时先在plugin中添加rule定义 plugins: ['xunserver'], 然后extends: ['eslint-plugin-xunserver/vue3 或者eslint-plugin-xunserver/vue2'] env: &#123; node: true, browser: true, &#125;, extends: [ 'other config' ] &#125;, vue2: &#123; // 大致同上 &#125; &#125;, processor: &#123; // processor 对象 'xxx': &#123; &#125; &#125;&#125; stylelintstylelint 配置上同eslint类似。从当前文件开始依次向上寻找.stylelintrc.js配置文件，直到找到为止。同eslint区别是默认都是root配置。大致配置如下 customSynax，定义解析器，比如在vue和html中使用就需要配置，一般和override搭配使用 extends, 继承其他配置，可以实现插件和customSynax的引入，和eslint有区别，extends大部分时候还用来配置插件。配置在后面的覆盖前面的，extends引入的会被覆盖。 plugins，通过插件提供新的规则，一般插件只提供了规则，但是未配置，需要extends配置或者自行配置。 overrides 能针对不能的文件类型使用不同的配置规则。比如stylelint-config-html/vue 实现了vue的特殊处理。 rules 对不同的规则配置，null表示规则不生效，其余需要参考rule的实现，数组形式如果第二项是对象，则认为是第二参数。通用的参数有disableFix，message两个关注的。一个可以不处理fix，一个可以自定义报错信息。 ignoreFiles 忽略文件。第三库不使用stylelint recssReasonable System css， 通过style-config-recss 实现规范 less sass 和 stylus 的解析使用别人配置好的stylelint-config-standard、stylelint-config-standard-xx 实现，其中stylelint-config-standard是在 stylelint-config-recommend 基础上实现。 如果是自行配置需要，overrides 对应的less、scss和stylus文件，解析器是postcss-less postcss-scss 和 postcss-styl vue需要安装postcss-html 和对应的postcss-less postcss-scss 等 解决prettier冲突同理stylelint不解决格式上的问题，需要关闭和prettier冲突的rules。 实现一个extend123456789modules.exports = &#123; extends: ['others extends'], overrides: [ &#123; file: ['*.vue', '**/*.vue'], customSynax: 'postcss-html' &#125; ]&#125; prettierprettier 是一个format工具，eslint和stylelint同时具有lint和format功能，执行顺序是eslint =&gt; prettier 或者stylelint =&gt; prettier。prettier 的配置文件比较简单，一共就10多个选项，使用时指定需要使用的文件即可，prettier在项目中使用意义不大，主要是不能在codeActionSave中使用。目前prettier对css 和 js的格式化都交给对应的格式化工具，不够prettier 对其他语法的格式化还是比较好用，还是建议在编辑保留。prettier还会使用editorconfig中的配置来初始化配置，如果新建文件总是报错飘红，建议检查editorconfig 和 prettier中冲突的部分。 vscode中引入格式化工具vscode 区分为工作区和用户区配置（本地和全局），vscode提供了两种format方式，一种是codeActionOnSave，表示保存时调用格式化工具。另一个是defaultEditor: ‘xxx’, 表示使用快捷键格式化时调用的工具。 codeActionOnSave和formatOnSave， formateOnSave是defaultEditor在保存时调用的方式，现在基本启用。codeActionOnSave支持多个格式化程序依次调用。vscode插件在初始化时会向vscode注册format功能 vscode针对不同类型的文件能够采用不同的配置，”[html]”为html类型的文件采用特定的配置。 vue中template如何格式化vue中template中规范prop能够保证良好的编码思路。建议加上vue/attributes-order。 husky、lint-stage、commitizen和cz-customizable husky 用于在git的各种阶段执行脚本，如果脚本返回错误，停止流程。 list-stage 用于只校验暂存区文件，提高lint速度，在校验文件时，会从文件的当前的目录开始查找最近的配置，在根目录配置baseconfig，子目录继承。 commitizen是一个检查commit message的工具。支持各种adapter。cz-customizable 是对应的adapter。安装好后使用git-cz代替git commit。该方案不能很好的和vscode结合，不采用。 commitlint 检查commit msg是否合规，结合husky实现commit信息的校验。 husky安装配置 pnpm add husky -Dw // 项目安装在根目录pnpm set-script prepare “husky install” 配置package.json script.prepare 脚本pnpm husky install // 初始化huskypnpm add ‘./husky/pre-commit’ ‘lint-stage’ // 不同包调用自身的lint-stage 方法pnpm add ‘./husky/pre-push’ ‘pnpm -F “./packages/**” run lint’ // 全局校验 list-stage在子项目中单独配置.lintstagedrc.js文件,文件内容如下。12345678// .lintstagedrc.jsconst baseConfig = require('../../.lintstagedrc.js')module.exports = &#123; ...baseConfig, '*.&#123;js,jsx,ts,tsx.vue,html&#125;': ['eslint --config .eslintrc.js'], '*.&#123;css,scss,sass,less,styl,vue,html&#125;': ['stylelint --config .stylelintrc.js'] '*.&#123;ts,tsx,js,jsx,json,html,yml,css,less,scss,md,sass&#125;': ['prettier --write']&#125; commitlint pnpm add commitlint -Dwpnpm husky add ‘./hasky/commit-msg’ ‘pnpm commitlint –config .commitlintrc.js –edit $1’添加.commitlintrc.js文件1234567891011121314151617181920212223242526272829303132333435363738/** * build : 改变了build工具 如 webpack * ci : 持续集成新增 * chore : 构建过程或辅助工具的变动 * feat : 新功能 * docs : 文档改变 * fix : 修复bug * perf : 性能优化 * refactor : 某个已有功能重构 * revert : 撤销上一次的 commit * style : 代码格式改变 * test : 增加测试 * anno: 增加注释 */module.exports = &#123; extends: ['@commitlint/config-conventional'], rules: &#123; 'type-enum': [ 2, 'always', [ 'build', 'ci', 'chore', 'docs', 'feat', 'fix', 'perf', 'refactor', 'revert', 'style', 'test', 'anno', ], ], &#125;,&#125;; eslintrc.js和eslintignore 文件eslint（stylelint）在执行时，按照如下执行。 确定当前使用的eslint文件位置，确定执行的上下文。 确定需要处理的全部文件 根据上下文中中的.eslitingnore、命令中的–no-ignore、–ext 确定需要处理的最终文件合集 一个一个文件的查找eslintrc配置，找到配置后执行eslint。配置的查找规则从当前需要检查的配置往上级目录查找，知道文件系统的根目录或者碰到一个root:true的配置文件，这种方式相当于变相实现了继承（stylelint在查找到第一个配置文件后停止，意味着需要自行实现继承）。 vscode中eslint和stylelintvscode执行逻辑大致同上，只是确定文件的方式有所不同。 vscode打开时加载项目根目录下的ignore文件 根据vscode中的no-ignore 和插件配置的生效文件确定最终文件。 lint-staged 如何实现只检查部分文件eslint，styllint和prettier均支持stdin方式确定输入文件。lint-staged把需要检查的文件和配置一一对比，确定出需要执行命令的文件，添加在命令后。lintstagedrc的查找方式从被检查的文件开始向上查找，lintstagedrc中指令执行的上下和本身相同 1234// lintstagedrc.jsmodule.exports = &#123; "*.(vue,ts,tsx,js,jsx)": "eslint" // 相当于执行在.lintstagedrc.js所在目录下执行eslint xx.js命令&#125; monorepo格式化解决方案monorepo仓库有如下难点需要解决。 不同项目使用不同技术栈，采用的规范不一致。 CI和lint-staged中的校验是全局的。 vscode编辑器总是从项目根目录读取工具并加载ignore文件。针对以上问题，解决方案如下 不同的子项目在编码时，建议到对应的子目录下编写，目的是为了匹配vscode的格式化功能。 不同子项目在配置时，通通引用公共的配置 ci和git 校验时采用调用各子项目中的lint工具。]]></content>
  </entry>
  <entry>
    <title><![CDATA[browlist]]></title>
    <url>%2Farchives%2F5bc71ff9.html</url>
    <content type="text"><![CDATA[作用配置当前项目面向的平台，可以帮助babel、postcss识别出当前内容中哪些是需要转换 配置支持字符串和对象的配置防范，对于字符串的配置可以使用npx browserlist string 检查字符串配置是否有效。TODO: 字符串配置对象详解]]></content>
  </entry>
  <entry>
    <title><![CDATA[babel]]></title>
    <url>%2Farchives%2Fb197ee89.html</url>
    <content type="text"><![CDATA[简述babel能把es6+转换成es5代码，有两方面转换，一是对语法的转换，比如箭头函数class语法、async语法等。二是对新的api比如数组和字符串上新添加的方法。 组成babel是由@babel/core 为主，通过一系列plugin来完成转换。 配置babel通过项目根目录下的配置文件处理一般都用babel.config.js 或 .bebelrc，两个区别是js需要按照js文件格式导出，rc文件只用写一个对象即可。 presets一系列已经配置好的插件合集，通过对外暴露options来对内部plugin进行配置。presets的是由后往前解析的，意味申明在后面的preset会先执行，每一个preset其实就是一个返回bable配置对象的函数。123456exports.myCustomPreset = (presetOptions) =&gt; &#123; return &#123; presets: ["@babel/preset-xxx"], plugins: ["@babel/plugin-xx"] &#125;&#125; plugins对于同一段代码的解析，由前往后。配置方式和presets一样，plugin总优先于presets中的插件先执行。 ###1234567module.exports = &#123; plugins: [ ['@babel/plugin-runtime-transform', &#123; xx: xx &#125;] ]&#125; @babel/preset-env targets 直接配置target属性，默认使用项目下browserlist文件（建议使用） useBuiltIns: ‘entry’,引入浏览器不支持的全部polyfill，即使未在代码中使用。 ‘usage’，在各个使用的地方应用，可能会存在重复的情况 corejs: 3 bebel/preset-env 和 @bebel/plugin-transform-runtime配置targets后，preset-env查询targets所支持的特性，过滤出生效的插件，每个插件在声明时需要指定能够生效的浏览器 polyfil主要包含3个方面的内容 corejs，对高级api的支持，比如Object.defineProperty 这一类的api。或者在原型添加某些方法，比如数组新增的那些方法 各种helper函数，比如箭头函数和class语法，生成各种helper函数。 regenerator，对async语法糖进行转换 preset-env对polyfill的处理是，corejs和regenerator全局注入，helper在模块注入（在模块现场申明一个helper，和transform-runtime区别在transform-runtime的helper是由corejs导出的，每个地方都可以复用），这样会污染全局环境。 @bebel/plugin-transform-runtime 将全局的注入全部改成模块的注入。缺点是不支持target，总是会做polyfill操作。 得到一个最终的版本12345678910111213module.exports = &#123; plugins: [ ['transform-runtime', &#123; corejs: 3 &#125;] ], presets: [ ['env', &#123; corejs: 3, useBuiltIns: 'usage' &#125;] ]&#125; 执行实现配置文件导出配置文件即可，在需要引用的地方extends合并。需要注意的时，preset文件中不能包含extends]]></content>
  </entry>
  <entry>
    <title><![CDATA[esbuild-loader]]></title>
    <url>%2Farchives%2Ff6187c2d.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[最全前端基础设计项目搭建 (一) 项目初始化和脚手架搭建]]></title>
    <url>%2Farchives%2Fc5806e5.html</url>
    <content type="text"><![CDATA[目标打包工具webpack 和 vite 统统都要，主应用采用webpack，部分子应用采用vitets-lodaer，babel-loader和esbuilder 全部整齐。 微前端qiankun、micro-app和 webpack mf 以及 vite mf。 语言ts + sass 要求 所有子应用均支持本地单独部署 支持CICD，githubpage和gitee自动发布，且能支持自动感知 http模块需要抽离到公共库，公共库内容支持开发调试。 monoRepo，pnpm 有代码守护，支持CDN 初始化项目目录 pnpm init 生成package.json 创建packages目录，创建pnpm-workspace.yaml,配置如下 12packages: - "packages/*" 在packages中新建各个子应用，package.json中的name作为应用名称 host应用webpack配置env.js 和 constant.js 配置通过配置dot文件，可以把一些自定义的环境变量注入到打包的流程中，不需要再使用cross-env工具。dotenv包和dotenv-expand， 前者用于读取dot文件中的变量后者用于合并扩展env。dot文件参考vue-cli的实现，命令行 &gt; 系统自带 &gt; .env.[mode].local &gt; .env.[mode] &gt; .env.local &gt; .envwebpack.config.js 通过导出函数返回配置可以获取命令行参数，webpack –config webpack.config.js –mode development。通过不同的mode，先初始化环境变量1234567// webpack.config.jsmodulex.exports = (env, arg) =&gt; &#123; const mode = arg.mode || 'production'; loadEnv(mode); // 加载环境变量 const config = require(`$&#123;mode&#125;.config.js`) return config;&#125; constant.js 用于定义一些webpack配置中需要的常量。 webpack-merge处理不同mode的config。通过webpack-merge库实现webpack.config.js的合并。12345const &#123; merge &#125; = require('webpack-merge');const baseConfig = require('./base.config.js');module.exports = merge(baseConfig, &#123; // ...&#125;) context、entry和extensions123456789&#123; // context: path.resolve(), // 绝对路径 entry: &#123; main: './src/index' // ./开头 &#125;, resolve: &#123; extensions: ['.vue', '.ts', '.js'] // 常用的写在前面 对entry同样生效，因为entry本质是虚拟一个新文件。 &#125;&#125; outputdevelopment和production区别不同，development需要方便调试。12345678910// development.config.js&#123; output: &#123; path: path.resolve('dist'), // 输出文件目录 filename: '[name].js' // 生产环境采用添加chunkhash配置 chunkFilename: '[name].chunk.js' // 生产环境 添加 contenthash clean: true, // 每次build均删除dist uniqueName: process.env.APP_NAME // 注意每个应用加载的变量的需要不一样，而且不能被覆盖。 &#125;&#125; alias和tsconfig.json中的paths使用js文件将tsconfig.json中的compilerOptions.paths和webpack中的别名对应起来，避免重复修改。两处格式不同需要做一些转换。配置tsconfig.js 两个作用。一是对ts-loader、babel-loader(ts)、esbuild-loader生效，这几个loader在处理时会忽略部分配置。二是部分编辑插件会根据配置项处理路径补全，错误提示等信息。12345678910111213141516171819202122232425262728293031323334353637383940&#123; "compilerOptions": &#123; "target": "esnext", // ts-loader 编译代码目标，总是设置为esnext，表示ts不处理高级语言，交给babel处理 "module": "esnext", // 针对import 语句的处理，esnext 不处理 import 语句等。交给webpack或者rollup处理 "strict": true, // 严格模式 "jsx": "preserve", // preserve 表示支持jsx但不不处理（交给babel处理），如果设置为none表示不支持jsx。 "moduleResolution": "node", // module解决方案 "skipLibCheck": true, "esModuleInterop": true, "allowSyntheticDefaultImports": true, "forceConsistentCasingInFileNames": true, "useDefineForClassFields": true, "sourceMap": true, "baseUrl": ".", // paths路径补全基于baseUrl "types": [ "webpack-env" ], "paths": &#123; "@/*": [ "src/*" ] &#125;, "lib": [ // 能够使用的全局变量 "esnext", "dom", "dom.iterable", "scripthost" ] &#125;, "include": [ "src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "tests/**/*.ts", "tests/**/*.tsx" ], "exclude": [ "node_modules" ]&#125; devServer配置资源配置public 和 assetspublic表示需要被直接拷贝到生成目录下的文件夹，代码中引用时通过./public/xx 的方式， assets 是项目中依赖的资源，会经过webpack loader处理。vue会把除了绝对路径的资源都交给webpack处理，导致没办法对public文件使用相对路径。项目规定如下 public全部使用相对路径，template中通过修改属性值为首字母大写可以跳过vue-compiler处理，style中css-loader 通过options.url.filter 添加自定义函数，less和sass loader 建议不处理资源，都交给css-loader 处理 assets相对路径和绝对路径均可，建议使用别名。]]></content>
  </entry>
  <entry>
    <title><![CDATA[npm]]></title>
    <url>%2Farchives%2Fa1345b2b.html</url>
    <content type="text"><![CDATA[npm 下载包流程 检查项目中是否存在package-lock.json 文件，如果有，比较和package.json和lock.json（一般都不一致），如果版本兼容则使用lock.json 定义的依赖，如果不兼容使用package.json 并更新。 检查缓存，无缓存使用,registry中获取包的tgz压缩包，下载(npm-registry-fetch)到本地缓存目录。 从缓存目录解压到node_modules目录，tgz是一个package目录，解压时未包含package目录 npm 本地添加离线包公司处于内网环境无法下载包，需要自行添加包。 使用npm-pack-all 制作tgz离线包。 上传离线包到npm仓库 网络下载或者使用npm i xxx.tgz安装 yarn 常用命令npm i =&gt; yarnnpm i xx =&gt; yarn add xx -Snpm i xx -S =&gt; yarn add xxnpm i xx -D =&gt; yarn add xx -Dnpm i -g xx =&gt; yarn global add xxnpm uninstall xx =&gt; yarn remove xx mutilRepo 和 monoRepo当团队项目变多，而且各个项目存在关联时，就需要采用monoRepo方式管理。传统的muti的lRepo将项目分散到各个仓库。会出现如下痛点 不能批量操作，操作某个项目需要到相应的目录下操作。项目多起来简直就是地狱 比如一个组件库升级了版本，需要在组件库修改版本号，发布npm。然后业务库再更新package.json 重新安装依赖。 组件库如果是break change 的更新，业务库可能会忘记及时更新 monoRepo出现会解决这些痛点，可以在一个地方对所有仓库进行，仓库相互之间能互相感知。 npm 痛点npm1 npm2项目下根据项目的package.json下载依赖到node_module，如果依赖存在依赖其他的情况会在node_modules/xxx/node_modules, 而且递归下去。 出现问题是大量重复的包被安装，而且文件目录过生对于查找耗时严重。 npm3 后优化了结构扁平化处理，如果一个依赖没在项目node_modules 出现，依赖的依赖就会安装在项目的node_modules 中，如果两个依赖同时依赖一个版本不一致的库，先安装的依赖在项目下，后安装按照npm1 npm2 处理。这样做也有问题 1.扁平的算法耗时严重。2. 项目未在package.json 中声明的依赖也可以直接引用，会出现不确定性(往往是自动补全代码带来的)。 3. 对于相同依赖的不同版本，完全是按照安装先后顺序来的，会有不确定的情况，这种会对缓存有较大影响（后续的package-lock.json专门解决这个） pnpm 解决的痛点pnpm通过软链接的方式把扁平的结构放到.pnpm目录中，同时.pnpm 通过npm2 的方式保证了包的正确性，子package中的node_module也是引用的root node_module/.pnpm的包。 pnpm 生产实践TODO: n 包管理器是啥ni xx -S =&gt; npm i xxx -Snr =&gt; npm runnrm =&gt; npm uninstallnx =&gt; npm execute n 会自动检查项目下存在package-lock.json、yarn.lock或者pnpm-lock.yaml 自动选择包管理器安装。 .npmrc、.yarnrc和.pnpmrcnpmrc格式是key=value的形式 value和key有空格需要用””包起来yarnrc格式是key value 的形式，有空格需要用””包裹pnpmrc使用的npmrc配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[css选择器学习]]></title>
    <url>%2Farchives%2Fc9ab05c.html</url>
    <content type="text"><![CDATA[选择器优先级 0 通配符，部分逻辑组合伪类:not() :where() :is() 1 标签选择器 10 类选择器、属性选择器、伪类 100 ID选择器 1000 style属性内联 10000 !important 选择器。从上面可以看到，无论如何都不能使用!import，!important 只能用于动态重置js设置的代码（js重置js代码，不能在css文件中硬编码）。如果需要提升优先级，可以采用.xxx.xxx.xxx、.xxx[class][class]这两种形式 不同等级的选择器不能通过数量的堆积来跨越，比如一个ID选择器，即使重复10个class选择器也不能覆盖，正是因为这种无法覆盖的特性，禁止使用ID选择器，一定是禁止。123456789101112131415161718&lt;style&gt; /* 优先级 2 */ .container .text &#123; color: red; &#125; /* 重复书写 优先级 3*/ .text.text.text &#123; color: blue; &#125; /* 上面方法或许不优雅 */ .text[class][class] &#123; color: green; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;p class="text"&gt;文字&lt;/p&gt;&lt;/div&gt; 查找性能 ID选择器 class 标签 通配 属性 部分状态伪类 优先使用class选择器，属性选择器仅特殊使用。 css渲染的理解css渲染的查找循序是从右往左，css解析时会把树形的css结构变成hash的结构方便快速查找。在渲染某个dom时，先从右往左检查是否命中css选择器。如果命中采用优先级高的，如果未命中检查是否有继承值，如果还没有采用默认值。 a链接变色怪事额外需要记住，伪类的优先级和类选择器相同 css中大小写问题HTML中标签和属性不区分大小写，但是属性区分大小写，所以有如下规则 标签选择器不区分大小写 属性选择器前面的属性不区分，后面的属性值区分，可以通过在]前面添加i 表示不区分。 [class=TEXT i] [ID=TEXT i]。 class和ID选择器本质上是属性值选择器有区分。 特殊命名可以使用-开头的css命名，可以起到强调作用.-important 不要出现一下命名.box .title .text .header .main .aside .warnning .success .red .green 都加上前缀。 html标签中获得灵感header body aside main nav section content summary detail option img footer a li g(roup) desc x(box) 这几个加上前缀,百试不爽。 html属性中获取radio button checkbox range number email tel color date url time file cell log menu log tab list panel tree row region item 状态类（禁止在css中声明，只能配合用）active invalide disabled selected checked 需要注意的是所有的转态 css命名最佳实践 嵌套层级不能过深 尽量低优先级 不要div.text 这种意义不大的选择器 公共结构、公共模块、UI组件、精致布局都不适合面向属性的命名 细枝末节和特殊场景微调适合面向属性的命名 状态类不能单独使用 js中后代选择器逻辑12345&lt;div&gt; &lt;section ID="test"&gt; &lt;div class="target"&gt;&lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 1document.querySelector("#test").querySelectorAll("div div").length // 1 js中后代选择器是作用域是全局的，针对每一个子节点检查css命中情况。而且是在全局范围内检查。target满足全局范围内的div div所以命中。 如果需要只在子节点css域检查，需要添加 “:scope div div” 谨慎使用&gt;子选择器会强制绑定DOM结构，违背了分离原则。可以采用具名的后代选择器实现限制选择 相邻兄弟选择器和兄弟选择器 会忽略文本节点和注释节点 可以实现:first-child 效果 li+li 和 :not(li+li) xxx + *。:first-child必要是第一个子节点，+的应用范围大一些。 1234567891011121314&lt;style&gt; li + * &#123; color: red &#125;&lt;/style&gt;&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;!-- asd --&gt; &lt;li&gt;&lt;/li&gt; 123 &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 配合状态伪类实现css上面的逻辑交付 || 属于选择符用于表格中通过colgroup 设置样式。 .xxx || td 查找td 同时属于.xxx。 元素选择器 不能重复自身(废话) 可以简单提升优先级比如 html body .text提升了.text。 组合时必须写在前面input[type=radio]，而且尽量不写。 ID选择器dom中可以存在多个相同的id，id选择器也会正常命中，包括querySelectorAll。还有个历史原因ID属性会被绑定到window同名变量上，多个相同id会绑定成数组。 属性值选择器格式类似[attr=”xxx”]，没得空格可以省略引号。 [attr=xxx] 完全匹配 [attr~=”xxx”] 单词匹配 匹配class=”xxx xxx1” 但是不匹配 class=”xxx1xxx”。使用场景是九宫格定位时 class=”center top” class=”left bottom” 这一类场景出现 [attr=|”xxx”] 开头单词部分(或者全匹配)匹配 匹配 class=”xxx-x xx” 不匹配 class=”xx xxx-x”或则 class=”xxx x”，用于部分前缀匹配。 [attr^=”xxx”] 前缀匹配，能够包含前一匹配。可以用于判断a链接类型，展示不同图标。 [attr$=”xxx”] 后缀匹配 可以用于判断文件类型展示不同图标。 [attr*=”xxx”] 包含匹配 可以匹配当前链接是不是站外地址 通过动态的添加css可以实现过滤效果。1234567const search = (searchValue) =&gt; &#123; styleEl.innerHTML = ` [data-search*="$&#123;searchValue&#125;"]: &#123; display: none &#125; `&#125; 通过兄弟选择器实现展示隐藏通过添加transition保证从a到img中，不会突变显示。123456789101112&lt;style&gt; .target-button:hover ~ .visible-img, .visible-img:hover &#123; visibility: visible； &#125; .visible-img &#123; visibility: hidden; transition: visibility .2s; &#125;&lt;/style&gt;&lt;a class="target-button"&gt;&lt;/a&gt;&lt;img href="xxx"/&gt; 通过:focus 伪类实现下拉暂存效果通过设置tableIndex实现元素能否被聚焦tabIndex=0 不能被聚焦tabIndex=-1 不能被tab检索，但是能点击触发:focustabIndex=1 可以被tab检索也能触发:focus 1234567&lt;style&gt;.target-button:focus ~ .visible-img &#123; visibility: visible;&#125;&lt;/style&gt;&lt;div classk="target-button" tabIndex="-1"&gt;任意元素&lt;/div&gt;&lt;img class="visible-img" href="xx"/&gt; 上面实现在苹果下有问题，需要在最外层添加tabIndex=-1（不能在body上） :ctive 伪类匹配任意元素，当鼠标按下时触发，抬起时消失。12345678&lt;style&gt; div:active::after &#123; content: "active伪类"; &#125;&lt;/style&gt;&lt;div&gt; 点击我&lt;/div&gt; 可以用于埋点数据。1234.xxx:active::after &#123; content: url(xxx); display: none;&#125; 不使用display: none或者visibility: hidden隐藏内容这两种方式会导致键盘检索失效。建议通过下面方法或者opacity:0 来实现1234.hidden &#123; position: absolute; clip: rect(0 0 0 0)&#125; focus-within子元素触发focus会触发，用于下拉中有操作的情况。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue3]]></title>
    <url>%2Farchives%2F9a707413.html</url>
    <content type="text"><![CDATA[基础教程setupsetup 函数只会执行一次，如果是if语句中创建的部分配置，可能无法访问。组合式函数需要同步调用，但是可以使用await语句。setup 单文件下如果语句使用了await 会自动将setup设置为async 模板中表达式的作用域是ctx，在模板中使用赋值语句如下1234&lt;div class="about"&gt; &lt;button @click="increaseCount"&gt;&#123;&#123; (a = count) &#125;&#125;&lt;/button&gt; &lt;button&gt;&#123;&#123; a &#125;&#125;&lt;/button&gt;&lt;/div&gt; 会被转换如下12345678910import &#123; toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock &#125; from "vue"export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createElementBlock("div", &#123; class: "about" &#125;, [ _createElementVNode("button", &#123; onClick: _ctx.increaseCount &#125;, _toDisplayString((_ctx.a = _ctx.count)), 9 /* TEXT, PROPS */, ["onClick"]), _createElementVNode("button", null, _toDisplayString(_ctx.a), 1 /* TEXT */) ]))&#125;// Check the console for the AST 挂载到this data上的值全部变成响应式1234567891011121314151617export default &#123; data() &#123; return &#123; value: null &#125; &#125; created() &#123; const test1 = &#123; value: 1 &#125; this.value = test1; // this.value 已经是一个proxy对象 console.log(this.value === test1 ) // false &#125;&#125; :style 支持数组的样式对象，vue会自动补齐前缀1&lt;div :style="[styleObject1, styleObject2]"&gt;&lt;/div&gt; ref 和reactiveref用于对非引用对象创建响应式reactive 对数组或者对象创建响应式 对一个响应式对象调用响应式依旧是响应式。。。。。 对reactive 原对象修改值，不会引起响应式变动，但会影响值。12345678const obj = &#123; test: 1&#125;const state = reactive(obj); obj.test = 2 // 不会导致响应式监听state.test === 2 // 但是读取值时会变动，可以用于手动控制视图更新 ref的解包 声明在顶层作用域的ref在模板中会自动解包，:count=”count” 相当于:count=”count.value” 子组件收到的是原始值， 不是ref对象。 state.count 就不能自动解包， 因为只有state是顶层对象 模板计算值如果是一个ref，会自动解包 不需要使用count.value 如果一个ref是reactive 对象（不包括数组和其他集合类型set，map）的property， 那么和普通的property表现相同， 会自动解包12345678const count = ref(9);const state = reactive(&#123; count&#125;)state.count++ // 不需要使用 state.count.value++const state1 = reactive([count])state[0].value++ // 数组需要 计算属性计算属性返回一个ref（将返回值用ref()包装起来， 如果返回的是一个reactive对象，就是ref(reactive(xxxx)), 如果是其他响应式对象，处理方式同上），支持set，get形式。可以用于v-model。12345678computed(&#123; get() &#123; return props.modelValue &#125; set(value) &#123; emits('update:modelValue', value) &#125;&#125;) style 和 class 绑定 内联式1&lt;div :class="&#123;'is-error': isError, active: data.active.value, success: state.success&#125;"&gt;&lt;/div&gt; 1234567const isError = ref(false);const data = &#123; active: ref(true)&#125;const state = reactive(&#123; success: true&#125;) 对象式和计算属性对象内部通过属性取值获取值（存疑），所以可以传入一个reactive对象。对象的键名作为class名称，属性值表示是否渲染1&lt;div :style="styleObject"&gt;&lt;/div&gt; 12345678910const styleObject = reactive(&#123; active: false, 'is-error': true&#125;)// 同样可以使用计算属性const active = ref(false)const styleObject1 = computed(()=&gt; (&#123; active: active.value &#125;)) 数组式:class=&quot;[active, isError ? &#39;is-error&#39; : &#39;&#39;]&quot; 可以传入一个空字符串不绑定class，数组每一项计算值直接作为class名称 style绑定对象时，对象的键作为属性，对象键值作为属性值。绑定数组时，每一项是一个样式对象。同理也支持字符串（空字符表示不渲染），可以通过alt html属性查看定义 1&lt;div :style="['color: red', '', [&#123;color: 'blue '&#125;]]"&gt;&lt;/div&gt; // blue 样式绑定是自动添加浏览器前缀 v-if 和 v-forvue3 中 同时使用v-if 会先执行，vue2 中 v-for 会先执行，如果同时使用，建议使用计算属性或者将v-for 提升到template上面 vue3中的v-modelvue3 中v-model 语法糖有所变化 在原生html 表单控件中, 通过添加.lazy 修饰符可以将input 替换成change事件 1&lt;div :value="xxx" @input="event =&gt; xxx = event.target.value"&gt;&lt;/div&gt; 在组件中使用的是:modelValue 和 @update:modelValue实现，替代了.sync 功能 同时组件中支持v-model:arg1=”xxx” 这种参数。展开来是 :arg1=”xxx” @update:arg1。所以v-model是v-model:modelValue的简写。完全替代了.sync 修饰符 生命周期 组合式api的生命周期始终在选项式前面执行 组合式生命周期少了created和beforeCreate setup在beforeCreate 前面执行 watch 和 watchEffectwatch 用于副作用操作，支持同步和异步的方式，能对ref、reactive对象（属性变化时监听，浅监听，支持第三个参数设置 { deep: true }）、getter函数（同计算属性），或者数组监听（任何一个变化都触发）。watchEffect 时一种自动监听的方法，会默认执行一次回调函数，收集依赖（同计算属性），同时也支持异步的方式， 不过只会收集前面同步的依赖（比如第一个await 前的属性）。 watch如果一个getter函数返回的是响应式对象， 默认是浅监听，需要设置deep: true 才能生效。reactive对象直接作为监听项默认是深度监听 ，如果需要浅监听需要使用getter函数。12345678910111213const url = ref('https://www.xx.com');const state = reactive(&#123;url: 'xxx'&#125;)const state1 = reactive(&#123; // 作为监听项时， 默认是深层监听，如果只想是浅，用 getter 函数, deep设置为false也无效。 data: &#123; url: 'xxx' &#125;&#125;)const data = ref('')const stopRequest = watch(url, async (newValue, oldValue, cleanFn) =&gt; &#123; const res = await request(newValue); data.value = res.data;&#125;)// 上述监听值还可以为 ()=&gt; url.value 、 [()=&gt;url.value, url]、 () =&gt; state.url state。 watch函数会返回一个stop函数，通过调用stop可以停止监听。 watch回调函数支持第三个参数用于清理之前的正在执行的副作用，比如每次回调时清理前一个未完成的回调。cleanFn(() =&gt; { // 执行清理逻辑， 比如放弃上一次请求， 始终使用最新请求 })，会在每次回调前调用（第一次回调不调用） 1234567watch(count, (_, __, clearFn) =&gt; &#123; const timer = setTimeout(() =&gt; &#123; console.log(count.value); &#125;, 2000); clearFn(() =&gt; clearTimeout(timer));&#125;); watch函数第三个参数时选项，{deep: boolean, immediate: boolean, flush: boolean}, 其中flush默认时pre 表示在dom更新前调用，post表示更新后（和设置pre然后nexttick()相同）。flush中pre，post都有缓冲队列机制，在同步操作中多次调用会放入到队列中，只会执行一次。这个机制同vue的默认机制。同时可以设置flush: sync 取消缓冲队列, 而且会立刻同步的调用的回调 12345state.data.url = 123; // 语句后立刻执行一次回调console.log("xxx"); // 然后打印 xxxstate.data.url = 1234; // 语句又立刻执行一次回调// 如果上面是post或者pre 则会打印 xxx 然后只执行一次回调 watch 同步创建watch监听器会在组件销毁时自动停止， 如果是异步创建的监听器，需要手动设置停止，尽量少创建异步监听器，可以使用判断语句异步转同步。 ref把一个ref绑定到模板ref属性上，会自动绑定ref，同react。使用起来同ref对象一样，需要通过ref.value 来获取。 组件defineProps和defineEmits都是sfc setup下面的宏。在sfc编译的时候回解析到相应的位置。 defineProps 详解 defineProps定义的属性会解析成选项式中props属性。defineProps的返回值解析成对setup(prop)中prop的引用。由于宏原因，defineProps中不能访问setup内部声明的变量，但是可以访问引用进来的。因为引用语句在总是上层 props如果接受到undefind值会触发自动default，如果未设置default，值为undefined。Boolean类型会自动转换成对应boolean值 props 是一个响应式对象，需要避免对齐解构，如果需要解构使用toRefs 或者toRef(props, xxx) 123456789101112131415161718192021const props = definedProps(&#123; count: number, info: null, // 或者undefined，设置这两个值时会跳过类型检查 data: &#123; type: String // 支持对象式的配置 &#125;&#125;)// 会转换成export default &#123; props: &#123; count: number, info: null, // 或者undefined，设置这两个值时会跳过类型检查 data: &#123; type: String // 支持对象式的配置 &#125; &#125;, setup(_props) &#123; const props =_ props; &#125;&#125; &lt;CustomComp count /&gt; 实际是&lt;CustomComp count=&#39;&#39; /&gt;的缩写，所以除了boolean类型总是会得到一个空字符串,boolean 类型在收到一个’’或者undefined时会触发default 模板中可以自动使用prop属性，比如上面的count, 可以直接，实际上也是宏的作用，在解析模板时，如果是变量是setup定义的，会使用ctx.count, 如果是宏定义的会使用宏的props.count, 如果都没定义使用ctx.count defineEmits同defineProps一样会到解析到{emits: [] }中，支持对象语法实现拦截器或者hook，可以在每次触发的通过返回boolean进行校验。但是不支持混合书写。defineEmits返回的结果是setup(props, {emit: customEmit})中emit的别名，在模板中如果直接使用$emit,使用的是ctx.$emit。也可以把emit暴露到模板中直接使用customEmit(‘xxxx’)； 组件内部实现了事件机制，对组件v-on或者onXxx的prop 会添加订阅，通过emit或者once(vue3 没得once)触发订阅。vue3不能取消订阅，可以通过触发拦截器实现。事件在beforeCreate前初始化，所谓在生命周期任何适合都可以用，可以通过@hook:created 实现对声明周期的监听 透传attribute任何未在组件porps或者emit 声明的都是attribute，默认情况下attribute会绑定到组件根元素上，如果根元素不存在需要手动绑定$attr到制定元素，可以添加inheritAttrs: false 选项取消默认绑定。$attrs对象包含了所有的未声明$attrs, 会将v-on转换成onXxx形式的prop值传入（所以v-on 也可以用v-bind来实现）。通过这个机制可以实现事件的分发，比如可以把某个事件分布到多个子组件上，或则批量的设置样式。 关于事件的思考对于组件v-bind:onXxx和直接v-on:xxx 相同(:onAdd = @add)， 针对原生元素@click 相当于v-bind:onClick。针对以上特性所以在透传attrbute时，可以直接用v-bind 绑定事件,因为事件在处理成onXxx的prop属性值这个特性可以用h函数解释，h函数的第二参数，以on开头的事件会被处理成事件 vue2 特性待研究 插槽直接第三个参数设置为对象传入，每个键是slot name，值是一个函数包括子组件传递的作用域。同理支持动态的slot name。指定插槽选项式使用的是this.$slot,setup() 函数用二参数中的slot属性12345h(CustomComponent, &#123; onClick: () =&gt; state.count++;&#125;, &#123; default: (user) =&gt; h('span', [user.name, user.code]) // &lt;CustomComponent&gt;&lt;template #default="user"&gt;&#123;&#123;user.name&#125;&#125;&#123;&#123;user.code&#125;&#125;&lt;/template&gt;&lt;/CustomComponent&gt;&#125;) 插槽的函数如下，每一个slot都是一个函数，通过传递函数参数实现作用域插槽12345interface ComponentPublicInstance &#123; $slots: &#123; [name: string]: Slot &#125;&#125;type Slot = (...args: any[]) =&gt; VNode[] 因为render函数中，插槽是在子组件中调用的。所以子组件可以控制插槽延迟渲染，可以实现一个组件版本的v-if。这样可以升级权限指令为权限组件，实现更高级的功能。 插槽的生命周期如下，parent init -&gt; parent beforeMounte -&gt; child init -&gt; child beforeMounte -&gt; child mounted -&gt; parent mounted provide 和 inject在vue3 provide 和 inject 的功能可以通过第三方store覆盖比如声明一个store 文件，里面简单的存放响应式对象即可实现。1234const count = ref(0)provide('count', count) // 提供inject('count', ref(2)) // 注入 实际可以用一个store.js实现, 然后在provide和inject的地方引入这个变量进行操作12// store.jsexport const count = ref(0) 组合式函数 组合式函数需要同步调用，因为需要感知当前的组件的实例，也可以在await 后调用(仅局限于sfc 的setup)，编译器会自动添加保存await前的实例。组合函数是逻辑复用的银弹，但不是唯一银弹，无渲染组件可以解决组件复用和逻辑复用。 组合式函数仅会调用一次，如果是有副作用的操作，可以使用watch、effect等操作。 约定组合式函数使用use命名开头 1234567891011121314151617181920212223242526import &#123; onMounted, onUnmounted, ref &#125; from "vue";export const useEventListener = (target, name, callback) =&gt; &#123; onMounted(() =&gt; &#123; // 可以感知当前绑定组件的实例 target.addEventListener(name, callback); &#125;); onUnmounted(() =&gt; &#123; target.removeEventListener(name, callback); &#125;);&#125;;export const useMouse = () =&gt; &#123; const x = ref(0); const y = ref(0); useEventListener(document, "mousemove", (event) =&gt; &#123; x.value = event.pageX; y.value = event.pageY; &#125;); return &#123; x, y, &#125;;&#125;; 指令 不建议在自定义组件上使用自定义指令，组件会透传指令。 自定义组件还是有多个根元素，指令无法正确识别而且$attrs 也无法识别 可以看到内置指令和自定义指令是两回事，自定义指令更多的是对dom操作。通过生成的vnode实现，但是不能改变创建的vnode。 teleporr支持to和disable prop。to变更实际上会导致el的变化，并不会导致重新生命周期。 to支持元素或者选择器 路由 使用params和path不能同时使用，path需要改成name redirect 支持函数，参数是to，可以动态的重定向。重定向中相对路径相对于当前路由 别名是多个path对应一个component, 别名的path也支持相对于当前路由的相对路劲，同时支持params 支持路由组件传参的方式，将params 变成props，导航时设置props: true 即可。 渲染函数和jsx 在setup() 函数或者函数组件中返回vnode，参数都是setup(props, { emits, attrs, expose, slots}) 在render函数或者setup返回函数中，参数形式如下render(ctx)，其中ctx指的是vue实例, 也就是this。 setup暴露的出的属性方法默认不能通过ref查询到，可以通过expose暴露。 插槽slot需要通过slots.xxx() 渲染，而且如果是自定义组件需要通过函数或者对象函数的形式传入1234567891011&#123; render(ctx) &#123; console.log(ctx === this) // true return h('span', /** 没得选项，第二个参数直接变成slot **/, 123) // 不需要使用插槽 return h(CustomComp, () =&gt; 123) // 传入default插槽 123 return h(CustomComp, &#123; default() &#123;return 123&#125;, header() &#123;return 'header'&#125; &#125;) // 使用具名插槽，同时也可以给函数传入参数， &#125; // jsx中可以用&#125; 指令withDirectives(vnode, [directives, params, modifier, data])。通过把vnode包装，实现一个有指令的vnode，可以通过resolvedirective找到指令。 jsx中自定义指令和模板相同，v-model也是相同 事件使用props传入，变成onXxx形式，如果需要添加修饰符，需要将事件响应函数使用withModifiers(fun, [‘self’])这种形式包裹传入。 函数式组件函数组件返回一个vnode。参数同setup相同，需要手动声明函数的props和emits。可以偷懒不声明，到attrs属性中获取，不过就不能获的devtools支持。 声明方式在函数的的静态属性上， 同选项式api相同 插件插件是一个具有install属性的对象（或者就是一个install函数），通过app.use 调用。会传入app和options 全局对象vue3中不能通过vue.prototype.xx 来全局添加属性，需要通过app.config.globalProperties.xxx 来添加全局属性。 响应式基础ref 和 shadowRef当ref的参数是一个对象时，参数会被reactive调用，意味着对state.value.count.xxx 进行修改也会触发state.value 的变化，可以通过shadowRef避免这个问题。仅当对state.value进行修改时才触发。 reactive、shallowReactive对第一层reactive创建响应式，reactive对递归的将所有的子属性设置为reactive对象1234567const _state = &#123; user: &#123; name: 'xxx' &#125;&#125;const state = reactive(_state)isReactive(state.user) // true readonly和shallowReadonly创建一个只读的响应式对象，接受一个对象、响应式对象或者ref。 CustomRef创建一个自定义行为的ref，官方内置两种ref，可以通过CustomRef来实现自定义行为的ref。1234567891011121314151617181920const debounceRef = (value, delay) =&gt; &#123; let timer = null; CustomRef((track, trigger) =&gt; &#123; return &#123; get() &#123; track() return value &#125; set(v) &#123; if(!timer) &#123; value = v; track(); timer = setTimeout(() =&gt; &#123; timer = null; &#125;, delay); &#125; &#125; &#125; &#125;)&#125; 强制触发ref的变化对一个shallowRef对象使用triggerRef(ref)可以触发ref所有相关的副作用。不能触发computed123456const count = shallowRef(0);watch(count, console.log);count.value++;triggerRef(count) // 1 --- 2 工具apitoRef、toRefs、unref将一个响应式对象(包括readonly)转换成每个子属性都是ref的，对象属性值的变更会导致ref也更新。 unref将一个值（如果是非ref）转化成ref并返回12345678910const state = reactive(&#123; count: 1&#125;)const count = state.countstate.count++ // count 不会变化，已经丢失响应式const &#123; count &#125; = toRefs(state) // 这样不会丢失响应式，对const count = toRef(state, 'count')isRef(count) // true isRef、isProxy、isReactive、isReadonlyisProxy检查 reactive、shallowReactive、readonly、shallowReadonly toRaw、markRawtoRaw 返回一个响应对象的原始对象的引用。markRaw将一个普通对象锁住，使其不能被转换成响应式对象。1234567const state = &#123;&#125;console.log(toRaw(reactive(state)) === state) // trueconsole.log(isReactive(reactive(markRaw(state)))) // false state.state = markRaw(&#123;&#125;)console.log(isReactive(reactive(state))) // false 子属性也是能锁住]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2Farchives%2F280100fb.html</url>
    <content type="text"><![CDATA[移动w 移动到下个单词开头e 移动到当前单词结尾b 移动到上个单词开头3b 移动3次0 移动到行首ctrl + o 移动到上一个光标ctrl + i 移动到下一个光标G 末尾gg 开头799G 跳转到799行 删除x 删除当前光标内容dw 删除当前光标及后面空格d$ 删除当前光标到行尾de 删除当前光标到单词结尾d% 删除到下一个尾括号3x 删除3个光标3de 执行3次de 撤销操作u 撤销操作crtl + R 前进操作 替换输入r 然后输入替换的单词c [number] motion 同删除类似 :s/aaa/bbb 当前行 替换 aaa成bbb一次:s/aaa/bbb/g 当前行全部替换:1,10s/aaa/bbb/g 1到10行 全部替换:%s/aaa/bbb/gc 全文询问式替换 删除暂存器p将暂存器的内容放置到光标后，如果是行，放置到当前光标下方 查找查找总是从光标向后，如果需要反向，使用?/xxx 查找xxx输入n 查找下一个，N查找上一个 编辑模式i 光标前a 光标后A 插入行末尾R 替换模式o 下一行插入O 上一行插入 配置:set xxx]]></content>
  </entry>
  <entry>
    <title><![CDATA[ts-type-practice]]></title>
    <url>%2Farchives%2Fe961b2fe.html</url>
    <content type="text"><![CDATA[前言新坑，TS类型编程学习 知识记录any 和 unknown区别any可以接受任何值，也可以赋值unknown可以接受任何值，但是不能赋值给any和unknown之外的类型 keyof 用于把索引类型变成联合类型1234567interface Person &#123; name: string age: number;&#125;type Test = keyof Person // "name" | "age"type Test1 = "name" extends keyof Person ? true : false // trueconst a: Test = "name" extends 详解满足下面条件，判断为true 两边类型都是常量时，常量需要相同 两边都是基础类型时，类型需要相同 索引类型，需要操作符左边包含操作符右边 联合类型，满足其中一个即可。 交叉类型需要全部满足123456789interface Pig &#123; type: 'pig', weight: number&#125;interface Animal &#123; type: string&#125;type Test = Pig extends Animal ? true : false // true 联合类型和交叉类型联合类型 针对基础类型时，表示的是几个类型任意一个。 联合类型只能调用共同方法 交叉类型 针对基础类型和常量类型 123string &amp; boolean // neverstring &amp; string // stringstring &amp; (string | boolean) // string 针对索引类型, 表示的索引合集，需要同时满足所有。 12345678interface A &#123; name: string&#125;interface B &#123; age: number&#125;type Test = A &amp; B; // A需要同时具有name 和 age属性 工具类IsEqual123456789101112131415161718192021222324// 简单版本type IsEqual1&lt;A, B&gt; = A extends B ? B extends A ? true : false : false type Test = IsEqual1&lt;string, string&gt; // truetype Test1 = IsEqual1&lt;string, '1'&gt; // falsetype Test2 = IsEqual1&lt;string, string | boolean&gt; // boolean !!! 失效// 升级版本type IsEqual12&lt;A, B&gt; = [A] extends [B] ? [B] extends [A] ? true : false : falsetype Test3 = IsEqual12&lt;string, string&gt; // truetype Test4 = IsEqual12&lt;string, '1'&gt; // falsetype Test5 = IsEqual12&lt;string, string | boolean&gt; // falsetype Test6 = IsEqual12&lt;&#123; name: string&#125;, &#123; readonly name: string,&#125;&gt; // true !!!!! 失败// 最终版本type IsEqual&lt;A, B&gt; = (&lt;T&gt;() =&gt; T extends A ? 1 : 2 ) extends (&lt;T&gt;() =&gt; T extends B ? 1 : 2) ? true : falsetype Test7 = IsEqual&lt;&#123; name: string&#125;, &#123; readonly name: string,&#125;&gt; // false 元组提取元组的第一个数组类型在线查看12type GetCupleFirstType&lt;T extends unknown[]&gt; = T extends [infer FirstType, ...unknown[]] ? FirstType : never;type Test = GetCupleFirstType&lt;[string, number, symbol]&gt; // Test = string 提取元组的最后一个类型在线查看12type GetLastCupleType&lt;T extends unknown[]&gt; = T extends [...unknown[], infer Last] ? Last : nevertype Test = GetLastCupleType&lt;[string, number, symbol]&gt; // Test = symbol 数组Pop在线查看12type Pop&lt;T extends unknown[]&gt; = T extends [...infer Rest, unknown] ? Rest : never;type Test = Pop&lt;[string, boolean, symbol]&gt; // [string, boolean] 数组Push12type Push&lt;T extends unknown[], S&gt; = [...T, S]type Test = Push&lt;[boolean], string&gt; // [boolean, string] 数组Shift12type Shift&lt;T extends unknown[]&gt; = T extends [any, ...infer Rest] ? Rest : nevertype Test = Shift&lt;[unknown, boolean, '1']&gt; // [boolean, '1'] 数组Unshift12type Unshift&lt;T extends unknown[], S&gt; = [S, ...T]type Test = Unshift&lt;[boolean], string&gt; // [string, boolean] 数组concat12type Concat&lt;T extends unknown[], S extends unknown[]&gt; = [...T, ...S]type Test = Concat&lt;[boolean, string], ['1', '2']&gt; // [boolean, string, '1', '2'] 数组zip12type Zip&lt;One extends [unknown, unknown], Other extends [unknown, unknown]&gt; = One extends [infer OneFirst, infer OneAnother] ? Other extends [infer OtherFirst, infer OtherAnother] ? [[OneFirst, OtherFirst], [OneAnother, OtherAnother]]: [] : []type Test = Zip&lt;['1', '2'], ['3', '4']&gt; // [['1', '3'], ['2', '4']] 任意长度数组合并 zip2123type Zip2&lt;One extends unknown[], Second extends unknown[]&gt; = One extends [infer OneFirst, ...infer OneRest] ? Second extends [infer SecondFirst, ...infer SecondRest] ? [[OneFirst, SecondFirst], ...Zip2&lt;OneRest, SecondRest&gt;] : [[OneFirst], ...Zip2&lt;OneRest, []&gt;] : Second extends [infer SecondFirst, ...infer SecondRest] ? [SecondFirst, ...Zip2&lt;SecondRest, []&gt;] : []type Test = Zip2&lt;["1", "2", "4"], ["5", "6", "7" ,"1"]&gt; 数组反转1234type ReverseHelper&lt;T extends unknown[], R extends unknown[] = []&gt; = T extends [infer First, ...infer Rest] ? ReverseHelper&lt;Rest, [First, ...R]&gt; : Rtype Reverse&lt;T extends unknown[]&gt; = ReverseHelper&lt;T&gt;type Test = Reverse&lt;['1']&gt; 数组flat12type ArrayFlat&lt;T, R extends unknown[] = []&gt; = T extends [infer First, ...infer Rest] ? ArrayFlat&lt;Rest, [...R, ...ArrayFlat&lt;First&gt;]&gt; : [...R, ...(T extends unknown[] ? T : [T])]type Test = ArrayFlat&lt;[1| 5 | 2]&gt; // 为啥是 1 | 5 | 2 字符串字符串 startWith12type StartWith&lt;T extends string, S extends string&gt; = T extends `$&#123;S&#125;$&#123;string&#125;` ? true : false // ts只有字符串，没char，所以用string匹配type Test = StartWith&lt;"123", "1"&gt; // true 字符串EndWith123type EndWith&lt;S extends string, T extends string&gt; = S extends `$&#123;string&#125;$&#123;T&#125;` ? true : false;type Test = EndWith&lt;"123", "3"&gt; // truetype Test1 = EndWith&lt;"123", "4"&gt; // false 字符串首位字符串12type GetFirstString&lt;T extends string&gt; = T extends `$&#123;infer First&#125;$&#123;string&#125;` ? First : never // infer 定义的变量只能在true里面使用type Test = GetFirstString&lt;"123"&gt; // "1" 替换字符串123type Replace&lt;S extends string, T extends string, R extends string&gt; = S extends `$&#123;infer Prev&#125;$&#123;T&#125;$&#123;infer After&#125;` ? `$&#123;Prev&#125;$&#123;R&#125;$&#123;After&#125;` : Stype Test = Replace&lt;"123", "2", "3"&gt; // "133"type Test1 = Replace&lt;"123", "3", "2"&gt; // "133" 创建指定长度的字符串12 字符串Trim123456type Space = '\n' | ' ' | '\t'type TrimLeft&lt;S extends string&gt; = S extends `$&#123;Space&#125;$&#123;infer Rest&#125;` ? TrimLeft&lt;Rest&gt; : Stype TrimRight&lt;S extends string&gt; = S extends `$&#123;infer Rest&#125;$&#123;Space&#125;` ? TrimRight&lt;Rest&gt; : Stype Trim&lt;S extends string&gt; = TrimLeft&lt;TrimRight&lt;S&gt;&gt;type Test = Trim&lt;" 123\n\t"&gt; 首字母转大写123type UpcaseFirst&lt;S extends string&gt; = S extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? `$&#123;Uppercase&lt;First&gt;&#125;$&#123;Rest&#125;` : S;type Test = UpcaseFirst&lt;'ceshi'&gt; // "Ceshi" 转小驼峰12type CamelCase&lt;S extends string&gt; = S extends `$&#123;infer Prev&#125;_$&#123;infer AfterFirst&#125;$&#123;infer Rest&#125;` ? `$&#123;Prev&#125;$&#123;Uppercase&lt;AfterFirst&gt;&#125;$&#123;CamelCase&lt;Rest&gt;&#125;` : Stype A = CamelCase&lt;'dong_test_liu'&gt; 删除指定字符串12type DropStr&lt;S extends string, T extends string&gt; = S extends `$&#123;infer Prefix&#125;$&#123;T&#125;$&#123;infer Suffix&#125;` ? DropStr&lt;`$&#123;Prefix&#125;$&#123;Suffix&#125;`, T&gt; : Stype Test = DropStr&lt;'123', '1'&gt; // '23' 函数获取函数参数类型123type GetParamsType&lt;F extends Function&gt; = F extends (...args: infer Args) =&gt; any ? Args : []type Test= GetParamsType&lt;(a?: string) =&gt; any&gt; // [a?: string] 获取函数返回参数类型12type GetReturnType&lt;F extends Function&gt; = F extends (...args: any[]) =&gt; infer Return ? Return : never // args中需要设置any，不能是unknowtype Test = GetReturnType&lt;(a: string, b: number) =&gt; string&gt; // string 添加函数参数123456type GetParamsType&lt;F extends Function&gt; = F extends (...args: infer Args) =&gt; any ? Args : [];type GetReturnType&lt;F extends Function&gt; = F extends (...args: any[]) =&gt; infer Return ? Return : never;type AddFunctionParams&lt;F extends (...args: any[]) =&gt; any, T&gt; = (...args: [...GetParamsType&lt;F&gt;, T]) =&gt; GetReturnType&lt;F&gt;;type AddFunctionParams1&lt;F extends (...args: any[]) =&gt; any, T&gt; = F extends (...args: infer Args) =&gt; infer ReturnType ? (...args: [...Args, T]) =&gt; ReturnType : Ftype Test = AddFunctionParams1&lt;(a: string) =&gt; string, string&gt; 设置函数中this的类型通过函数参数中第一个参数this定义类型1234567891011121314151617181920212223interface Person &#123; name: string say(name: string): any&#125;interface SayName &#123; (this: Person): any&#125;const a: SayName = function () &#123; console.log(this.say('name is yang'))&#125;const person: Person = &#123; name: 'yang', say(name: string) &#123; console.log(name) &#125;,&#125;a() // Errora.call(person)const b = a.bind(person)b() 获取函数中this指向的类型。12type GetThisType&lt;T extends Function&gt; = T extends (this: infer ThisType, ...args: any[]) =&gt; any ? ThisType : never // 注意，函数参数要用 any[] 接受type Test = GetThisType&lt;(this: string, name: boolean) =&gt; boolean&gt; // string 构造器和类实例123456789101112interface Person &#123; name: string&#125;interface PersonCtor &#123; new (name: string): Person&#125;const createPerson: Person = function(ctor: PersonCtor) &#123; ctor() // 禁止 非构造函数调用 return new ctor('name');&#125; 获取构造器的实例类型123456789101112// 获取构造函数的函数实列type GetInstanceType&lt;T extends new (...args: any[]) =&gt; any &gt; = T extends new (...args: any[]) =&gt; infer InstanceType ? InstanceType : unknown interface Person &#123; name: string&#125;interface PersonCtor &#123; new (): Person&#125;type Test = GetInstanceType&lt;PersonCtor&gt; // Person 获取函数构造器参数1234567891011// 获取构造函数的参数类型type GetInstanceType&lt;T extends new (...args: any[]) =&gt; any &gt; = T extends new (...args: infer ParamsType) =&gt; any ? ParamsType : unknown interface Person &#123; name: string&#125;interface PersonCtor &#123; new (name: boolean): Person&#125;type Test = GetInstanceType&lt;PersonCtor&gt; // [name: boolean] 获取索引类型中指定值的类型12345678interface Person &#123; name: boolean age: number&#125;type GetPropNameType&lt;T&gt; = 'name' extends keyof T ? T extends &#123; name: infer NameType &#125; ? NameType : never : nevertype Test = GetPropNameType&lt;Person&gt; // boolean 索引类型值修改12345678910type ChangeValue&lt;T&gt; = &#123; [K in keyof T]: [T[K]]&#125;interface Person &#123; name: string age: number&#125;type Test = ChangeValue&lt;Person&gt; 索引类型索引修改1234567891011type ChangeIndex&lt;T&gt; = &#123; [K in keyof T as Uppercase&lt;K &amp; string&gt;]: [T[K]] // 只过滤 string类型， 交叉类型在针对普通类型时需要严格相同， 同时never索引默认不会展示&#125;interface Person &#123; name: string age: number 1: number&#125;type Test = ChangeIndex&lt;Person&gt; // &#123;NAME: string, age: number&#125; 无 1: number Record12345type MyRecord&lt;S extends string | number | symbol, T&gt; = &#123; [K in S ]: T&#125; type A = MyRecord&lt;string | 1, number&gt; 取出值为指定类型的索引1234567891011type Mypick&lt;Obj, T&gt; = &#123; [K in keyof Obj as Obj[k] extends T ? K : never] : Obj[K]&#125;type A = &#123; sex: number&#125;type Test = Mypick&lt;&#123; name: string; age: number; sex: A&#125;, A | string&gt; // &#123; name: string; sex: A &#125; readonly12345678type MyReadOnly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K]&#125;type Test = MyReadOnly&lt;&#123; name: string; age?: number&#125;&gt; ToPartial 全部可选12345678type ToPartial&lt;T&gt; = &#123; [K in keyof T]?: T[K]&#125;type Test = ToPartial&lt;&#123; name: string age?: number&#125;&gt; 去掉readonly1234567type DropReadOnly&lt;T extends Object&gt; = &#123; -readonly [K in keyof T]: T[K] &#125;type Test = DropReadOnly&lt;&#123; readonly name: string; age: number&#125;&gt; 去掉可选1234567type DropOptional&lt;T extends Object&gt; = &#123; [K in keyof T]-?: T[K]&#125;type Test = DropOptional&lt;&#123; name?: string; age: number&#125;&gt; 获取指定索引类型的子集123456789101112131415type FilterByIndexType&lt;Obj extends Object, T extends number | string | symbol&gt; = &#123; [K in keyof Obj as K &amp; T]: Obj[K]&#125;type A = FilterByIndexType&lt;&#123; [x: symbol]: number name: string 1: string 2: number&#125;, symbol | 1&gt;type ReverseHelper&lt;T extends unknown[], R extends unknown[] = []&gt; = T extends [infer First, ...infer Rest] ? ReverseHelper&lt;Rest, [First, ...R]&gt; : Rtype Reverse&lt;T extends unknown[]&gt; = ReverseHelper&lt;T&gt;type Test = Reverse&lt;['1']&gt;type B = 1 &amp; (number | string) 获取指定指针类型的子集1234567type FilterValueType&lt;Obj extends Object, T extends number | string | symbol&gt; = &#123; [K in keyof Obj as Obj[K] extends T ? K :never]: Obj[K]&#125;type Test = FilterValueType&lt;&#123; name: string; age: 18&#125;, number&gt; 循环递归获取promise返回值类型1234type DeepPromiseTypeHelper&lt;P&gt; = P extends Promise&lt;infer ValueType&gt; ? DeepPromiseTypeHelper&lt;ValueType&gt; : Ptype DeepPromiseType&lt;P extends Promise&lt;unknown&gt;&gt; = DeepPromiseTypeHelper&lt;P&gt;type Test = DeepPromiseType&lt;Promise&lt;number&gt;&gt; 反转是否包含1234type IsEqual&lt;A, B&gt; = (&lt;T&gt;() =&gt; T extends A ? 1 : 2 ) extends (&lt;T&gt;() =&gt; T extends B ? 1 : 2) ? true : falsetype Include&lt;S extends unknown[], T&gt; = S extends [infer First, ...infer Rest] ? IsEqual&lt;First, T&gt; extends true ? true : Include&lt;Rest, T&gt; : falsetype A = Include&lt;['1' | '2', '2'], '2' | '1'&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue查漏补缺（二）双向绑定原理]]></title>
    <url>%2Farchives%2F61b757b4.html</url>
    <content type="text"><![CDATA[初始化对象123class Vue &#123; cont&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue查漏补缺（一）生命周期]]></title>
    <url>%2Farchives%2F69b5cd9a.html</url>
    <content type="text"><![CDATA[生命周期解释生命周期函数是一个hook，类似于好莱坞的设计模式，hook是同步调用，在Vue执行的各个时间点被调用，能获取到对应时间点VM的状态 开始 赋值_self, vm=this 合并extend和mixin选型 初始化proxy拦截器 初始化render生成函数 初始化组件上的事件监听器 beforeCreate injection prop method data computed watch providercreated 编辑模板生成render函数 vm.$el 赋值（但是还未替换dom）beforeMount 执行render函数，生成vnode 挂载vnode到dom中mounted]]></content>
  </entry>
  <entry>
    <title><![CDATA[json-schema-json]]></title>
    <url>%2Farchives%2Fe6d11dd8.html</url>
    <content type="text"><![CDATA[流程 form表单渲染schemaField schemaField中根据type渲染不同Field。 ObjectFiled，需要渲染容器 如果是其他类型，渲染由widget包裹的组件 widget是一个el-form-item]]></content>
  </entry>
  <entry>
    <title><![CDATA[http查漏补缺]]></title>
    <url>%2Farchives%2F756fdee8.html</url>
    <content type="text"><![CDATA[https 加密流程 服务端使用第三方机构（ca）的私钥加密，获得一个公钥证书发给浏览器 浏览器调用三芳芳机构公钥解密，获得服务端的公钥。浏览器使用服务端公钥生成一个对称密钥，发给服务端 服务端使用自己的私钥解密，获取到对称的密钥 DNSDNS使用UDP， 递归查询是指域名服务帮忙查询下一级，迭代查询是指客户端自己查询下一级 常见服务端口20 ftp数据口21 ftp控制口22 ssh23 telnet80 http443 https3306 mysql6379 redis localStorage 和 sessionStorage。localStorage在存储系统中按照同源策略保存，sessionStorage按照同源同时加上tabId保存，当页面tab被关闭时清空，而不是等到浏览器关闭时清空，而且不同tab页面不共享。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器解析]]></title>
    <url>%2Farchives%2F50c7c64b.html</url>
    <content type="text"><![CDATA[浏览器渲染进程包含的线程 GUI 渲染线程，负责解析HTML，CSS，构建DOM、CSSOM和render tree, 布局和绘制。当页面回流时。 js引擎线程，一个渲染进程只有一个js引擎线程，负责解析执行js代码 事件线程，当事件触发时，会添加到队尾，等待js引擎执行 定时器线程，触发后放在队尾 htto请求线程，请求后放在队尾 简略版xuanran 解析html，构建dom树 解析css,构建css树 cssom和dom合并成渲染树 根据渲染树计算节点位置，布局 调用GUI绘图，上色，合成图层，并渲染到界面上 html、css和js解析构建顺序 html解析从上到下解析文档，依次构建DOM 如果碰到link或者style，异步的进行cssom构建 如果碰到js脚本，会先等到前面的cssom构建完成，才会解析js脚本（可以先下载）。js脚本解析执行期间，html会停止解析 初始的html解析完成后，会触发documentContentLoad 事件。此时图片资源可能还未下载完成 load 事件表示初始html以及资源全部load 图层一个普通的文档流被视为一个图层，包括浮动和非（fixed）定位。对于频繁的渲染需要生成一个新的图层来操作。 3D转换 fixed 动画 重绘和回流重绘不涉及布局和几何变化，比如改下颜色。回流是指布局和几何外观的改变，需要渲染整个图层。所有重绘和回流都只争对当前元素 避免回流 translate 替换 top 选择器从右到左，避免dom查找过深]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器网络]]></title>
    <url>%2Farchives%2F31643d6c.html</url>
    <content type="text"><![CDATA[浏览器进程 主进程 网络进程 GUI进程 多个插件进程 多个渲染进程（一个页面一个，多个同源界面共用一个，所以页面崩溃时可能影响其他多个页面，一个tab页因为iframe可能存在多个渲染进程） 渲染进程是放在sanbox中的，不讲整个浏览器放在sanbox原因是其他进程需要用到沙箱外的服务。渲染进程需要保证安全。 输入url到页面展示页面流程 构建请求行 GET /index.html http1.1 （没有host和协议） 浏览器根据请求url判断是否走缓存，如果是get请求，根据查询强缓存（硬盘缓存和内存缓存）查询是否有，有直接返回。没有缓存走下一步。 准备ip或者端口，如果是url是域名形式的，需要根据DNS查询ip，DNS查询也有多级缓存，查询的流程有递归和迭代查询，前者是从根域名服务器查询，根域名服务器往下查询。后者由下往上查询。如果url中没有端口，端口根据协议自动推导 准备请求投，根据发起请求添加header，部分请求头浏览器默认准备，cookie会自动根据当前domain和path，添加父域名和父path的cookie。host（domain + port）, referer根据请求发起的位置添加（http://xxxx.com/123），不包含hash。还有origin，格式同referer 建立TCP连接，三次握手，发送请求，谷歌tcp连接最多6条，所以在控制台中有等待的请求 服务处理请求，发送响应，响应包括响应头，响应行，响应体。响应行包括协议、状态码(HTTP/1.1 304)，常见的状态码如下1xx: 请求未传输完成，继续传输200: 请求接受成功，正常处理301: 资源永久重定向, 根据响应头中的location请求新地址302: 资源临时重定向，location处理304：资源未被修改，使用本地缓存文件。同时根据响应头更新本地资源。400: 服务器无法理解当前请求401：未鉴权403: 已登录无权限404: 资源未找到405: 请求的方法错误5xx: 服务器出错了。 浏览器解析文档，从上到下依次解析html，计息dom和cssom，组成渲染树，然后渲染到页面。 浏览器缓存概述 查询是否存在强缓存（cache-control, expire）。如果不存在直接请求 检查强缓存是否有效（先检查cache-control）,如果没有过期，使用缓存 如果过期，使用协商缓存，先检查是否有etag,如果有etag，发送请求（携带if-none-match:etag），服务端接收到请求后，如果当前缓存有效，返回304和新的etag，浏览器使用本地缓存同时更新etag或者新的cache-control。如果当前服务检查缓存无效，则会返回新的资源和etag等 如果不存在etag，存在last-modified。则发送if-modified-since, 服务端检查后同etag处理流程一致。 如果都不存在，则发送新请求。 浏览器解析文档 浏览器根据content-type判断是交给文档解析器还是下载管理器，一般content-type 是字节流会交给下载管理器作为下载文件 如果是文档，会交给渲染进程，渲染进程接受到后发挥出确认提交给浏览器主进程，主进程会更新浏览器导航栏，地址栏等信息。这个时候页面时空白，然后开始解析文档，渲染界面 defer 和 asyncdefer是延迟，表示资源下载完后，在文档解析完成后依次执行async 是异步，表示资源下载不阻塞，资源下载后立马执行，阻塞渲染进程解析。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookie]]></title>
    <url>%2Farchives%2F8ae0ba66.html</url>
    <content type="text"><![CDATA[前言最近在公司碰到了内嵌的iframe始终提示未登录的问题，查询到时接口请求时未自动携带cookie，排查过程中一直没搞懂cookie携带的机制。将排查后学习到总计一下。 问题先来几个问题 cookie是怎么设置到浏览器中，设置cookie有什么限制 什么样的请求能携带cookie，能携带哪些cookie cookie存储方式是什么 cookie 和 storeage 区别 跨域和跨站 跨域和跨站同域: 协议、域名、端口相同，反之是跨域同站: eTLD + 1, 顶级域名 + 1 相同则是同站，反之是跨站 请求的场景假设当前网站是xunserver.cn, 页面地址是http://cloud.xunserver.cn/file。这个页面发出的请求有以下几种 同域请求，http://cloud.xunserver.cn/patha 跨域请求不跨站 https://cloud.xunserver.cn/patha 和 http://cloud.xunserver.cn:8088/patha 子域名请求 http://nps.cloud.xunserver.cn/patha 跨域同时跨站 http://docker.xunserver.com/patha 上级域名请求 http://xunserver.cn cookiecookie组成cookie 包括name, value, domain, path, expire, httpOnly, secure, samesite。 cookie 如何被设置有两种设置cookie的方法 请求响应头中set-cookie 前端JS代码document.cookie。 通过响应设置cookie时， domian默认是当前请求的eTLD + 1， 路径默认是/。可以设置上级域名和上级路径的cookie，如果设置子域名或者子路径，cookie设置会无效，而且会被抛弃。 document.cookie 设置和set cookie类似，前者被限制于当前文档的地址（浏览器地址栏）,而且不能设置httpOnly和secure 属性。 cookie 如何被携带当浏览器发送请求时，根据请求的场景携带cookie不同。 同域请求， 自动携带当前请求所有的子域名和父路径, 会携带path=/patha、path=/ 和 domain=cloud.xunserver.cn、xunserver.cn的cookie cookie不区分端口和协议，所以同上一致 会携带domain=nps.cloud.xunserver.cn 以及上级域名 携带domian=docker.xunserver.cn 携带domain=xunsrever.cn 不会携带cloud.xunserver.cn 域名 samesite 是啥用户在银行登录了系统，这个时候浏览器嵌入了cookie，如果恶意网站中有一个form表单，提交地址是银行的链接，用户在点击链接后就会触发接口，因为请求携带了cookie，所以银行会判断为正常用户，从而带来不安全。或者恶意网站嵌套i银行frame，诱导用户点击，实际点击到了银行网站的接口。samesite有三个值,strict, lax 和nonestrict 表示只有请求在同站的情况下，才会携带cookie。lax 表示除了a标签、预加载、get表单能cookie外，其余场景都不能携带，包括iframenone 表示不限制 samesite 如何设置，浏览器默认是lax, 匿名浏览器如果关闭第三方共享是strict。如果设置none，需要同时secure，同时在https下设置 跨域如何携带cookie哪些些请求能跨域link、img、script 标签支持跨域，但是new Image不支持。跨域能发送请求，但是不能解析响应。其余的通过axios或者fetch发送跨域请求，axios 需要添加withCredentials: true支持跨域携带cookiefetch 需要添加withCredentials: include属性 fetch withCredentials解析omit 跨域不打送cookieinclude 总是发送same-origin 同站才发送 storagelocalstorage 和 sessionStorage 严格按照同源原则。 document.domain 用来干嘛可以把父页面和iframe的domain设置成一个（都需要设置，因为document.domain调用后端口会被设置为null），父页面可以拿到iframe的window对象，从而调用iframe中的方法实现跨域。设置document.domain 仅设置自身或者上级域名，不能设置为其他或者子域名。 也可以通过window.open 获取引用 如何检查浏览器同时打开多个相同页面循环检查localStorage host、referer和originhost: 指向请求的host和端口号，任何请求都有referer: 当前请求发起的来源，一个页面跳转到另一个页面指向的是之前的页面，页面内发起的资源请求，指向当前文档的地址，不包含hashorigin: 跨域请求中常见 ，指向原始]]></content>
  </entry>
  <entry>
    <title><![CDATA[network]]></title>
    <url>%2Farchives%2F608487bc.html</url>
    <content type="text"><![CDATA[console 线一头网线，一头usb线的线，通过串口控制设备 一般是9600 8 0 配置 盒式设备、框式设备盒式设备高度按照u来分区，一般一排网口的是半U，两排是1U。框式设备是一整块机柜，包含电源主从，控制主从等。 MGT端口通过两头网线控制，笔记和管理端口同网段即可 mini-console一头usb，另一个mini-console接口，用于控制设备 telnet和ssh通过应用层协议连接 rs2329针口，现在的都集成变成usb telnet、ssh 端口telnet 23 ssh 22 ISO，OSIISO 国际标准化组织OSI 开放系统互联互通模型 OSI 7层模型介绍物理层物理层层面的0，1转换传输。以太帧 链路层物理上点到点的传输， Mac 网络层节点和节点的传输。IP 传输层端口到端口的传输 命令行权限和用户权限命令权限有0-3级， 分别是观察级、监控级、配置级和管理级用户权限有0-15级 前面和命令行对应。每一级可以使用前面所有等级命令 视图用户视图 \&lt;host> 默认登录上的视图 系统视图 [host] 用户视图输入system-view 后进入 命令视图 系统视图下输入命令的视图 配置ip地址123system-view # 系统视图interface Ethernet 0/0/8 # 接口视图ip address 192.168.1.2 24 # 设置ip 开启telnet 登录1. 新建用户1234system-view aaa # 进入aa模式local-user test password cipher test # 设置用户名密码local-user test service-type telnet # 指定用户登录模式 2. 分配vty12345# 需要指定用户登录的vtysystem-view user-interface vty 0 3 # vty配置模式user privil level 3 # vty 用户最大权限authentication-mode aaa # 设置认证方式为aaa 网卡CU: 控制单元OB: 输出缓存LC: 线路编码器TX: 发射器 RX: 接收器LD: 线路解码器IB: 输入缓冲CU从网络层获取到packet，在CU封装成frame帧，帧传递到OB，OB会按照帧的接受顺序排列成队列，依次传递到LC。LC把一个一个的帧编码成 0 1物理电平传递给TX, TX将物理的电平增加功率，发送出去双绞线。 同理，RX,LD,OB也相同。 交换机的网卡和主机网卡在CU处理方面不同，交换机接收到帧做泛洪，舍弃，点对点转发。主机网卡接收到帧后，会解开帧后转交给上层的网络层处理。 mac地址MAC 地址有48位，区分为单播MAC（首字节末尾是0），组播MAC（首字节末尾是1），广播MAC（全是1，所以是一种特殊组播），网卡的MAC又称BIA地址，前24位是厂商向IEEE申请，后24位厂商自行分配。前24位是OUI地址。 以太帧目前使用的以太帧有IEEE 802.3 和 Ethernet II 两种格式。Ethernet II格式简单使用广泛，IEEE 802.3用于某些特殊协议。 Ethernet II由以下组成，目的MAC，源MAC，2字节表示类型，载荷，和CRC校验和结尾。 2的次方速记一个字节8位，两个16进制计数。2 ^ 8 = 65536;2 ^ 16 = 16777216 帧的流转帧在交换机端口中进入时，会查找MAC表中是否存在映射，不存在时执行泛洪，并保存将帧的源MAC和端口保存更新到MAC表中。MAC和端口是多对一的关系。主机MAC在接收到单播帧时，会检查BIA地址和目的MAC是否一致，如果不一致则会丢弃帧。接收到广播帧时，CU会传递到上层模块]]></content>
  </entry>
  <entry>
    <title><![CDATA[hcna]]></title>
    <url>%2Farchives%2F548c626e.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[dhcp]]></title>
    <url>%2Farchives%2Fcd116c88.html</url>
    <content type="text"><![CDATA[简介DHCP（dynamic host configuration protocol）动态主机配置协议。是一个应用层协议，用于给dhcp客户端配置ip，网关，dns等。 流程首次DHCP 客户端广播DISCOVER，要求当前广播域中的服务器提供可用的IP。 服务端广播OFFER，提供可选的IP。 客户端选择一个可用的IP，广播REQUEST，提示服务端已经选择某个OFFER。 服务端收到REQUEST后，记录已经分配的IP，并广播ACK。 客户端收到ACK后，设置IP。 释放IP 客户端单播发送RELEASE，目标地址时DHCP服务端 服务收到，释放IP 续租 租期50%时（T1），客户端会单播发送REQUEST，服务端单播ACK，续租成功。如果服务端单播回复NAK，会重新走DISCOVER流程请求新的IP 如果T1时发送的包REQUEST未得到回应，会在87.5%时，发送第二次RESQUEST，流程同第一次 如果租期到了，REQUEST还未得到回应，走DISCOVER流程 配置 配置默认网关 配置主备DNS服务器 配置开始的IP池，结束IP池 从DHCP服务器同一个广播域中可以存在多个DHCP服务器，所以DHCP流程有4步，不是2步。OFFER就相当于保价并保留短暂时间，如果客户端发起的REQUEST相当于通知其他DHCP没选择他们的OFFER]]></content>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2Farchives%2Ff85ddf3d.html</url>
    <content type="text"><![CDATA[防抖debounce事件发生后，规定时间内只执行一次回调, 如果重复触发，会重置计时器和事件。 有立即执行和延迟执行两种方式，应用场景不同。 立即执行，触发事件 -&gt; 执行回调 -&gt; 延迟。常用在输入框远程搜索。 延迟执行，触发事件 -&gt; 延时 -&gt; 执行回调。用在防止按钮重复点击 实现方式如下 节流规定时间段内，只会发生一次事件，重复事件会被舍弃掉。]]></content>
  </entry>
  <entry>
    <title><![CDATA[access-control]]></title>
    <url>%2Farchives%2Fcb8b60b3.html</url>
    <content type="text"><![CDATA[简单请求必须满足下列所有条件 请求方法是 GET POST HEAD(只请求资源首部) 首部只能包含下面字段 accept accept-language content-language content-type content-type 的值只能是 application/x-www-form-urlencode multipart/form-data text/plain 复杂请求不满足简单请求的都是复杂请求, 常见的复杂请求包括 content-type: applcation/json cors cross-origin resource sharing 跨域资源共享简单请求针对简单请求，浏览器发现是跨域，会在请求中添加origin字段，如果服务端允许跨域，会返回access-control-allow-origin 字段，浏览器检测返回字段是否和当前域匹配，决定是否舍弃当前请求。 响应会返回下面3个首部字段 access-control-allow-origin, 指定允许的域。只能是origin 字段或者* access-control-allow-credentials，决定下次请求是否可以携带cookies access-control-allow-headers, 允许浏览器额外获取的首部字段 复杂请求针对复杂请求浏览器会先发送预检请求(options)，检查当前请求能否跨域，允许的字段等。浏览器发送预检查请求，包括Origin,access-control-request-method（表示当前请求的方法）,access-control-allow-Headers(表示当前请求额外的首部字段) 服务端根据预检请求，会返回origin，access-control-allow-methods（表示允许的方法），用逗号分隔access-control-allow-headers(表示允许的首部字段)（逗号分隔），浏览器会检查，如果和当前匹配，则会发送正式请求。 为了避免浏览器每次需要预检请求，还会同时返回access-control-max-age(秒), 表示有效期内不用发送预检请求。如果一个请求背、被预检通过，会走简单请求的流程，如果这个时候被简单请求拦截， 也不会成功 nginx 配置cors123456location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'POST,DELETE,OPTIONS'; add_header Access-Control-Max-Age: 7200 add_header Aceess-Contorl-Allow-Headers 'Cache-Control,Keep-Alive,If-Modified-Since,Content-Type,Authorization'&#125; 或者单独对options 请求配置1234567location / &#123; if($request_method = 'OPTIONS) &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET,POST,PUT,DELETE,OPTIONS'; add_header Access-Control-Allow-Header 'Cache-control,If-Modified-Since,If-None-Matched,Authorization,Content-Type' &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx之location]]></title>
    <url>%2Farchives%2Fe22c93eb.html</url>
    <content type="text"><![CDATA[安装windows 安装windows 直接下载官方二进制包，添加到环境变量 其他版本安装官网download下面有个平台的快捷安装方法 docker 安装需要注意的是配置转发的时候不是127.0.0.1（因为指向的是nginx容器本身） 命令大全指定配置文件运行 nginx -f xxx.conf 检查配置 nginx -t 检查配置文件nginx -T 检查并输出配置文件 重启、停止 nginx -s restartnginx -s stop systemctl 管理 systemctl start nginxsystemctl stop nginxsystemctl restart nginx 配置文件server_nameserver_name 支持精准匹配、通配符，正则匹配（^）开头。 location 语法location [= | ^~ | ~* | ~ ] xxx = 精准匹配优先级最高。 ^~ 前缀匹配, 按照最长的前缀匹配，如果命中，则会阻止正则，但不会组织普通路径 ~ 区分大小写的正则匹配，正则匹配只要命中就生效。 ~* 不区分大小写的正则匹配 不加符号，表示前缀匹配, 采用最长匹配 / 兜底匹配按照 上述顺序匹配 案例分析123456location /test_1 &#123; return 400;&#125;location ^~ /test &#123; return 401;&#125; 如上如果path为/test_1，返回的是400，说明^~优先级并不比普通匹配高 例子2123456789location /test_1 &#123; return 400;&#125;location ^~ /test &#123; return 401;&#125;location ~ /test &#123; return 402;&#125; 会返回 402, 因为会先命中 400 ，然后不会阻止正则 静态服务器root、alias12345678location /img/ &#123; root some/path; # /img/image/1 =&gt; some/path/img/image/1 会将整个路径添加到 root 路径中 index index.html index.htm; =&gt; # /user/image/1 =&gt; some/path/user/image/1 或者1.html&#125;localtion /img/ &#123; alias some/path; # /img/image/1 =&gt; some/path/image/1 会舍弃命中部分，所以要求location 和alias上级目录一致，所以location一定是一个目录，一定需要在末尾添加 / &#125; proxy_pass 解析目标地址后不带/，表示将请求的path拼接在target之后，如果带，表示将请求命中之外的拼接在target后]]></content>
  </entry>
  <entry>
    <title><![CDATA[call,apply,bind实现]]></title>
    <url>%2Farchives%2F8b2df16f.html</url>
    <content type="text"><![CDATA[思路 模拟this调用 解析剩余参数 参数如何传到函数中 context为null时处理 处理函数非法的情况 删除额外新增的变量，最好采用symbol12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const getFunctionArgs = (funcArgs, startIndex = 0) =&gt; &#123; const result = [] for(let i = startIndex, len = funcArgs.length; i &lt; len; i++) &#123; result.push(funcArgs[i]) &#125; return result;&#125;const checkFunction = (fn) =&gt; &#123; return typeof fn === 'function'&#125;Function.prototype.myCall = function(context) &#123; if(!(checkFunction(this))) &#123; throw new Error('not function'); &#125; const restArgs = getFunctionArgs(arguments, 1); context = context || globalThis; context.__fn = this; const result = eval(`context.__fn($&#123;restArgs&#125;)`) delete context.__fn return result&#125;Function.prototype.myApply = function(context, args = []) &#123; if(!checkFunction(this)) throw new Error('not function'); context = context || globalThis; context.__fn = this; const result = eval(`context.__fn($&#123;args&#125;)`) delete context.__fn return result&#125;Function.prototype.myBind = function (context, ...initArgs) &#123; if(!checkFunction(this)) throw new Error('not function'); const fn = this; const temp = function () &#123;&#125; temp.prototype = this.prototype; const fbind = function (...args) &#123; return fn.myCall(this instanceof fn ? this : context, ...initArgs, ...args) &#125; fbind.prototype = new temp() return fbind&#125;function newFn(constructor, ...args) &#123; const obj = Object.create(null); obj.__proto__ = constructor.prototype; constructor.myApply(obj, args) return obj&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[whistle跨平台代理调试工具]]></title>
    <url>%2Farchives%2F5258564a.html</url>
    <content type="text"><![CDATA[简介whistle用于代理http,https,websocket请求，监听修改报文，实现调式功能。语法简单，对前端友好。 安装和命令行通过npm全局安装1234567891011npm i -g whistle# 前台启动w2 run # 后台启动w2 start# 后台停止w2 stop# 重启w2 restart# 查看帮助信息w2 help 其余请求参数 配置范式whistle所有的操作都是通过下面范式配置， 匹配模式 操作协议+操作值 pattern operatorURI | | 请求url表达式 对应的操作：操作协议和操作值 匹配模式匹配模式分为域名、路径、正则、精准匹配和，通配符匹配 域名匹配通过域名、协议和端口号进行匹配，会匹配命中的所有请求12345678# 不区分协议www.baidu.com# 区分协议， 注意尾部添加/ 不是域名匹配https://www.baidu.com# 带端口的形式www.baiu.com:9000 路径匹配匹配uri路径及其子路径，uri是由域名和路径组成1www.baidu.com/xxx # 匹配 www.baidu.com/xxx 以及 www.baidu.com/xxx/xxx1/xxxx.index.html, 但是不匹配 www.baidu.com/xxx1 如果想实现任何域名的路径匹配，使用通配符模式 **/xxx 正则匹配支持子匹配，i模式，不支持g模式。子匹配可用在operatorURI中,同时支持非匹配 !/xxx/ 精准匹配在路径匹配前添加$，同时支持非匹配， 表示不精准匹配某条。!\$uri 通配符匹配使用^开始，可选的$作为结尾 *.com 匹配 xx.com 但是不能匹配 a.xx.com **.com 可以匹配 a.xx.com */xx 可以匹配]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用软件合集]]></title>
    <url>%2Farchives%2Ff11219d6.html</url>
    <content type="text"><![CDATA[编辑器 vscode subline notepad++，国内下载 数据库GUI mysql dbeaver，国内下载 redis AnotherRedisDesktopManager 服务器 git相关 git vscode 插件 code runner css peek eslint stylelint vetur rest client prettier git lens live Server markdown all in one git lens git history npm 包 代理工具 npm i -g whistle 静态服务器 npm i -g static-server 其他软件 act 本地运行github action工具 ftp和dhcp简单工具 tftpd64 端口扫描(网络管理工具)[https://borntoberoot.net/NETworkManager/Download] 在线管理cron工具()[https://github.com/ouqiang/gocron] 写文档historie]]></content>
  </entry>
  <entry>
    <title><![CDATA[glob模式学习]]></title>
    <url>%2Farchives%2F5500de7d.html</url>
    <content type="text"><![CDATA[概念 区段 地址分隔符中分隔的区间 比如 /a/b/c 就分为了3个区间 语法 * 匹配单个区段中0个或者多个字符 ** 匹配跨区段 0个或者多个字符, 如果是 **/ 只会匹配目录，或者忽略目录 ? 匹配一个字符 []配置括号中某个字符,当开头添加 ^、!时表示不匹配 ! ? * 和小括号一起使用时，和正则类似 例子匹配任意module下全部js，除了index.js **/module/!(index).js 只能配置 /module 或者 xx/module，不能匹配 /xx/module */module]]></content>
  </entry>
  <entry>
    <title><![CDATA[git再学习]]></title>
    <url>%2Farchives%2F141454d6.html</url>
    <content type="text"><![CDATA[经验技巧原则记录 未推送的内容使用reset回退，已推送的内容使用revert回退 谨慎使用rebase，建议仅作为本地内容commit的合并 使用对commit –amend 对上一次commit信息进行修改，可以把当前暂存区的合并到修改中 下面文件是常用的git 配置12345[user] name = yangjiaxun email = yangjiaxun@longfor.com[alias] lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative gitlab 分支管理流程commit理解git 是由commit组成，commit 记录git每次操作，包括 commitid（sha-1） Author, commiter, Parent(父commit)， child(多个下游commit), Branches 当前被哪些分支引用 每次commit操作会在当前commit上，添加一个下游commit，同时挪动相关引用。 branch 理解commit用commit标记，同时可以取一个别名，这个别名就是branch，branch指向某个commit。1234# 创建分支git branch develop # 删除分支git branch -d develop 如果当前工作区是branch，commit时会挪动branch和HEAD到最新commit，如果当前是在commit上，只会挪动HEAD到最新commit HEAD当前引用，始终指向当前工作区所在commit，可以用checkout来挪动。1234# 将当前HEAD 挪动到develop 所指的commit上，并切换工作区git checkout develop# 切换到349d1ddf的commit上，HEAD -&gt; 349d1ddf, 并切换工作区git checkout 349d1ddf merge分为两种情况，快速合并和新建合并 快速合并是指要合并过来的分支commit树包含当前分支commit信息，这个时候直接挪动当前分支到要合并的分支 如果不包含，会自动在当前分支新建一个commit。这个commit包含两个分支的diff 信息，然后挪动当前分支到自动创建的commit。 reset将分支和HEAD挪动位置123456# 挪动当前分支到HEAD所在commitgit reset HEAD# 挪动当前分支到HEAD父commitgit reset HEAD^# 挪动当前分支到3次父commitgit reset HEAD~3 –soft 将差异内容保存到暂存区 –hard 清空当前工作区和暂存区内容 不加参数，将差异保存在工作区 也可以对文件进行操作，删除暂存区内容 checkout针对文件时，是操作工作区内容和版本区一致 工作区、暂存区和版本区 工作区 -&gt;当前文件系统所拥有的状态 暂存区 -&gt;add后添加到到内容 版本区 -&gt;commit后的区域 指针都指向版本区 pull和push]]></content>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器开发者工具技巧]]></title>
    <url>%2Farchives%2Fea959a90.html</url>
    <content type="text"><![CDATA[保存为全局变量对打印的信息右键保存为全局变量 复制dom element strng点击直接ctrl+c element面板调整数字大小上下箭头 + ctrl alt 或者shift一个一个试一下 命令行 ctrl + p 打开资源查找器，输入 &gt; 进入命令行。 直接ctrl + p + shift $ 和 ? $ 是 document.querySelector()别名 ? 是 document.querySelectorAll() 别名 $_ 表示上一次的执行结果,像是对上一次语句左边拼接 = console一定是同步的吗？console打印需要时间，再打印出结果前，是以引用的方式保存的。所有有可能打印的结果不准确。所以应该尽量打印基本类型，或者使用断点。 console控件台总是被async 包围一些异步的方法可以直接使用await，比如fetch语句 条件断点在断点语句添加判断语句， 不需要if，如果条件满足就会断点。条件语句总是会执行 条件断点和console黑科技利用上面的特性，因为console总是返回undefined，所以可以添加一个条件语句console.log() 条件和consoleconsole.assert()，第一个参数写语句，后面写打印 log 多参数打印技巧console.log(x1, x2, x3) 修改改成 console.log({ x1, x2, x3 }) 就可以看到每个位置是什么参数，当然可能会出现值不准确的问题。 打印数组和对象console.table 过滤请求 filter 过滤框中添加 method:GET 就会仅显示GET请求，-method:GET 就会过滤GET请求只显示其他，也可以勾选invert选项 安装crtl 点击资源类型可以多选 勾选禁用缓存和硬性刷新浏览器的区别禁用缓存会每个资源都不使用缓存，硬性刷新只会在dom初始化阶段的请求添加禁止缓存 添加network展示的列在表头右键，一般添加上method方法 代码片段命令行输入 create new snippet 新建代码片段，通过!加代码片段名称调用 利用source -&gt; filesystem 实现在浏览器中修改代码，并同步css本地起一个服务，把代码目录拖到filesystem, 对变绿色的代码就可以直接修改，保存后隐射到本地 page filesystem overrides contentScript的使用 page 用于查看当前网页下面文件 filesystem 连接本地和浏览器，在浏览器中的修改会同步到本地代码。文件标志是绿色 overrides 不能和filesystem共用，修改文件时优先保存overrides。通过完全一致的url对应，包括查询参数。文件标志是紫色。浏览器加载时会本地替换这个资源]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端缓存]]></title>
    <url>%2Farchives%2F97f0c4bf.html</url>
    <content type="text"><![CDATA[请求报文和相应报文报文中报头部分使用冒号分隔的键值对组成，称为首部字段。部分首部字段在响应和请求中均有，称为通用首部字段。 强缓存expires(响应首部字段)资源有效时间，表示在此事件前资源使用缓存。Expires: Wed, 11 May 2022 03:50:47 GMT cache-control（通用首部字段）缓存控制，由以下字段组成 max-age 缓存最大时间，是一个相对时间，同时可用于请求，表示希望获得一个max-age 不大于指定值的资源，单位是秒。max-age 会覆盖expires，一般expires和max-age需要同时存在，兼容性设置。 s-maxage 表示代理服务器最大缓存时间，公共服务器接受到这个参数后，会直接使用这个，忽略其他expires 和 max-age public/private 表示资源是否能够被缓存服务器缓存， 不过一般缓存服务器不会处理这个字段，照样缓存。 no-cache/no store，no-cache在请求中时，表示不使用缓存服务器资源，使用源资源，同时也可以向源资源表示，使用最新资源。在响应中需要使用no-store 才表示真正的不缓存 no-cache 不进行强缓存（重要） no-store 不强缓存，也不协商缓存。 协商缓存Last-Modified 和 If-Modified-SinceLast-Modified 资源最后修改时间，浏览器接收当前资源后，下次在请求头中添加If-Modified-Since 字段。服务器验证是否有效，有效返回304。无效返回200、最新资源和最新的Last-Modified Last-Modified值实列如下，时间精度到秒Last-Modified: Fri , 14 May 2021 17:23:13 GMT。如果资源是毫秒级别的更新，可能会出现资源不是最新的情况。所以新出现了Etag和If-None-Match Etag 和 If-None-matchEtag在响应头中返回，用于标志资源的唯一性，资源每次变化时，Etag会重新生成。浏览器下次发送请求通过If-None-match发送。服务器对比处理逻辑同Last-Modified 缓存位置 memory cache 内存缓存 disk cache 缓存时间如何计算缓存新鲜度 = max-age || (expires - date) date 表示响应头中的Date字段缓存使用期 = 响应使用期 + 传输延迟时间 + 停留缓存时间 响应使用期 = max(0, response_time - date_value)，然后再和响应头age（秒）max 传输延迟时间 = 响应时间 - 请求时间 停留缓存时间 = now - 响应时间 now表示电脑当前时间。修改电脑时间使缓存失效的关键点。 当缓存使用期大于缓存新鲜度时，强缓存会失效，会启用缓存协商，如果无协商缓存，会重新请求。 启发式缓存上述可见强缓存新鲜度 = max-age || (expires - date)。如果max-age、expires、date不存在。缓存新鲜度计算规则 max(0, date - Last-Modified ) * 10% 开发模式下的刷新操作 硬性重新加载：不使用本地缓存，同时请求时在请求中添加cache-control: no-cache, 告知服务器和代理服务器不使用缓存。 使用硬性加载没有用的原因是，这两个请求头仅在页面渲染时添加，通过动态脚本添加的资源不会添加这个请求头，还是会走强缓存。 清空缓存并强制加载：清空本地缓存并硬性加载 spa情况下如何配置缓存策略spa通过加载一个index.html,index.html中再加载相关文件完成界面。这里就有两个地方index.html 和 其他资源。 index.html 文件名不会变化，需要使用协商缓存，服务端配置max-age = 0, 但是不能配置cache-control: no-store 其余资源，设置强缓存。根据文件内容变化文件名，保证每次引用都是新的，也不会走缓存。 webpack 如何使用强缓存 hash 项目级别的hash chunkhash 根据 入口文件相关的依赖进行hash contenthash，根据每个文件内容变化的hash nginx 如何配置缓存 针对静态资源设置]]></content>
  </entry>
  <entry>
    <title><![CDATA[ts随笔]]></title>
    <url>%2Farchives%2Fd6023bbe.html</url>
    <content type="text"><![CDATA[开发必备npm: ts-node ts-node-devvscode: 配置vscode中Inlay Hints, 插件 errorLens、typescript-import、move-ts 变量申明空间和类型申明空间类型申明空间不会编译到源码中，class会同时声明到变量声明空间和类型声明空间。 命令空间单文件中如果包含import或者export语句，当前单文件会默认被命名空间包围。也可以通过namespace在一个文件中实现多个命名空间,命名空间可以嵌套。12345678910// a.tsexport namespace b &#123; export const b = 13&#125;export const a = 'a'// c.tsimport &#123; a, b &#125; from './a.ts'console.log(b.b) 模块大致和esm相同，有如下注意的 可以只引入类型。使用import xx = require(‘xx’)时导入的是类型。ts3.8后使用import type { xx } from ‘xx’导入类型。 可以import as xx from ‘xx’, 也可以export as xx 新版本对package.json处理有更新123456789101112&#123; "main": "./dist/lib/index.js", "module": "./dist/es/index.js", "types": "dist/types/index.d.ts", "exports": &#123; // 优先 ".": &#123; "types": "dist/types/index.d.ts", "import": "./dist/es/index.js", "require": "./dist/lib/index.js" &#125; &#125;,&#125; 模块解析如果tsconfig中moduleResolution: Node 时，按照node的模块查找规则。查找规则按照path+place 的方式 path是相对或者绝对路径时，直接按照路径解析。相对路径不包含 ‘xx/‘path是动态路径时，比如 import xx from ‘xx’ 。从当前文件开始查找同级目录是否存在node_modules/xx。 place规则如下 xx.ts xx 中存在package.json 而且存在package.types所指的文件或者exports.types指定的文件 @types/xx xx/index.ts 同时针对文件扩展名，按照.ts .tsx .d.ts 顺序解析。 另外还可以通过修改设置baseUrl和paths 映射来修改这种行为。默认情况下只要设置了baseUrl,paths会默认添加 { ““: [“./“] } 配置12345678910&#123; "compilerOptions": &#123; "baseUrl": ".", // 相对于tsconfig.json "paths": &#123; "*": ["*"], // 前面一个*表示module,后面一个表示相对路baseurl的module "@/*": ["src/*"], // "@/xxx" =&gt; baseUrl + src + xxx "jquery": ["some/path/jquery"] // "jquery" =&gt; "some/path/jquery" &#125; &#125;&#125; 如果想追踪每个module的解析情况，可以使用traceResolution: true 打印解析日志tsc编译时会从入口文件开始，将相关的依赖文件同时编译。如果配置了noResolve选项指定了某些模块不编译，编译会报错。 rollup，webpack，tsc，nodejs对模块的处理都不同，都是对js文件处理。特别是ts还隐藏了一层类型查找的问题。 每个编译器所使用的的module解析方式不同，特别是在对package.json字段未统一。 从变量引用和类型引用两个角度分析。变量角度12345// test.tsimport &#123; a &#125; from "a" // 1. 寻找是否能根据baseUrl和paths匹配到模块 2.依次向上查询node_modules/a是否存在 3.如果是文件夹，先检查package.json描述,如果package.json 不存在，检查index.ts 是否存在。import b from "a/b" // 1. 同上 2. 检查node_modules/a/b 是否存在。 3. 同上3import c from './c' // 1. 检查是否配置了rootDirs。 2. ./c是否是文件夹，如果是参考1.3 import d from 'd.xx' // 1. 同上1 类型角度123456// test.tsimport &#123; a &#125; from "a" // 1. 寻找是否能根据baseUrl和paths匹配到模块,a.ts存在，直接导出a.ts的命名空间,如果只有a.js存在，需要查找a.d.ts，如果a.d.ts未查找到，同时allowJS: false，在查询是否存在当前module的 declararion 声明，查找终止。 // 2. 向上查找node_modules/a.d.ts，如果是文件夹，先查找package.json相关定义，再查找node_modules/a/index.d.ts。再加载同级@types/a 文件夹，按照上述步骤处理。 import b from "a/b" // 1. 同上1 2.import c from './c' // 1. 同上述文件夹处理方式 2. 检查是否有declaration 声明import d from './d.xx' // 后缀当做文件名处理 *.d.ts作用tsc 编译时通过 declaration: true 能自动生成.d.ts文件。如果某个模块还未被声明，ts会自动加载同名的x.d.ts作为声明文件。 target和module通过module: “Commonjs”, ts代码可以编译成cjs，amd，cmd和esm。但是cjs和amd中只支持导出一个对象这和ts export defalt, { xxx }行为不兼容。如果明确代码需要转换成cjs，需要按照如下方式编写123import xx = require('xxx') // 如果是export = xxx模式导出，必须使用这种默认引入const a = 123;export = a; tsconfig重点字段详解types、typeRoot和node_modules/@type默认情况下，tsc会加载编译上下文中所有.d.ts、同时还会加载node_modules/@type文件中所有的.dt.ts，以及向上目录的所有node_modules/@type。通过typeRoot指定默认文件夹（不会在向上循环查找），或者通过types指定typeRoot中需要加载部分*.d.ts文件。 extends可以继承多个配置，在需要打包不同的library时有用。不同配置文件中的配置的路径是根据该配置文件相对。 rootDir 和 rootDirsrootDirs用于把多个不同实际位置的目录组合到一个虚拟目录中，方便引用。比如src/a.ts 和src1/b.ts，组合到一个虚拟目录中后可以import xx from ‘./b’ rootDir设置单个的虚拟目录，用于解决打包后文件目录和src不一致问题。默认值所有非声明输入文件的最长公共路径。相当于打包前将包含的文件放置到路径.replace(rootDir, dist)。 baseurl和pathbaseUrl用于处理module中non-relative，默认会在node_modules 前查找。配置paths使用可以自定义路径别名 path用于配置别名 alias: baseUrl + path。和webpack declarationdeclaration: true， 开启编译时生成.d.ts文件，默认情况下声明文件和编译后的js文件放在同一位置，通过declarationDir: ‘path’指定声明文件存放路径，声明文件的 allowJS 和 checkJSallowJS: true 允许在ts中直接在加载js文件，即使这个js文件没有.d.ts。 checkJS 加载js文件时，同样检查js的类型系统 null 和 undefined未开启strictNullCheck时，默认是其他类型的子类型 let a: string = null; 支持具名元组type A = [name: string, age: number, desc: string]; 建议写不出类型时，使用以下替代针对object使用Record&lt;string, unknown&gt;，数组使用unknown[] symbol的特殊地方symbol类型是共有的，可以添加unique 限制symbol 赋值。let a: symbol = Symbol(“1”)let b: symbol = a; const c: unique symbol = Symbol(“1”);const d: unique symbol = c; 字面量类型字面量类型总是对应原始类型(拆包类型)的子类型，函数类型没有字面量类型 联合类型和交叉类型联合类型具有联合作用，表示几种类型的联合，使用时需要指明当前是具体是哪个类型，否则只能使用联合的部分，函数类型需要使用() 包裹起来 交叉类型具有交叉的语意表示几种类型的并集，同时具有几种类型的特性，针对基本类型一般都是never，不可能一个类型同时有boolean和number特性。如果是interface 交叉，相同属性名也是按照基本类型的规则 枚举ts中的枚举是双向映射的（常量枚举除外）,枚举也是在变量空间和类型空间同时存在12345678910enum EnumA &#123; A, B, C = 'c'&#125;const enum enumConstA &#123; A, B&#125; EnumA.A 和 EnumA[‘c’] 都可以。常量枚举不会再源码中编译. 函数类型 如果函数没有返回语句，建议将函数返回值标记成void, 同时不建议写行内声明比如 let a: (a: string) =&gt; number = (a: string): number =&gt; { return 1} 支持函数类型重载，比如函数的参数具有一定逻辑性时12345function testA(user: string, age: number):number;function testA(user: number, age: string): string &#123;&#125;// 当第一参数传入string时，第二参数必须是number class抽象类和interface怎么样选择? 无脑抽象类（抽象类还是实现部分逻辑） never表示永远不会到达，常见于函数报错终止。在体操类型时比较常见。 string &amp; never = never string &amp; (string | never) = string &amp; string | string &amp; never = string | never = string 索引类型，工具类型泛型是一个工具类型，用于生成其他类型索引类型的键必须要是 keyof any =&gt; string | number | symbol。 同时索引类型中具名类型必须满足索引类型的定义定义1234interface A &#123; propA: string; [k]: number // 不行，&#125; 使用字面量联合类型进行索引类型访问时，其结果就是将联合类型每个分支对应的类型进行访问后的结果，重新组装成联合类型。索引类型查询、索引类型访问通常会和映射类型一起搭配使用，前两者负责访问键，而映射类型在其基础上访问键值类型，我们在下面一个部分就会讲到。 注意，在未声明索引签名类型的情况下，我们不能使用 NumberRecord[string] 这种原始类型的访问方式，而只能通过键名的字面量类型来进行访问。 类型收缩 如果是直接在if语句中使用typeof，类型会收缩 如果if语句是函数判断，在函数中使用is断言 通过可辨识的属性来区分时，针对同属性名不同类型，需要具体到字面量类型 instanceof 和 typeof一样，用于class类型的断言 使用asserts后，后续同作用域的代码均会变成断言的类型 interface 和 typeinterface 可以实现接口合并和继承，在实现合并继承时，子接口的属性必须要要兼容父接口。 type 常用于实现联合类型、泛型、交叉类型 泛型泛型允许默认类型type A = T; 调用时按照type B = A。泛型类型约束 A extends B，表示A是B的子类型。 类型自身是自身的子类型 字面量类型都是对应原始类型的子类型 联合类型子集都是联合类型的子集, 下级类型总是上级类型的子集，比如 { age: number } extends {}; 泛型参数之间也存在约束，后续的参数总是能依赖前面参数进行约束, 不能后面约束前面 函数泛型只允许出现在函数申明的地方（无法再type中定义），在类型检查时可以由函数执行时推导T的类型，同时也支持泛型约束,泛型也是总是最小字面量原则。class泛型也是同理123function a&lt;T extends string | number = string&gt;(input: T = '123'): T&#123; return input&#125; 结构化类型只要一个类型A有另一个类型B所有的特征，这个类型A就兼容类型B 装饰器技巧巧用declare来实现验证如下123456interface Tmp &#123; name: string; age: number;&#125;declare let tmp: Tmptmp.name = 123 // 用于快速验证]]></content>
  </entry>
  <entry>
    <title><![CDATA[ccna]]></title>
    <url>%2Farchives%2F838de56f.html</url>
    <content type="text"><![CDATA[三种配置模式 用户模式 console登录上去默认 命令行标识符为 &gt; 特权模式 输入 en | enable进入， 标识符为 # 配置模式 输入 configrue terminal 标识符为(terminal)# console 配置密码防止内鬼直接console进入设备12345678910en # 特权模式configure t # 配置模式line # 线缆模式line console 0 # 选择console 0password somepass # 设置密码login # 激活登录 # 取消密码no login # 不激活密码no password # 删除密码 华为仅只有用户视图密码123456system-viewuser-interface console 0# 路由器authentication-mode password# 交换机set authentication password simple somepassword 特权模式设置密码需要在配置模式设置123enable password somepasswordno enable password 删除密码 查看线缆链接情况12345enableshow line # 华为show user-interface 星号表示当前正在使用的端口vty: 虚拟ttycty: console ttyaux: 不常用 查看当前模式下所有配置1234# 思科show running-config# 华为display currenting-configure 保存配置不保存配置关机后之前的配置会消失12345enablewrite# 华为只在用户模式保存save]]></content>
  </entry>
  <entry>
    <title><![CDATA[umd,cmd,commonjs,esmodule学习教程]]></title>
    <url>%2Farchives%2F4986aa26.html</url>
    <content type="text"><![CDATA[amdamd Asynchronous Module Definition 异步模块化定义, requirejs实现了这套规范，思想是前置依赖，主要包括以下几个方法 require.config() 配置依赖 define([deps], callback)。定义模块 require([deps], callback)。引用模块12345678910111213141516171819202122232425262728293031// dependA.jsdefine([ 'dependB'], function(dependB) &#123; return &#123; start: function() &#123; document.write(dependB.name) &#125; &#125;&#125;);// dependB.jsdefine(function() &#123; return &#123; name: 'dependB' &#125;&#125;);// main.jsrequire.config(&#123; baseurl: '/static/umd', paths: &#123; "dependB": 'dependB', "dependA": 'dependA', &#125;&#125;)require(['dependA'], function(dependA) &#123; console.log(dependA) dependA.start()&#125;) 查看演示。requirejs 需要预先配置好所有依赖。不能动态获取所有 cmdcmd 通用模块定义（Common Module Definition）。seajs实现了这套规范，依赖是就近依赖，延迟执行。1234567891011121314151617181920212223// main.jsseajs.config(&#123; alias: &#123; dependB: './dependB.js' dependA: './dependA.js' &#125;&#125;)seajs.use('dependA')// dependA.jsdefine(function(require, exports, module) &#123; let dependB = require('dependB'); dependB.start()&#125;)// dependB.jsdefine(function(require, exports, module) &#123; 'use strict'; exports.start = function() &#123; document.write('dependB') &#125;&#125;); 查看演示。seajs通过正则解析，预先将当前文件的require的module加载，所以require可以同步加载 commonjscommonjs 是nodejs实现的一套模块化规范，和seajs类似。通过require、exports、module实现动态导入导出，不过不需要写define语句。123456// moduleA.jsconst a = require('A');exports.someA = function() &#123; console.log('someA')&#125; commonjs下，为什么我们可以在文件中使用dirname,filename, require，module,exports等。 nodejs会将js文件进行包裹，类似下面这种。12345(function(exports, require, module, __dirname, __filename,...) &#123; exports.say = function() &#123; console.log('say') &#125;&#125;) 包装函数如下12345678910111213function wraper(functionStr) &#123; return `function(exports, require, module, __dirname, __filename) &#123; $&#123;functionStr&#125; &#125;`&#125;let moduleFunction = wraper` export.say = function() &#123; console.log('say') &#125;`runInThisContext(moduleFunction)(exports, require, module, __dirname, __filename) runInThisContext 相当于eval或者new Function。实现动态申明函数的功能。读取文件内容 =&gt; 添加包裹 =&gt; eval生成函数 =&gt; 添加相应参数 =&gt; 执行，require整个流程。 在代码中可以打印require和module，查看具体详情。 require加载流程require加载模块有3类 nodejs底层核心模块 工程中代码 npm 中的第三方代码 require标志符指require时的参数，按照以下方式解析 如果标识符是核心模块，加载核心模块。 如果标志符以./ / ../开头，视为项目代码，会解析成绝对路径，作为module标志 如果不满足上面，则认为是第三方模块。 解析第三方模块规则如下 从当前__dirname 开始，寻找是否存在node_modules, 在node_module 中查找标识符目录，如果查询到，检查package.json 中是否存在main字段，如果有根据main字段指向的js作为module入口，如果没有使用index.js ，index.json ，index.node。 如果未找到node_modules, 在父级目录查找，直到根目录。重复执行上述流程。 !()[] require 解析是按照深度优先的原则，按照代码执行顺序解析require。 require 简单源码commomjs 将所有文件视为一个module，module包括文件解析相关信息。1234567891011121314151617181920function require(id) &#123; const cacheModule = Module._cache[id] if(cacheModule) &#123; return cacheModule.exports &#125; const module = &#123; exports: &#123;&#125;, loaded: false, ... &#125; const fileContent = getFileContent(id); Module._cache[id] = module; runInThisContext(warper(fileContent))(module, module.exports, require, __filename, __dirname) module.loaded = true; return module.exports&#125; 如上所示，相同标识符下，require只会加载一次，避免了循环引用问题。 delete require.cache[moduleName]; 具体参考 commonjs 详解 umdumd是兼容amd和commonjs的规范，对代码做相应包括可实现。12345678910111213141516171819(function (context, factory) &#123; if (typeof module === 'object' &amp;&amp; typeof module.exports === 'object') &#123; console.log('是commonjs模块规范，nodejs环境') module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; console.log('是AMD模块规范，如require.js') define(factory) &#125; else if (typeof define === 'function' &amp;&amp; define.cmd) &#123; console.log('是CMD模块规范，如sea.js') define(function(require, exports, module) &#123; module.exports = factory() &#125;) &#125; else &#123; console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory(); &#125;&#125;)(this, function(exports, module) &#123; // js 代码&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[vercel白嫖教程]]></title>
    <url>%2Farchives%2Ff79d6af9.html</url>
    <content type="text"><![CDATA[简介vercel 可以托管静态资源，ssr，和serverless 函数。官网地址 https://vercel.com，首次使用需要邮箱注册，建议绑定github 账号，方便登录。 托管vue项目]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuex-db设计]]></title>
    <url>%2Farchives%2Fa8ae78e0.html</url>
    <content type="text"><![CDATA[分类系统存储，普通数据存储，用户数据存储，页面数据存储，页面用户数据存储，路由快照和路由用户快照。 系统存储用于存储用户打开的标签页，是否展开侧边栏，页面大小，主题等数据， 实现方案123456789101112import low from 'lowdb';import LocalStorage from 'lowdb/adapters/LocalStorage';import &#123; cloneDeep &#125; from 'lodash'const adapter = new LocalStorage('db'); // localstorage 名称const db = low(adapter);db.defaults(&#123; posts: []&#125;).write()db.get('posts').push(&#123; title: 'vue解密' &#125;).write() 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// util.db.jsimport low from 'lowdb';import LocalStorage from 'lowdb/adapters/LocalStorage';import utils from '@/utils'db .defaults(&#123; sys: &#123;&#125;, database: &#123;&#125; &#125;) .write()export default db/** * 初始化路径, 如果提供了默认值，会将默认值写入。如果已经存在值并且值校验出错，重新写入默认值 */export function pathInit(&#123; dbName = 'database', path = '' , user = user, validator = () =&gt; true, defaultValue = '' &#125;) &#123; const uuid = utils.cookies.get('uuid') || 'ghost-uuid'; const userPath = user ? `user.`$&#123;uuid&#125; : 'public'; const keyPath = path ? `.$&#123;path&#125;` : '' const finalPath = `$&#123;dbName&#125;.$&#123;userPath&#125;$&#123;keyPath&#125;` const value = db.get(finalPath).value(); if(value === undefined || !validator(value) ) &#123; db.set(finalPath, defaultValue).write() &#125; return finalPath;&#125;export function dbSet(&#123; dbName = 'database', path = '', user = true, value = ''&#125;) &#123; db.set(pathInit(&#123; dbName, path, user, &#125;), value) .write()&#125;/** * 获取db值，如果没有值，设置一个默认值并返回 */export function dbGet(&#123; dbName = 'database', path = '', user = true, defaultValue = ''&#125;) &#123; return cloneDeep(db.get(pathInit(&#123; dbName, path, user, defaultValue &#125;)).value())&#125;/** * 获取一个db对象，可以执行set, write操作 */export function database(&#123; dbName = 'database', path = '', user = true, defaultValue = '', validator = () =&gt; true&#125;) &#123; return db.get(pathInit(&#123; dbName, path, user, defaultValue, validator &#125;))&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// store/module/db.jsimport router from '@/router';import &#123; cloneDeep &#125; from 'lodash'import &#123; database as getDatabase, dbGet, dbSet &#125; from '@/utils/util.db.js'export default &#123; namespace: true, actions: &#123; set(ctx, &#123; dbName, path, value, user = false &#125;) &#123; return dbSet(&#123; dbName, path, value, user &#125;) &#125;, get(ctx, &#123; dbName, path, defaultValue, user = false &#125;) &#123; return dbGet(&#123; dbName, path, defaultValue, user &#125;) &#125;, database(ctx, &#123; user = false, defaultValue = &#123;&#125; &#125;) &#123; return getDatabase(&#123; user, defaultValue &#125;); &#125; databaseClear(ctx, &#123; user = false &#125;) &#123; return getDatabase(&#123;user, validator: () =&gt; false, defaultValue: &#123;&#125;&#125;) &#125; databasePage(ctx, &#123; user = false, basis = 'fullpath'&#125;) &#123; return getDatabase(&#123; path: `page.$&#123;router.app.$route[basis]&#125;`, user, defaultValue: &#123;&#125; &#125;) &#125; databasePageClear(&#123; user = false, basis = 'fullpath', &#125;) &#123; return getDatabase(&#123; path: `page.$&#123;router.app.$route[basis]&#125;`, user, validator: () =&gt; false, defaultValue: &#123;&#125; &#125;) &#125; &#125;,&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[js编码规范]]></title>
    <url>%2Farchives%2Fe960579a.html</url>
    <content type="text"><![CDATA[Javascript 编码规范[TOC] 术语 原则: 必须坚持的指导思想 建议: 需要加以考虑的约定 不好示例: 反面教材，里面的都是错误示范 推荐示例: 正面教程，可以按照里面示例类推 命令文件建议: 不使用index文件实现逻辑，index用于聚合导出。避免componentA/index.js，然后在index.js 写component的逻辑，正确的写法是 componentA/componentA.js。 componentA/index.js 仅作导出。当你在浏览器resource查找文件就知道了-__-。 命名原则原则: 源文件编码格式（包括注释）必须是UTF-8大家一定被乱码的解释折磨过…. 原则: 方法、变量需要一个好名字好的名字有包括不局限以下特征: 清晰表达意图：使用有描述性的型单词，避免使用单个字母，或者自创缩写来表达，比如 let lastDay 比 let ld 要好 必须使用英文单词，不允许出现中文拼音（约定熟成除外）。中文拼音在多音字表现上会有歧义，而且不太利于团队以后成成长 避免误导性命名，有误导的命名比表达不清晰还要危险，比如 let nameArray 不是一个array类型，而是一个字符串。 能区分出意思，建议不要在变量后面加上data，info，object等一般意思的词。比如productInfo和productData有什么区别。 类原则: 构造函数、类命名都是用大驼峰推荐示例12function Kind() &#123;&#125;class People() &#123;&#125; 不好示例12function kind() &#123;&#125;class people() &#123;&#125; 原则: 方法命名使用动词、动宾结构，并遵守驼峰原则格式如下 get + 非布尔属性名 is + 布尔属性名 set + 属性名 has + 名字\形容词 动词 动词 + 宾语不好的示例12345function type() &#123;&#125;function Finished() &#123;&#125;function visible() &#123;&#125;function DRAW() &#123;&#125;function keyListener() &#123;&#125; 推荐示例:12345function getType() &#123;&#125;function isFinished() &#123;&#125;function setVisible() &#123;&#125;function draw() &#123;&#125;function addKeyListener() &#123;&#125; 原则: 方法名不能过长影响可读性方法名不能超过15个字符，可以采用去掉元音字符或者业界约定的缩写来表示。比如 function getCustomerInfomation() {} 可以改成 function getCustomerInfo() {} 建议: 私有属性或者方法， 建议以下划线_开头变量原则: 变量名遵循驼峰风格, 首字母大写，后续每个单词小写建议: 避免使用否定的布尔变量名对于否定的布尔变量名，当使用逻辑非运算符时，会出现双重否定，对阅读造成阻碍，比如!isNotError。 不好示例:12const isNotError = true; // 到底有没有错const inNotFinished = false; // 结束没有 推荐示例12const isError = false;const inNotFinished = true; 建议: 缩写词应该全部大写或者小写，不要混搭。原则: 不要用保留字作为键名或者变量名，使用同义词。为了兼容未来，虽然在语法上使用保留字作为键名是可以允许的。可以这样改class =&gt; klass， default =&gt; defaults，private =&gt; hidden 原则: 常量使用全部大写并且用下划线_分隔 不要魔鬼数字，比如错误码 response.code === &quot;0000&quot; || response.code === 5, 这种代码，不熟悉的人需要花时间去理解 5 是什么，&quot;0000&quot; 又是什么。 不要魔鬼常量，比如const NUM_FOUR = 4这种脱了裤子放屁行为;推荐示例123456const SUCCESS_CODE = '0000';if (response.code === SUCCESS_CODE) &#123; ....&#125;const MAX_GOODS_NUM = 4; 注释注释原则最好的注释就是没有注释注释的作用是解释代码。如果变量命令足够清晰，代码结构好就不需要注释。举个例子1234// 大于65岁并且是职工，或者性别是女可以领福利if ((person.flag === 0 &amp;&amp; person.age &gt; 65) || person.sex === 1) &#123; ....&#125; 别人审阅读代码时需要看注释才能知道if语句中含义。可以换成如下写法123if (isBenefits(person)) &#123; ...&#125; 直接通过阅读代码就可以理解到意思，如果需要深读判断逻辑，同时隔离的函数也方便阅读。 原则: 注释的作用是帮助理解代码，而不是误解代码无用的注释，过期的注释及时清理掉。如果一个注释和代码实现不一致，那么enummmm….。 原则: 不要出现todo代码，todo代码自己在个人备忘录记录。大家习惯把部分代码标记上todo，然后推到公共分支。如果某一天你不接手这个项目了，后面的人看到你写的todo，他到底需不要todo，这是个问题。 建议: 不要临时注释屏蔽代码，直接删除。临时注释屏蔽部分代码是大部分人常见的操作，可以直接删除。如果后续需要找回，git来帮忙。否则后面的人接手一看，这个代码屏蔽注释了，不知道啥原因，不敢动，久而久之，x山。 原则: 不要用注释记录文件修改信息都用git了， 不要在文件开头去记录xxx多久修改了啥。git信息里面都有。 注释风格原则: 单行注释使用 //, 多行注释 /** */, 文件注释用 / \/推荐大家使用jsDoc风格的注释规范 原则: 注释和描述的代码相邻，放在代码上方，并且和代码的缩进一致。原则: 注释要和上方的代码块有间隔，间隔一行。 // 后空两格。排版风格排版可以从下面的维度出发，给出每个维度的建议项和原由，各团队可以自行商议。 建议: 团队内风格应该保持一致，大家商量，抛弃个人喜好建议: 团队内将风格固化到IDE中，通过eslint，stylelint, editorConfig等来保证一致性。缩进原则: 禁止使用制表符作为缩进制表符在不同IDE或者代码阅读器上面表现的风格不一致，有可能产生对齐错乱的问题。空格在不会有这样的问题。我们在开发中常使用tab键实现缩进，需要把tab设置为缩进空格。 建议: 缩进使用2个空格缩进。缩进过大，在嵌套过深的情况，需要拖动横向滚动条条才能阅读代码，不方便阅读。 换行建议: 超长代码需要换行，换行时操作符放在前面推荐示例12345const resultA = xxx ? 'a' : 'b';const resultB = xxxxxxxxxxxxA &amp;&amp; xxxxxxxxxxB &amp;&amp; xxxxxxxxxxC 建议: 函数参数尽量在同一行，对于超长的场景每个参数独占一行。推荐示例1234567function someFunction(arg1, arg2, arg3, arg4) &#123;&#125;function someLongerFunction( xxxxxxxxxxA, xxxxxxxxxxB, xxxxxxxxxxC, xxxxxxxxxxD) &#123;&#125; 建议: 对象字面量超过4个，都应该换行不好的示例1const airticle = &#123; title: '中国之声', author: 'some people', date: '2012-02-01', preview: 999, total: 334343 &#125;; 推荐示例1234567const airticle = &#123; title: '中国之声', author: 'some people', date: '2012-02-01', preview: 999, total: 334343 &#125;; 建议: 链式调用对象时，一行最好不超过4个调用，可以改成每个独占一行。不好示例1someInstance.queryAll().find('classA').forEach((item) =&gt; handle(item)).map(item =&gt; item.name).end() 推荐示例123456someInstance .queryAll() .find('classA') .forEach((item) =&gt; handle(item)) .map(item =&gt; item.name) .end() 建议: else 和 if尾括号放在同一行，else if同理推荐示例12345if () &#123; ....&#125; else &#123; ....&#125; 不好示例123456if () &#123;&#125;else &#123;&#125; 建议: 设置每行的最大长度，超过最大行数需要换行。阅读代码最喜欢时从上到下阅读，不喜欢横向滚动条。推荐每行最大长度不超过180 建议: 条件语句过长的，可以将每个条件都放入当都一行，操作符放在开头空行原则: 不同的逻辑块之间空一行相对独立的代码块之间考虑换行（一般这个时候你需要提炼函数了-_-）。 建议: class中，方法和方法之间需要换行。不同逻辑区间的属性之间换行。12345678910111213141516171819class People &#123; age: 36, sex: 'male', career: 'teacher', isFlag: false, isRegisted: true children: [], parent: &#123;&#125; checkValid() &#123; ... &#125; handleError() &#123; ... &#125;&#125; 原则: 方法体、块语句、类的开始或者末尾不要有空行。建议: 一般情况下，不要使用连续空行。空格建议: 关键字周围空格一致性 在保留字(if, for while) 和左括号( 之间添加一个空格 else catch 与 关闭花括号 } 之间添加一个空格 在任何打开花括号前添加一个空格, (函数参数和模板中去除外) 1234// 下面这三种情况除外function too(&#123; name &#125;) &#123;&#125;function foo([ name ]) &#123;&#125;const str = `#$&#123;s&#125;`; 在任何三元或者二元操作符的两侧增加一个空格 数组和函数参数逗号, 后面添加一个空格，前面不要增加空格。 ; 前面不要空格 单行 {} 内侧需要一个空格 1const objA = &#123; name: 'xxx', total: 2 &#125; 数组[]内侧不要有空格 [a, b, c]，不要[ a, b ]。 禁止出现多个空格，除注释和缩进外。 花括号建议: 总是给代码执行体添加{}while, if, for, do，即使执行语句只有一行。1if (result) foo++; 上面这种看着很酷，如果需要多写一个语句，就需要三行的改动，如果我们事先添加好花括号。改动只有一行，出错的机率大幅度减低。血的教训——__——。 建议: 花括号要和语句在一行123class Xxx &#123; ...&#125; 不好示例1234class Xxx &#123; ....&#125; 建议: 对象字面量和数组中使用拖尾逗号,12345const obj = &#123; keyA: 'xxx', keyB: 'xxx', // 拖尾逗号&#125;const someArray = ['xxxA', 'xxxB',] 建议: 每行代码句后添加分号。123456789101112// 这个代码会被解析 some = 'xxx'; 而不是 some = getSome;function getSome(arg1) &#123; return arg1; &#125;const some = getSome(()=&gt; &#123; return 'xxx'&#125;)()// 这个代码会被解析成 return; &#123; .... &#125;;return &#123; ....&#125; 建议: 单文件长度最好不要超过1500行，尽可能的考虑拆分建议: 单个方法长度不要超过50行建议: 圈复杂度不要超过20建议: 块嵌套深度不超过4层。if语句判断等建议: 回调深读不超过4层。变量原则: 优先使用const，其次let。非特殊场景不使用var原则: 在使用地方申明变量，且尽快初始化原则: 每行申明一个变量，结构和for循环除外 方便阅读 在debug模式下，可以按行阅读。单行代码无法优美的查看（大雾）。不好示例1const varA = 'nb', B = 123; 推荐示例12345678const varA = 'nb';const varB = 123;for (let i = 0, len = arr.length; i &lt; len; i++) &#123; ...&#125;const [varA, varB] = ['nb', 123] 建议: 申明阶段禁止连续赋值建议: 变量不需要使用undefined来初始化未赋值的变量会默认有一个undefined的初始值(????) 建议: 非特殊情况一般使用基础类型的字面量来初始化，而不是封装类型。不好的示例1234567891011121314const stringA = new String('A');const numberB = new Number(123);console.log(numberB + 1) // 124;// 会有语义上的不明确const arrA = new Array(3, 4, 5); // [3, 4, 5]const arrA = new Array(4) // [empty * 4] 语义不明确const arrC = new Array('4') // ['4'] // 语义不明确// 考虑可读性和冗余性，对象也是const objA = new Object(&#123; keyA: 'longfor', keyB: 123&#125;) 建议: 内部作用域变量不要覆盖外部作用域变量会导致更深层次的代码无法获取到想要的变量，在后续变更操作中，增加出错风险。 不好示例12345678910111213function a() &#123; const aa = 1; function b() &#123; const aa = 2; function c() &#123; // 如果c函数需要知道a函数中aa咋办??????? console.log(aa) &#125; c() &#125; b()&#125;a() 参数建议: 方法的参数不超过5个超过5个的参数，将逻辑关联的参数放入对一个对象中。 建议: 函数参数指定默认参数，不是使用 || 指定默认参数不好示例1234// 如果 a = false 或 a = ''；enummmmm.....function test(a) &#123; a = a || true&#125; 建议: 永远不要改变参数的值。 如果函数中新增加一个功能，需要用到参数的原始值，想要一下需要改动的地方有多少。 如果参数是引用传参，改变参数的属性会导致修改传入外部，造成一些不必要的问题。建议: 默认参数放在最后面默认参数放在前面，需要写undefined来占位，放在后面可以不用。不好示例12function test(argA = &#123;&#125;, argB) &#123;&#125;test(undefined, 'test'); 推荐示例12function test(argB, argA = &#123;&#125;) &#123;&#125;test('test'); // cool....。 建议: es6不要使用arguments, 请rest替代 箭头函数不存在arguments arguments只是类数组，操作不方便 建议: 对于外部API，始终对参数进行校验。为了保证健壮性，防御性编程不可少(大雾) 建议: 优先使用参数结构申明与实现原则: 函数申明一致性函数有表达式声明和function申明。有如下区别 function申明会将申明提升到作用域顶级，可以在申明前调用 表达式申明不会提升，在申请前使用会出错(not a function)团队应该选择统一的风格来实现，推荐使用表达式申明。 建议: 匿名函数优先使用箭头函数普通函数和箭头函数性能和开销没有太大差别，但是匿名函数没有this的困扰(^-^)。 原则: 箭头函数参数风格一致性有下面有两种风格 只有一个参数的情况下去参数括号。 1const test = argA =&gt; argA * 2; 总是添加参数括号 1const test = (argA) =&gt; argA * 2; 推荐第二种方式，没有花括号的方式会有阅读上的停顿。 原则: 箭头函数return风格一致性同上，方法体只有一个return 语句，是不是需要添加花括号。推荐总是添加花括号，丑一点但是方便断点调试。 建议: 函数有多个返回参数时使用对象解构优先使用对象结构而不是数组解构。不然冷不丁出现这种const [a,,b,,c] = [1,1,1,1,1,1] 类与对象类建议: 优先采用class定义类 class关键字定义类简洁，而且逻辑更易于阅读。 不仅仅时语法糖，class的构造函数有特殊的内部属性[[IsClassConstructor]]: true, 可以防止被作为普通函数使用。 String(SomeClass) 会得到什么? – class SomeClass {} 建议: 使用extends来实现继承。原则: 构造函数中禁止在super() 前调用this或者super.xx建议: 在构造函数中申明所有的属性和方法。不要在类实例化后再动态添加属性, 如果一个属性实在执行时被赋值的，也需要先申明，方便VM优化。 字符串建议: 优先使用单引号当你创建一个包含html代码时候就知道了 建议: 字符串使用模板字符串可阅读性，一堆 + 很难阅读，特别时字符串中带有 + 时。 原则: 不使用\字符串行连续符号。当你在\ 后面加个空格时，找代码会找的你怀疑人生。 直接写在一行，大部分IED会处理用多行来显示一行。 数组建议: 添加元素使用数组的push方法，而不是索引赋值数组的length有长度限制，push会检查并抛错，赋值没有。极限情况下出现length不更新问题。 建议: 不在数组定义非数字索引有特殊场景需要添加，建议替换成map或者set。 建议: 数组遍历优先使用数组上方法建议: 除特殊场景， 不要使用for in遍历数组。建议: forEach中不要对数组进行增加删除操作对象建议: 对象字面量属性名统一风格，不加引号。非特殊场景不使用混搭风格不好示例1234567const objA = &#123; 'name': 'AAA', title: 'welcome to AAA', // 特殊情况 'some-one': '123'&#125; 建议: 尽量在申明时将所有属性申明好，少动态添加。建议: 对象字面量中，方法使用简写。推荐示例123456const objA = &#123; key: 'a', getKey() &#123; return this.key; &#125;&#125; 不好示例123456const objA = &#123; key: 'a', getKey: function() &#123; return this.key; &#125;&#125; 建议: 推荐使用对象字面量中使用简写属性推荐示例1234567const key = 'a'const objA = &#123; key, getKey() &#123; return this.key; &#125;&#125; 不好示例1234567const key = 'a'const objA = &#123; key: key, getKey() &#123; return this.key; &#125;&#125; 建议: 使用.号来访问属性方法，只有动态情况或者数字索引下采用[]访问原则: get 和 set 必须成对出现，否则没有意义。如果只有get，表示该属性只可读，不可写。如果只有set，表示该属性只可写，不可读。 原则: 禁止在对象上使用Object.proptotype 的内置属性，用call代替如果一个来自外部的JSON resData = { hasOwnProperty: 1 }; 如果调用resData.hasOwnProperty() 就会出现安全风险。用Object.proptotype.hasOwnProperty.call(resData) 则不会。 建议: for in循环对象需要约束for in 会将原型链上的属性包括进来，建议使用Object.prototype.hasOwnProperty() 过滤，或者直接使用Object.keys转成数组循环。 建议: 严禁对内置的类型添加修改属性方法。常见在String.prototype 上面添加方法等。 运算和表达式条件表达式建议: 条件表达式中，变量在先，表达式在后。有种观点时变量在后面，为了防止 if (a = 1) {}这种低级错误出现。不过为了可阅读性，我们推荐变量的在前面，配合现在IDE，可以避免这种错误。 建议: 总使用 === 和 !==， 不使用 == 和 !===和!=对于新人来说难以掌握，而且也不利于阅读。所有 == 和 != 的场景都可以用 === 和 !== 表示出来。 建议: 条件语句尽量简单不好示例12if (isValid === true) &#123;&#125;const isFinished = condition ? true : false; 建议: 不要在一个复杂的条件表达式最前面添加否定!不好示例123if (!((person.flag === 0 &amp;&amp; person.age &gt; 65) || person.sex === 1)) &#123; // 来读读这个是啥意思 ....&#125; 需要否定的地方，用数学知识处理一下，解开括号。原则是 AND-OR互换，!抵消。括号加在 OR 中，从左到右依赖删除括号。对!(!conditionA || !conditionB &amp;&amp; conditionC) 举例。 AND-OR互换: !!conditionA &amp;&amp; !!conditionB || !conditionC ! 抵消: conditionA &amp;&amp; conditionB || !conditionC 括号加在 OR 中 conditionA &amp;&amp; (conditionB || !conditionC) 观察是否能够消除括号，这个例子不能消除括号。建议: 非特殊场景，if else 条件判断不要否定在前 建议: 禁止使用嵌套的三元表达式嵌套的三元表示式需要用栈的思维来阅读。建议多写几个if替代。 建议: 混合条件表示式，使用括号来标记运算顺序。建议: 每个switch语句总是有default，即使default里面为空防御性编程意识不可少，当定义了default，就会想switch的错误场景。 建议: 非特殊场景，总是给每个case添加break建议: 总是给每个case的执行体添加花括号{}switch中，每个case都在switch代码块，作用域共享。为了防止出错，建议给每个case添加花括号形成块作用域。 推荐示例123456switch (code) &#123; case: '0000': &#123; .... break &#125;&#125; 正则原则: 正则表达式中不要出现连续空格不好示例1const testReg = /test test/; // 你能直接知道是几个空格吗 推荐示例1const testReg = /test &#123;4&#125;test/ 建议: 总是使用具名捕获组比如 &#39;web-doc&#39;.match(/-(?&lt;customName&gt;\w)/).groups，可以得到 { customName: &#39;d&#39; } 一些特性作用域建议: 不要在顶层作用域申明函数变量一般情况下，大部分人会忘记顶层作用域就是全局作用域。如果要申明，应该显示的申明到windows或者global上。 建议: 谨慎添加window上属性。尽可能用命名空间实现，给windows挂载一个特殊的属性，剩下的挂在在这个属性下面。参考jquery 或者underscore 数字建议: 禁止省略小数点前后的0好好写嘛 不好示例123const numA = .5;const numB = 2.;const numC = -.9; 原则: 使用isNaN() 来检查NaN异常建议: 异常的原则 异常总是Error子类或者Error 优先考虑内置异常， 不满足情况下使用自定义异常 捕获的异常不处理需要注释说明 建议: promise中reject总是返回异常，而不是其他;Promise rejct 返回 Error可以看到错误栈，方便调试，断点神器。 异步原则: 不要 return await写法直接return，async 本身会返回Promise对象。 杂谈建议: 一般不使用eval，如果需要，务必需要多人评审。原则: 防止出现隐形evalsetTimeout 和 setInterval第一个参数为字符串时，和eval一样。不过大部分浏览器会拦截这个漏洞。 原则: 非特殊场景不用withwith可以提升性能，如果掌握不好会有一定的安全风险，比如在语义不明的情况，开发可能错误的执行了某个对象上的方法。建议团队评估后使用。 建议: 类型转换都用显示的方法处理，不要短符号实现。 布尔类型: 用 Boolean(numA) 代替 !!numA 数字类型: 用 Number(strA) 代替 +strA 其余类推 原则: DOM卸载时，务必移除事件绑定。不然哪天内存泄漏都找不到原因，引用计数GC的浏览器有这个问题。 原则: 及时清理定时器和延时器同样会导致内存泄漏，还要]]></content>
  </entry>
  <entry>
    <title><![CDATA[github-action]]></title>
    <url>%2Farchives%2F355afdd9.html</url>
    <content type="text"><![CDATA[术语workflow: 一次持续集成 job: 一次workflow包含一个或者多个job，在没有依赖的情况下，多个job异步执行 step: 每个job 由多个step组成，同步执行 action: 每个step可以执行一个或者多个action 简单例子12345678910111213141516171819202122232425262728name: github pageson: push: branches: - masterjobs: build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@master - name: build uses: actions/setup-node@v1 with: node-version: '10.x' - run: | npm install npm run hexo g - name: deploy uses: peaceiris/actions-gh-pages@v2.5.0 env: ACTIONS_DEPLOY_KEY: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; EXTERNAL_REPOSITORY: xunserver/xunserver.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue查漏补缺]]></title>
    <url>%2Farchives%2F98f4c1bc.html</url>
    <content type="text"><![CDATA[动态编译 Vue.compile(str)完整版情况可以将模板加载成render函数，实现远程加载功能 阉割版的响应数据 Vue.observable(obj)创建一个可响应对象，目前我们的可以响应对象在data，watch,computed 中， 这个阉割版的可以响应对象用于渲染函数和计算属性中 watch可以监听一个数组，也可以是一个方法123456789101112watch: &#123; a: 'someMethod' // vm实例中方法, b: [ &#123; handler: function () &#123;&#125;, deep: true, immediate: true &#125;, function () &#123;&#125;, 'someMethod' ]&#125; 插槽新功能 v-slot v-slot:slotName 指定具名插槽 v-slot在单个插槽的情况下可以绑定非template，其余必须绑定到组件上 v-slot可以简写为#, 认插槽需要#defaultv-bind 支持对象绑定, 动态绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 绑定一个 attribute --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定一个全是 attribute 的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt; v-pre 手动指定这个元素和其子元素不需要编译。直接展示原始标签不需要响应式的数据记得冻结，比如表格数据1234567891011121314151617&lt;script&gt; export default &#123; data() &#123; retur: &#123; data: [] &#125; &#125;, async beforeMounted() &#123; this.data = await this.getData() &#125;, methods: &#123; async getData() &#123; return Object.freeze(someData) &#125; &#125; &#125;&lt;/script&gt; 静态内容尽量使用template模板渲染， 不使用jsx或者render函数。提高性能complie 会优化render 函数，直接写没有优化过程。 组件会在每个生命周期触发事件，比如’hook:mounted’ 这种。尽量使用受控组件，优先选择函数组件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[filerun搭建和配置]]></title>
    <url>%2Farchives%2Fcecf9a65.html</url>
    <content type="text"><![CDATA[安装docker参考docker安装和配置 1234$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun$ sudo systemctl enable docker #开机启动$ sudo systemctl start docker # 打开服务 安装docker-compose123$ sudo curl -L https://download.fastgit.org/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose$ chmod u+x /usr/local/bin/docker-compose 修改docker-compose.yml 配置12345678910111213141516171819202122232425262728293031323334version: '2'services: db: image: mariadb:10.1 environment: MYSQL_ROOT_PASSWORD: root # 替换 MYSQL_USER: filerun # 替换 MYSQL_PASSWORD: filerun # 替换 MYSQL_DATABASE: filerun # 替换 volumes: - /root/filerun/db:/var/lib/mysql web: image: afian/filerun environment: FR_DB_HOST: db FR_DB_PORT: 3306 FR_DB_NAME: filerun # 替换 FR_DB_USER: filerun # 替换 FR_DB_PASS: filerun # 替换 APACHE_RUN_USER: www-data APACHE_RUN_USER_ID: 33 APACHE_RUN_GROUP: www-data APACHE_RUN_GROUP_ID: 33 depends_on: - db links: - db:db ports: - 80:80 volumes: - /root/filerun/html:/var/www/html # 挂载到宿主的目录 - /root/filerun/user-files:/user-files # 网盘文件，需要将CIFS挂载到此目录 挂载CIFS硬盘选择CIFS共享，不是NFS，NFS权限难搞。1$ mount -t cifs -o username=share,password=share,gid=tape,uid=33 //bijiben1.home/share /root/filerun/user-files 修改/etc/fstab 实现开机自动挂载1//bijiben1.home/share /root/filerun/user-files cifs username=share,password=share,gid=tape,uid=33 0 0 启动docker-compose docker-compose up -d 配置filerun 初始化用户密码是superuser/superuser 中文界面需要自行下载语言包上传。 语言包]]></content>
  </entry>
  <entry>
    <title><![CDATA[let-encrypt 域名证书申请]]></title>
    <url>%2Farchives%2F63bb46e5.html</url>
    <content type="text"><![CDATA[下载certbot-autowget https://dl.eff.org/certbot-auto chmod a+x ./certbot-auto 单域名证书申请新建nginx 配置1234567891011server &#123; listen 80; server_name cloud.jiaxuan.site; charset utf-8; root /opt/www/cloud.jiaxuan.site; index index.html index.htm; access_log /var/log/nginx/cloud.jiaxuan.site_access.log; error_log /var/log/nginx/cloud.jiaxuan.site_error.log;&#125; 申请单域名证书 ./certbot-auto certonly –email 1358925129@qq.com –domains cloud.jiaxuan.site]]></content>
  </entry>
  <entry>
    <title><![CDATA[hyper-v]]></title>
    <url>%2Farchives%2F320b54d3.html</url>
    <content type="text"><![CDATA[下载固件下载lede 虚拟机专用固件, 下载名称为generic-squashfs-combined-efi.vmdk的固件。 转盘使用转盘工具 StarWind Software V2V Image Converter。转盘工具可以转换.img .vmdk .vhd .vhdx格式，将固件转换成 vhdx 格式镜像，或者并且支持动态动态扩展大小的格式。 虚拟交换机配置配置 Wan新建虚拟交换机 =&gt; 外部网络 =&gt; 选择需要绑定的网卡 =&gt; 取消允许管理操作系统共享此网络适配器 如果取消允许管理操作系统共享此网络适配器，宿主机不能通过此网卡上网，必须要通过内部 lan =&gt; 软路由 =&gt; wan , 共享情况下是直接 =&gt; wan 如果需要多拨的，重复上述步骤 配置 lan-x新建虚拟交换机 =&gt; 外部网络 =&gt; 选择需要绑定的网卡 =&gt; 取消允许管理操作系统共享此网络适配器 重复上述步骤添加其余 lan 虚拟机配置 虚拟机存储位置指的是虚拟机相关的配置保存路径，不是磁盘路径 虚拟机代数，已知 lede 可以用二代；高恪，爱快二代显示镜像未找到，暂无方法，只能用第一代，第二代可以用 efi 镜像 第一代第二代磁盘使用不一致，第二代只能用 scsi 控制器添加硬盘驱动器。 硬盘驱动器第一代选择 IDE 控制器 1 虚拟磁盘选择转盘后的文件，使用文件前，先扩容到 2G。虚拟磁盘理解成一个隔离的真实磁盘 网卡配置按照 内部网络 =&gt; lan =&gt; wan 口的形式配置。外部网络需要在高级设置中启动 mac 地址欺骗 取消安全性检查 bios 启动顺序，使用硬盘优先 最好禁用检查点 启动设备使用 192.168.1.1 访问软路由管理界面。因为添加了内部 lan，否则只能设置外部 lan 网卡的网关到 192.168.1.1 直通教程 查看所有设备 Get-PnpDevice 获取 InstanceId Get-PnpDevice -FriendlyName “设备名称”| select InstanceId 禁用设备 Disable-PnpDevice -InstanceId “设备 InstanceId” 获取设备 LocationPaths Get-PnpDeviceProperty -InstanceId “设备 InstanceId” -KeyName DEVPKEY_Device_LocationPaths 通过 LocationPaths 下线设备 Dismount-VMHostAssignableDevice -Force -LocationPath “设备 LocationPaths” 查看被下线的设备 Get-VMHostAssignableDevice 通过 LocationPaths 添加设备到虚拟机 Add-VMAssignableDevice -VMName “虚拟机名称” -LocationPath “设备 LocationPaths” 可以直接通过 设备管理器 =&gt; 设备 =&gt; 设备详细信息查看 InstanceId 和 LocationPaths。LocationPaths=位置路径 InstanceId=设备实例路径 踩坑事项 外部网络不能并用，所以不能同一个外部网络不能分配到两个虚拟机上。 外部网络设备互斥，不能讲同一个设备分配到两个外部网络上。 出现 boot loader 加载失败，原因是没有禁用安全性启动 出现镜像未找到原因是，部分固件不支持二代虚拟机，需要用第一代的形式]]></content>
  </entry>
  <entry>
    <title><![CDATA[react和vue的生命周期]]></title>
    <url>%2Farchives%2F27ee65e3.html</url>
    <content type="text"><![CDATA[vue beforeCreate （ &lt;=初始化事件和生命周期） created （&lt;= prop 注入完成） beforeMount 编译 template 模板或者 render， 并收集依赖 mouted （挂载到 dom 上面） beforeUpdate =&gt; 不能在里面更新 data =&gt; 开始 diff render beforeDestory =&gt; 解除绑定，解除事件，销毁子组件。 destoryed =&gt; 删除完回调 react初始化阶段 defaultProp =&gt; prop initState componentWillMount render componentDidMount 运行阶段react 的变化需要自己手动更新，包括 props 和 state 的变化 props 变化通过 componentWillReceiveProps 获得， state 的变化通过 setState 方法来实现 均会触发 shouldComponentUpdate 钩子，如果钩子返回 false 表示不更新。然后会触发 componentWillUpdate 构造重新调用 render 函数， 渲染界面触发 componentDidUpdate 钩子， 销毁钩子 componentWillUnmount]]></content>
  </entry>
  <entry>
    <title><![CDATA[react开发采坑之路]]></title>
    <url>%2Farchives%2F5bca6e8e.html</url>
    <content type="text"><![CDATA[父组件给子组件设置 className 也需要通过 props 传递1&lt;div className=&#123;`$&#123;this.props.className&#125; otherClassName`&#125;&gt; jsx 属性命名原则React DOM 使用 camelCase（小驼峰命名）来定义属性的名称]]></content>
  </entry>
  <entry>
    <title><![CDATA[ts+react环境搭建]]></title>
    <url>%2Farchives%2F3a1fbb86.html</url>
    <content type="text"><![CDATA[package.json 初始化 npm init webpack 安装配置webpack 安装 npm i -D webpack webpack-cli 配置文件 新建config/base.config.js 1234567891011121314151617const path = require("path")module.exports = &#123; entry: &#123; main: path.resolve(__dirname, "../src/main.tsx") &#125;, output: &#123; path: path.resolve(__dirname, "../dist"), filename: "[name]-[hash].js" &#125;, module: &#123; rules: [ &#123; test: /\./ &#125; ] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习scss]]></title>
    <url>%2Farchives%2Ff800a64.html</url>
    <content type="text"><![CDATA[变量 用于定义属性值（不能是属性名） 美元符$开头，具有块级作用域 可以引用其他变量 $light-border: 1px solid \$ligth-color 变量中命令不区分 下划线和中横线，一般统一风格就行 属性嵌套12345678910111213141516div &#123; border: &#123; // 冒号隔开 width: 1px solid; left: 0; right: 0; &#125;&#125;div &#123; border: width: 1px solid &#123; // 冒号隔开 left: 0; right: 0; &#125;&#125; @import导入文件中定义的变量和混合器, 如果在这个文件中重新定义变量会影响后面所有的变量值 如果 a.scss 定义了\$a, b 引入 a.scss 并重写了， 后面再次引用 a.scss 的文件均是 b 重写过的 解决方案 使用默认值定义 \$width: 400px !default（这样不会覆盖） 使用嵌套引入，将引入的作为局部变量 div {@import “”} @mixin将片段 复用，理解成讲这个片段完整拷贝到@include 位置 @mixin name {xxxxx} 定义 @include name; 使用 可以使用 &amp; 可以包含块 可以带参数 @mixin name($arg1, $arg2), @include name(red,blue) 具名参数 @mixin name($arg1, $arg2), @include name({$arg2: blue, $arg1: red) 默认参数 @mixin name($arg1: red, $arg2: \$agr1) 可以对形参进行引用 @extends继承其他选择器的属性, 仅是那个选择器， 不会包括选择器子元素那些 继承在 BEM 中实战 123456789101112131415.nav &#123; background-color: steelblue; &amp;__container &#123; display: flex; justify-content: space-between; &#125; &amp;__item &#123; color: white; &amp;--active &#123; @extend .nav__item; border-bottom: 1px solid red; &#125; &#125;&#125;// 可以在html中直接 .nav__item--active 而不需要使用 .nav__item .nav__item--active 变量的数据类型修正之前变量的错误认识 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif，同时包含（空格 ，）时分解为子数组 maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) #{}插值语句可以避免运算，直接编译 &amp;的理解理解成一个特殊的变量 1234567891011@mixin does-parent-exist &#123; @if &amp; &#123; &amp;:hover &#123; color: red; &#125; &#125; @else &#123; a &#123; color: red; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960$light-theme: ( border-color: #eceeef, font-color: #323232, font-secondary: #c2c6d0, background-color: #fff, bg-title: #d3e6fb, bg-oddList: #f3f3f3, bg-listHover: #c5dffe);//深色主题$dark-theme: ( border-color: #000, font-color: #c2c6d0, font-secondary: #aaa, background-color: #131925, bg-title: #293248, bg-oddList: #171e2c, bg-listHover: #0d3a70);//定义映射集合$themes: ( light: $light-theme, dark: $dark-theme);@mixin themify($themes: $themes) &#123; @each $theme-name, $map in $themes &#123; .theme-#&#123;$theme-name&#125; &amp; &#123; $theme-map: () !global; @each $key, $value in $map &#123; $theme-map: map-merge( $theme-map, ( $key: $value ) ) !global; &#125; @content; $theme-map: null !global; &#125; &#125;&#125;@function themed($key) &#123; @return map-get($theme-map, $key);&#125;#app &#123; font-family: "Avenir", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; @include themify($themes) &#123; background: themed("background-color"); color: themed("font-color"); &#125;&#125; @each12@each $item, $index in $list &#123;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树学习]]></title>
    <url>%2Farchives%2Ffeb19258.html</url>
    <content type="text"><![CDATA[红黑树红黑树是二叉平衡树的一种，包括 5 种性质 根节点是黑色 节点颜色要么黑色，要么红色 每个叶子节点是黑子 任意节点到每个叶子节点的路径中包含的黑节点树 相等 每个红色节点的两个子节点的一定都是黑色（不能有两个连续的红节点） 红色树通过左旋，右旋，变色来实现平衡 左旋: 旋转节点的右节点变成父节点，选择节点变成右节点的左节点，右节点的左节点变成选择节点的右节点 右旋: 旋转节点的左节点变成父节点，旋转节点变成左节点的右节点，左节点的右节点变成旋转节点的左节点 插入流程]]></content>
  </entry>
  <entry>
    <title><![CDATA[三次握手四次挥手的奇怪理解]]></title>
    <url>%2Farchives%2F6c3aac24.html</url>
    <content type="text"><![CDATA[三次握手 向妹子招手(SYN=1, seq = X) 妹子回应(ACK=X+1) (此时你知道妹子回应你，你知道妹子的意思了) 并通知向你招手(seq=Y syn =1) 你回应妹子的招手(ACK=Y+1, seq = Z) (此时妹子也知道你的意思了) 四次挥手主动方: FIN=1 ACK=Z seq=X被动方: ACK=X+1 seq=Z被动方：FIN=1 ACK=X seq=Y;主动方：ACK=Y seq=X]]></content>
  </entry>
  <entry>
    <title><![CDATA[passport学习]]></title>
    <url>%2Farchives%2Fb4605e3d.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[开发中学习nest.js]]></title>
    <url>%2Farchives%2F65be6a2e.html</url>
    <content type="text"><![CDATA[新建配置服务安装依赖 1234npm i -S dotenvnpm i -D @types/dotenvnpm install -S @hapi/joinpm install -D @types/hapi__joi 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// config.service.tsimport * as dotenv from "dotenv"import * as fs from "fs"import * as Joi from "@hapi/joi"const configSchema = &#123;&#125;export type EnvConfig = Record&lt;string, string&gt;export class ConfigService &#123; private readonly envConfig: Record&lt;string, string&gt; // 配置的合并顺序 // .env.[type].local =&gt; .env.[type] =&gt; .env constructor(filePath?: string) &#123; if (filePath) &#123; this.envConfig = dotenv.parse(fs.readFileSync(filePath)) &#125; else &#123; // 读取默认配置 .env // 读取[type].env 配置 // 读取 local.[type].env配置 let defaultEnvConfig let typeEnvConfig = &#123;&#125; let localEnvConfig = &#123;&#125; try &#123; defaultEnvConfig = dotenv.parse(fs.readFileSync(".env")) typeEnvConfig = dotenv.parse( fs.readFileSync(`$&#123;process.env.NODE_ENV&#125;.env`) ) localEnvConfig = dotenv.parse( fs.readFileSync(`local.$&#123;process.env.NODE_ENV&#125;.env`) ) &#125; catch (err) &#123;&#125; if (!defaultEnvConfig) &#123; throw new Error("默认配置文件未找到!") &#125; this.envConfig = Object.assign( defaultEnvConfig, typeEnvConfig, localEnvConfig ) &#125; // todo // this.envConfig = this.validateConfig(this.envConfig); &#125; private validateConfig(envConfig: EnvConfig): EnvConfig &#123; const envVarSchema: Joi.ObjectSchema = Joi.object(configSchema) const &#123; error, value: validateEnvConfig &#125; = envVarSchema.validate(envConfig) if (error) &#123; throw new Error("配置文件验证出错") &#125; return validateEnvConfig &#125; get(key: string): string &#123; return this.envConfig[key] &#125;&#125;// config.module.tsimport &#123; Module &#125; from "@nestjs/common"import &#123; ConfigService &#125; from "./config.service"@Module(&#123; providers: [ &#123; provide: ConfigService, useValue: new ConfigService() &#125; ], exports: [ConfigService]&#125;)export class ConfigModule &#123;&#125;// .envPORT = 3000 注册到全局模块 mysql typeorm 集成安装依赖1npm i -S @nestjs/typeorm typeorm mysql ### mysql typeorm curd 集成1npm i --save @nestjsx/crud @nestjsx/crud-typeorm class-transformer class-validator 默认情况下 module 是单列的，意味着模块中 提供者也是单列认证12npm install --save @nestjs/passport passport passport-localnpm install --save-dev @types/passport-local JWT 功能12npm i -S @nestjs/jwt passport-jwtnpm i -S @types/passport-jwt 请求的执行顺序客户端请求 —&gt; 中间件 —&gt; 守卫 —&gt; 拦截器之前 —&gt; 管道 —&gt; 控制器处理并响应 —&gt; 拦截器之后 —&gt; 过滤器 重点：在示例给出了它们的写法，注意全局管道、守卫、过滤器和拦截器，只能 new，全局中间件是纯函数，全局管道、守卫、过滤器和拦截器，中间件都不能依赖注入。中间件模块注册也不能用 new，可以依赖注入。管道、守卫、过滤器和拦截器局部注册可以使用 new 和类名，除了管道以为其他都可以依赖注入。拦截器和守卫可以写成高阶方法来传参，达到定制目的 泛型中&amp;是啥意思&amp;指的是并集类型， | 指的是交集类型 别人的项目结构main.ts 入口main.hmr.ts 热更新入口app.service.ts APP 服务（选择）app.module.ts APP 模块（根模块，必须）app.controller.ts APP 控制器（选择）app.controller.spec.ts APP 控制器单元测试用例（选择）config 配置模块core 核心模块（申明过滤器、管道、拦截器、守卫、中间件、全局模块）feature 特性模块（主要业务模块）shared 共享模块（共享 mongodb、redis 封装服务、通用服务）tools 装饰器的集中写法1234567891011121314151617181920declare type ClassDecorator = &lt;TFunction extends Function&gt;( target: TFunction) =&gt; TFunction | voiddeclare type PropertyDecorator = ( target: Object, propertyKey: string | symbol) =&gt; voiddeclare type MethodDecorator = &lt;T&gt;( target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | voiddeclare type ParameterDecorator = ( target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; void 动态模块中 service 如何被注册到其他动态模块上1configModule 是个动态模块， 现在需要注册到typeormModule 上面, 最好的方式直接申明全局模块 采坑记录ConfigModule 不能读取 module 目录下的 json 配置文件开发代码都在 src 里，生成代码在 dist (打包自动编译)，typescript 打包只会编译 ts 到 dist 下，静态文件 public 和模板 views 不会移动，所以需要放到根目录下， 同理，配置 json 需要放在根目录下。 管道安装 npm i -S class-validator class-transformer 直接在 DTO 中装饰器定义 12345// create-cat.dto.tsexport default CreateCatDto &#123; @IsString() readonly name: string;&#125; 配置管道控制器中使用方法装饰器注入@UsePipes(new ValidationPipe({transform: true})) class-validator 装饰器大全@Length@contains(‘text’) entity 中定义类型和装饰器相比优先级低12345@CreateDateColumn(&#123; comment: '创建时间' &#125;)createdAt: Date@UpdateDateColumn(&#123; comment: '更新时间' &#125;)updatedAt: boolean // 这样也是可以的， 最后也会被解释成 datetime 类型的]]></content>
  </entry>
  <entry>
    <title><![CDATA[开发中学习typescript]]></title>
    <url>%2Farchives%2F71eabda7.html</url>
    <content type="text"><![CDATA[Record 类型将一个类型的所有属性值都映射到另一个类型上并创造一个新的类型 12345678910111213141516171819202122232425262728293031323334type Record&lt;k extends keyof any, T&gt; = &#123; [P in K]: T&#125;type petsGroup = "dog" | "cat" | "fish"interface IPetInfo &#123; name: string age: number&#125;type IPets = Record&lt;petsGroup, IPetInfo&gt;/** * IPets = &#123; * dog: IPetInfo * cat: IPetInfo * fish: IPetInfo * &#125; **/const animalsInfo: IPets = &#123; dog: &#123; name: "dogName", age: 2 &#125;, cat: &#123; name: "catName", age: 3 &#125;, fish: &#123; name: "fishName", age: 5 &#125;&#125; 联合类型一个值可以是几种类型之一如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 12345678910111213141516171819202122type unionType = number | stringinterface Bird &#123; fly() layEggs()&#125;interface Fish &#123; swim() layEggs()&#125;type Animal = Bird | Fishfunction getPet(): Animal &#123; if (xxx) &#123; return bird &#125; else &#123; return fish &#125;&#125;let pet = getPet()pet.fly() // error 类型保护与区分类型枚举枚举是 enum 关键定义的数据 123456789101112enum enumVar = &#123; x, y&#125;// enumVar.x = 0// enumVar[0] = 'x'enum enumVar = &#123; x = 'x' y = 'y'&#125;// enumVar.x = 'x'// enumVar['x'] = 'x' 高级类型Partial 123type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[p]&#125; Required 123type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P]&#125; ReadOnly 123type ReadOnly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P]&#125; Pick 123type Pink&lt;T, K extands keyof T&gt; = &#123; [P in K]: T[P]&#125; Record 123type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T&#125; Type 123interface Type&lt;T&gt; extends Function &#123; new (...arg: any): T // 表示T只能被new 调用， 不能直接调用&#125; 可以看到 type 是不能继承的，而且写法是赋值, interface 更像是申明 装饰器装饰器经计算后必须返回一个函数，就包括两种形式，一是直接返回函数，另一种是函数工厂 123456function decorator(target) &#123; return ...&#125;function decoratorFactory() &#123; return function(target) &#123;&#125;&#125; 装饰器会在 class 定义期间执行，无须等到 new 上至下依次对装饰器表达式求值(工厂函数会被执行)。 求值的结果会被当作函数，由下至上依次调用 123@g@f// g(f(x)) 类装饰器(constructor) 方法装饰器(constructor, key,) 属性装饰器 参数装饰器 ReadonlyArray&lt;&gt; 和 Array&lt;&gt;用于固定数组， 保证数组不能被修改或者被引用到另一个变量上 interface 理解是对结构的描述 12345678910111213141516171819interface Test &#123; test(): boolean // 描述对象的中函数 (a: string): boolean // 函数体的描述 new (test: string): someInstanceInterface // 对构造函数的额描述 [prop: number]: string // 索引签名&#125;interface Test1 extends Test // 接口是可继承的interface Counter &#123; // 混合类型，类比有属性的函数 (start: number): string; interval: number; reset(): void;&#125;interface SomeConstructor &#123; // 对构造器进行描述，描述构造器和构造器上面的静态属性 new (a: string): Counter test() propA: string&#125; 对象字面量传参问题对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误 1234567interface Config &#123; width?: string height?: string&#125;function test(config: Config): &#123; width: string &#125; &#123;&#125;test(&#123; height: 123, a: 123 &#125;) // a会报错 解决方法是提前为 额外的属性进行 定义 1234interface Config &#123; ... [prop: string]: string&#125; 函数的 interface 仅用于表达式声明中1234interface Func &#123; (arg1: string, arg2: number): void // 对函数体描述&#125;let func: Func = function(a: string, b: string): void &#123;&#125; // 参数名可以和接口不一致 可索引的类型仅包括数字索引和字符串索引， 数字索引的值必须是字符串索引的子类型，因为 JavaScript 中 a[100]===a[‘100’] 1234interface SomeInterface &#123; [prop: string]: number [prop: number]: string&#125; readOnly 的理解针对对象的属性名进行锁定，在索引签名中，可以对索引锁定readonly [prop: string]: string，对象不能在新增加属性 interface 的种类 对象类型 函数类型 class 类型 class interface 的写法123456789101112131415161718192021222324252627282930313233// ? PersonConstructor 是用来检查静态部分的interface PersonConstructor &#123; new (name: string, age: number) // ✔️ 这个是用来检查 constructor 的 typename: string // ✔️ 这个是用来检查静态属性 typename 的 logname(): void // ✔️ 这个用来检查静态方法 logname 的&#125;// ? PersonInterface 则是用来检查实例部分的interface PersonInterface &#123; // new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的 log(): void // : 这里定义了实例方法 log&#125;// class Person implements PersonInterface, PersonInterface &#123; ❌ 这样写是错误的const Person: PersonConstructor = class Person implements PersonInterface &#123; name: string age: number static typename = "Person type" // 这里定义了一个名为 typename 的静态属性 static logname() &#123; // 这里定义了一个名为 logname 的静态方法 console.log(this.typename) &#125; constructor(name: string, age: number) &#123; // constructor 也是静态方法 this.name = name this.age = age &#125; log() &#123; // log 是实例方法 console.log(this.name, this.age) &#125;&#125;const Person: PersonConstructor 接口可以继承 class当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 1interface someInterface extends someClass // 会继承class中所有的成员，实例属性和方法 对上一条的理解 当我们比较带有 private 或 protected 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则 就是说需要都是某一个基类的子类才行 受保护的构造函数对构造添加 protected，pretected 能被子类访问， private 不能被子类访问 类中的 readonly你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 typeof class返回一个 类的 静态成员信息和实例化对象的构造函数信息 （静态信息部分） 1234567891011121314151617181920class Greeter &#123; static standardGreeting = "Hello, there" greeting: string greet() &#123; if (this.greeting) &#123; return "Hello, " + this.greeting &#125; else &#123; return Greeter.standardGreeting &#125; &#125;&#125;var greeter1: Greetergreeter1 = new Greeter()alert(greeter1.greet())var greeterMaker: typeof Greeter = Greeter // Greeter 包括了静态信息部分和动态信息部分，所以满足typeofgreeterMaker.standardGreeting = "Hey there!"var greeter2: Greeter = new greeterMaker() // new greeterMaker返回动态信息，所以蛮子 Greeter， 是class 本生作为类型， 应该指的是示例部分alert(greeter2.greet()) 函数定义类型详情参见函数类型写法 在申明时给每个参数和返回标记处类型，并写函数体 123function a(arg1: string): booleanlet a: (arg1: string) =&gt; boolean = func 使用 type 3. 12345678910111213// 写法一function Func(a: string)=&gt;boolean;// 写法二let a: (b: string) =&gt; boolean = function(a: string) &#123; return true&#125;// 写法三interface Func1 &#123; (a: string): boolean&#125; TypeScript 里的每个函数参数都是必须的不能传 null 和 undefined interface 可以缩写， 直接在用的地方定义12345678interface SomeInterface &#123; (a: string): boolean&#125;let a: &#123; (a: string): boolean &#125; = function(a: string) &#123; // 这两种是等价的、 return false&#125; 泛型在定义中函数或者 interface 前面， 使用时在后面 12345678910111213141516// 泛型接口interface &#123; &lt;T&gt;(a: T): T&#125;// 泛型类class Add&lt;T&gt; &#123; value: Array[T] consturctor(value:T) &#123; this.value= [value] &#125;&#125;// 泛型约束interface With&lt;T, name&gt; &#123; name: T&#125;class Add&lt;T extends WithNumber&lt;string, "number"&gt;&gt; 泛型仅包括泛型接口和泛型类ts 需要区分运行时和编译时interface 和 const enum 就会在编译时被抹掉, enum 会被计算到生成的代码中， interface 仅作为检查。 12345678const enum EnumA &#123; A, B, C&#125;const test = [EnumA.A]// =&gt; 生成的js 代码const test = [0] typeof 变量可以推导出变量 A 的类型， 用于复制某一变量的类型 1type typeA = typeof varA]]></content>
  </entry>
  <entry>
    <title><![CDATA[严格模式]]></title>
    <url>%2Farchives%2F7108a574.html</url>
    <content type="text"><![CDATA[如何使用“use strict” 指令只允许出现在脚本或函数的开头。推荐在函数定义中开头放置 ‘use strict’ ，而不是在脚本开头 为什么要使用严格模式消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 严格模式体现了 Javascript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在严格模式中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在严格模式下将不能运行。掌握这些内容，有助于更细致深入地理解 Javascript，让你变成一个更好的程序员。 规则 this 的指向不再默认指向 全局 不允许删除变量、对象、函数 不能使用 8 进制， 转义字符串 不能使用 with； eval 是沙盒模式 保留一些关键字 禁止使用 arguments.callee 开发中如何规范使用 eslint 等静态代码检查工具，提前扫描。 常用套路123(function(window) &#123; "use strict"; // 防止合并代码代码导致严格模式失效的情况&#125;)(window);]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码盒子]]></title>
    <url>%2Farchives%2F2aa90bba.html</url>
    <content type="text"><![CDATA[Array.prototype.sort12;[3, 1, 4].sort((a, b) =&gt; a - b) // 1,3,4;[3, 1, 4].sort((a, b) =&gt; b - a) // 4,3,1 currying 柯里化函数123456789101112131415161718192021function currying(fn) &#123; // 通用的柯里化函数 var args = [] return function() &#123; if (arguments.length === 0) &#123; return fn.apply(this, args) &#125; else &#123; args.push(arguments) return arguments.callee &#125; &#125;&#125;var cost = currying(function() &#123; let result = 0 let len = arguments.length while (len--) &#123; result += arguments[len][0] &#125; return len&#125;) 惰性代码12345678910function isEnterKey(keyCode) &#123; var finalCode // 遥控器 确认按键 if (keyCode === 13 || keyCode === 14) &#123; finalCode = keyCode isEnterKey = function(keyCode) &#123; return finalCode === keyCode &#125; &#125;&#125; addEventListener 兼容优化写法1234567891011121314151617function addEvent(element, eventName, callback, options) &#123; if (element.addEventListener) &#123; // 重写函数 addEvent = function(element, eventName, callback, options) &#123; return element.addEventListener(eventName, callback, options) &#125; &#125; else if (element.attachEvent) &#123; addEvent = function(element, eventName, callback, options) &#123; element.attachEvent("on" + eventName, callback, options) &#125; &#125; else &#123; addEvent = function() &#123; element["on" + eventName] = callback &#125; &#125; addEvent(element, eventName, callback, options)&#125; 同理解绑函数也是同上 123456789function _off(el, event, fn) &#123; if (el.removeEventListener) &#123; el.removeEventListener(event, fn, false) &#125; else if (el.detachEvent) &#123; el.detachEvent("on" + event, fn.bind(el)) &#125; else &#123; el["on" + event] = null &#125;&#125; 为元素添加 on 和 trgger 方法12345678910// onElement.prototype.on = Element.prototype.addEventListenerNodeList.prototype.on = function(event, fn) &#123; Array.prototype.forEach.call(this, el =&gt; &#123; el.on(event, fn) &#125;) return this&#125;// trigger 使用代理的单例模式12345678910111213function Man() &#123;&#125;function createSingleClass(Fn) &#123; var instance return function newFn() &#123; if (this instanceof newFn) &#123; if (!instance) &#123; instance = new Fn(...arguments) &#125; return instance &#125; &#125;&#125; 翻转数字12345 =&gt; 54321 123456789function reverserNumber(number) &#123; var newNumber = 0 while (number &gt;= 1) &#123; var pop = number % 10 number = Math.floor(number / 10) newNumber = newNumber * 10 + pop &#125; return newNumber&#125; 找到第一个未重复的字符123456789function findFirstNumber(str) &#123; var i = -1, s while ((s = str[++i])) &#123; if (str.lastIndexOf(s) === i) &#123; return i &#125; &#125;&#125; 限制并发数并尽快的完成任务需要上传多张，要求尽快的上传完成，但是同时上传的格式为 m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function loadImg(url) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`$&#123;url&#125; is loaded`) resolve(url) &#125;, url * 100) &#125;)&#125;// promise 版本async function limitLoadAwait(urls, handler, limit) &#123; let sequence = [].concat(urls) let result = [] let promises = sequence.splice(0, limit).map(async (url, index) =&gt; &#123; result.push(await handler(url)) return index &#125;) await sequence.reduce(async (pCollect, url, currentIndex) =&gt; &#123; await pCollect let fastIndex = await Promise.race(promises) promises[fastIndex] = handler(url).then(res =&gt; &#123; result.push(res) return fastIndex &#125;) return promises &#125;, Promise.resolve()) await Promise.all(promises) return result&#125;// async await 版本async function limitLoadAwait(urls, handler, limit) &#123; let sequence = [].concat(urls) let result = [] let promises = sequence.splice(0, limit).map(async (url, index) =&gt; &#123; result.push(await handler(url)) return index &#125;) await sequence.reduce(async (pCollect, url, currentIndex) =&gt; &#123; await pCollect let fastIndex = await Promise.race(promises) promises[fastIndex] = handler(url).then(res =&gt; &#123; result.push(res) return fastIndex &#125;) return promises &#125;, Promise.resolve()) await Promise.all(promises) return result&#125; 巧妙结合 promise 和 reduce需要连续调用三个接口， 如果接口返回 true，继续调用下个接口。直到返回 false 或者到末尾 123456789101112131415161718192021function uploadImg(url) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(url) &#125;, 1000) &#125;)&#125;function uploadOneByOne(urls, handler) &#123; return urls.reduce((p, url) =&gt; &#123; return p.then(res =&gt; &#123; if (res) &#123; return handler(url) &#125; else &#123; return Promise.resolve(false) &#125; &#125;) &#125;, Promise.resolve(true))&#125;uploadOneByOne([true, true, true, false, true], uploadImg).then(console.log) 上述方法缺点是不能提前跳出 循环队列的思考和实现传统方式实现队列, 借助数组的 pop 和 unshift 方法 123456789function Queue() &#123; var _data = [] this.enQueue = function(value) &#123; _data.push(value) &#125; this.deQueue = function() &#123; return _data.unshift() &#125;&#125; 这种方法的弊端是每次入队出队都需要挪动整个队列。考虑引入头部指针和尾指针 123456789101112131415function Queue() &#123; var _data = [] var head = 0, tail = 0 this.enQueue = function(value) &#123; _data[head++] = value &#125; this.deQueue = function() &#123; if (_data.length === 0) &#123; return new Error("队列为空") &#125; else &#123; return _data[tail++] &#125; &#125;&#125; 这种策略空间换时间的方案，长时间使用后会溢出。所以有循环队列的方案 12345678910111213141516171819202122232425262728293031323334353637383940function Queue(initLength) &#123; var _data = new Array(initLength), tail = -1, head = -1, length = 0 dataLength = initLength this.enQueue = function(value) &#123; console.log(value, head, tail) if (length === dataLength) &#123; // 溢出 this.resetQueue() &#125; head = (head + 1) % dataLength _data[head] = value length++ &#125; this.deQueue = function() &#123; if (length === 0) &#123; throw new Error("empty") &#125; tail = (tail + 1) % dataLength length-- var result = _data[tail] _data[tail] = undefined return result &#125; this.resetQueue = function() &#123; // 扩容 dataLength = dataLength * 2 _data.length = dataLength // 如果 if (head &lt; tail) &#123; var headList = _data.splice(0, head + 1) _data.splice(tail, 0, ...headList) &#125; &#125; this.toString = function() &#123; console.log(_data) &#125;&#125; 动态的去扩大长度，还有 deQueue 应该动态减少长度 经典算法-洗牌算法12345678function shuffleArray(arr) &#123; var len = arr.length while (len--) &#123; var index = Math.floor(Math.random() * len) ;[arr[index], arr[len]] = [arr[len], arr[index]] &#125; return arr&#125; 位运算详解与或非异或 判断是否为奇数 n &amp; 1n | 0 === n n ^ n === 0 n ^ 0 === n~~表示向 0 取整 123function power(n) &#123; return 1 &lt;&lt; n&#125; n &gt;&gt;&gt; 0 的含义toNumber（不能转成 number 的变成 1） =&gt; 整数(~~n) =&gt; toUint32(负数 + 2 的 30 次方) GC 那些事儿 引用计数法. 对每个开辟的空间进行引用计数， 缺点是回带来内存溢出（循环引用的情况） 标记回收法：从根开始，递归的标记能访问的对象，标记完成后，去虽有未标记的对象进行回收 常见的内存泄露情况及处理方案 被遗忘的定时器 意外的全局变量(使用严格模式) 脱离 dom 的引用 闭包 脱离的 dom 的引用举例123456&lt;script&gt; let div = document.getElementById("fa") document.body.removeChild(div) // dom删除了 //div=null //切断div对div的引用 console.log(div)&lt;/script&gt; 一行代码实现 flat 函数123function flat(arr) &#123; return [].concat.apply([], arr)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端误区]]></title>
    <url>%2Farchives%2Fa2e48826.html</url>
    <content type="text"><![CDATA[引用值作为属性名情况先 toString 再 valueOf，使用独一无二的 key 使用 symbol 1234var a = &#123;&#125;var b = &#123;&#125;b[a] = 123b[a] === a["[object object]"] // true es6 中可以使用 Map 或者 weakMap constructor 误区constructor 是继承的构造函数的 prototype.constructor 属性。对象的__proto__属性指向函数的 prototype 属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Person(name) &#123; this.name = name&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;// 原型链继承function Woman(sex) &#123; this.sex = sex&#125;Woman.prototype = new Person("yan")let woman1 = new Woman("female")woman1.sayName() // yan/* --------------------------------- */// 构造函数function Man(name, sex) &#123; Person.call(this, name) this.sex = sex&#125;let man1 = new Man("xun", "male")man1.sayName() // error// 组合继承function Man(name, sex) &#123; Person.call(this, name) this.sex = sex&#125;Man.prototype = new Person() // 问题 Man.prototype.contructor === Person man1.contructor !== ManMan.prototype.contructor = Man // 修正 contructor, 修复instanceOflet man1 = new Man("xun", "fale")man1.sayName() // xun// 原型式继承function extend1(o) &#123; // 等价于 Object.create(o) let Fn = function() &#123;&#125; Fn.prototype = o return new Fn()&#125;// let const 和 var 绑定变量的区别区别是 let const 不会绑定在 window 上面。 var 会。 还有严格模式下函数中的 this 模式不会指向 window 1234let a = 1console.log(window.a) // undefinedvar b = 2console.log(window.b) // 2 this 永远指向最后调用它的那个对象a.b.c() c 中 this 指向的是 b，除了显示调用 this，其余都是 123456789101112function foo() &#123; console.log(this.a) return function() &#123; console.log(this.a) &#125;&#125;var obj = &#123; a: 1 &#125;var a = 2foo.call(obj)()// 1// 2 // 还是指向的window 函数作为参数可以这样写12345678910111213function test(fn) &#123; console.log(typeof fn)&#125;test( function() &#123; console.log(this.a) &#125;.call(&#123; a: 1 &#125;))// 输出// 1// undefined setTimeout 使用 undefined 作为参数的情况什么也不会发生 箭头函数 this 问题里面的 this 是由外层作用域来决定的，且指向函数定义时的 this 而非执行时。 ps 这句话是错误的， 应该从函数调用栈的观点来看待 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined 特殊例子 12345678910111213141516171819var obj = &#123; name: "obj", foo1: () =&gt; &#123; console.log(this.name) &#125;, foo2: function() &#123; console.log(this.name) return () =&gt; &#123; console.log(this.name) &#125; &#125;&#125;var name = "window"obj.foo2.call(&#123; name: 3 &#125;)()// 3// 3// 所以箭头函数的this 应该是执行时向父作用域的this看齐。 执行代码是应该是加上父作用域的执行情况 箭头函数的 this 不能通过 bind,apply,call 来更改，因为箭头函数自身没有 this，依赖的是父作用域中的 this，所以只能通过修改父作用域来修改 this。 更加的迷惑的行为 1234567891011121314151617181920212223var name = "window"var obj1 = &#123; name: "obj1", foo1: function() &#123; console.log(this.name) return () =&gt; &#123; console.log(this.name) &#125; &#125;, foo2: () =&gt; &#123; console.log(this.name) return function() &#123; console.log(this.name) &#125; &#125;&#125;var obj2 = &#123; name: "obj2"&#125;obj1.foo1.call(obj2)() // obj2 obj2obj1.foo1().call(obj2) // obj1 obj1 迷惑： 因为返回箭头函数，所以形成了闭包， 需要再次引用父作用域的thisobj1.foo2.call(obj2)() // window windowobj1.foo2().call(obj2) // window obj2 浏览器端 even loop 执行顺序 一开始整个脚本作为一个宏任务执行 执行中，同步代码直接执行，宏任务进入宏任务队列， 微任务进入本次宏任务的微任务队列 宏任务执行，微任务执行 UI 线程 渲染进行 web worker 进行 重复第二点 宏任务包括 script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering 微任务包括 process.nextTick promise.then MutationObserver 微任务会被添加到本次宏任务的末尾， 而宏任务会到下一次执行 promise 误区1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve("success") // 如果promise 没有 resolve .then 不会生效。 打印结果是 1 2 4 console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4)// 1 2 4 3 一开始进入宏队列 123456789101112console.log("1")setTimeout(() =&gt; &#123; // 放入下一个宏队列 console.log("2")&#125;)Promise.resolve().then(() =&gt; &#123; // 属于本次宏任务的微任务 console.log("3")&#125;)console.log("4")// 1 4 3 2 影响性能的可能因素 === 性能优于 !== if 语句都需要化简为=== while 循环性能优于 for 养成 while 循环的好习惯 while(len--) 不能使用++a, 性能比直接先++ 弱 charAt 和 直接字符串下标的区别charAt 是 es3 方法， 下标是 es5+方法。 charAt 在越界时返回 “”。字符串下标会让人误以为是可写的。 实际不能写。 promise 再次理解先上结论 Promise 的状态一经改变就不能再改变。 .then 和.catch 都会返回一个新的 Promise。catch 也会返回一个 resolve 状态的 Promise。如果 catch 没有抓到错， 也会返回一个新 promise，是调用 catch 的副本。同理上层有 reject 状态时，.then 也会一直返回一个 rejected 状态的副本 catch 不管被连接到哪里，都能捕获上层的错误。(见 3.2) 在 Promise 中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如 return 2 会被包装为 return Promise.resolve(2)。 Promise 的 .then 或者 .catch 可以被调用多次, 当如果 Promise 内部的状态一经改变，并且有了一个值，那么后续每次调用.then 或者.catch 的时候都会直接拿到该值。(见 3.5) .then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。(见 3.6) .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。(见 3.7) .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。(见 3.8) .then 方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为 catch 是.then 第二个参数的简便写法。(见 3.9) .finally 方法也是返回一个 Promise，他在 Promise 结束的时候，无论结果为 resolved 还是 rejected，都会执行里面的回调函数。 1234567// 证明第二点 每次调用.then .catch 都是返回的新的promise，状态由上一个promise的状态决定 。除了.then 一个 rejected状态的promise返回rejected状态的promise，其余都返回resolved状态var a = new promise(res =&gt; res(2))console.log(a) // promise resolved:2var b = a.then(console.log) // 2 promise resolved:2console.log(b === a) //falseconsole.log(a) // 同上个ab.then(console.log) // 2 promise resolved:2 证明 catch 返回的 promise 123456var a = Promise.reject(2) // reject: 2var b = a.catch(console.log) // 2 resolve： undifinedvar c = a.then(console.log)console.log(c) // reject: 2console.log(c === a) // falseconsole.log(b) // resolve： undifined 验证返回的 promise 副本是深拷贝还是浅拷贝。下面例子证明是”浅拷贝” 1234var a = &#123;&#125;var b = Promise.resolve(a);var c = = b.catch().then(res=&gt;console.log(res===a)) // trueconsole.log(b.catch() === b) // false promise .then .catch 参数非法的情况1234Promise.resolve(1) .then(2) // 只生成副本 .then(Promise.resolve(3)) // 只生成副本 .then(console.log) // 1 await 误区和正确阅读123456789101112async function async1() &#123; console.log("async1 start") await async2() console.log("async1 end")&#125;async function async2() &#123; console.log("async2")&#125;async1()console.log("start")// 之前错误的观点 start =&gt; async1 start" =&gt; async2 =&gt; async1 end// 实际运行结果 async1 start =&gt; async2 =&gt; start =&gt; async2 所以可以理解为 await 函数是当前函数.then 的一个语法糖。 然后 async 理解成一个 promise 的封装，所以 await 需要是 resolved 或者 rejected 状态的才行。 1234var a = new Promise(res =&gt; &#123; console.log&#125;)// pending 状态的。 奇特的 Promise resolve12345678910111213function a(fn) &#123; setTimeout(() =&gt; &#123; fn(123) console.log(1234) &#125;, 3000)&#125;var a = new Promise(res =&gt; &#123; a(res)&#125;)a.then(console.log)// 1234// 123 其实也不奇特，函数是引用传递 vue 中碰到浏览器死循环的问题，可以换个浏览器试试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[炫酷的CSS]]></title>
    <url>%2Farchives%2Fb29594f7.html</url>
    <content type="text"><![CDATA[若隐若现的发光字 background-image： line background-position: -500% =&gt; 500%]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端编码的故事]]></title>
    <url>%2Farchives%2F5f877c4e.html</url>
    <content type="text"><![CDATA[前言本文记录自己理解 ascii、unicode、utf-8 的含义和区别 ascii 编码ascii 编码使用一个字节代表一个字符，比如 A，二进制就是 0100 0001，十进制就是 65。目前来说 ascii 只有 128 个字符，所以第一位都统一为 0 unicode 编码ascii 编码只有 128 种状态，表示英语字符能够，但是表示其他国家语言字符时就不够用， 所以 unicode 编码就是在 ascii 上面扩展到多个字节。所以 unicode 编码将世界上所有符号包括在内。 unicode 只是定义的符号集，但是有些字符需要多字节存储。这个时候有个问题，如何区分多个独立字节表示的多个符号还是表示的一个符号。 有个解决方式都统一成 4 字节或者更高，这个也有个问题是，英语字符需要一个字节，补位会导致存储空间明显变大。 utf-8为了解决这个问题，出现 UTF-8、UTF-16、UTF-32 这些解决方案。大部分 unicode 字符都是 2 字节UTF-8 是一种可变长得编码方式， 可以使用 1-4 个字节来表示一个符号。编码规则只有两条 如果是单字节，第一位是 0，剩下用 unicode 编码补齐 如果字节是 n(n&gt;1), 前 n 位 1，n+1 位 0, 剩下的每个字节的前两位一律 10， 没有提及的位数使用 unicode 编码补全，]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法-递归优化]]></title>
    <url>%2Farchives%2F15477400.html</url>
    <content type="text"><![CDATA[前言本文简单记录算法学习中， 递归优化的一些方法 尾调用简单来说就说一个函数末尾返回另一个函数 123456789function a() &#123; ... return a() // 这种就属于尾调用&#125;function a() &#123; ... return n+b() // 这种不属于， 因为return 了其他计算式&#125; 尾调用优化当尾调用的不依赖当前函数时就是尾调用优化，调用栈尽可能少。 12345678910function a(n) &#123; ... function b(n) &#123; return n+x &#125; return b(n) // 这个是尾调用， 但不是尾调用优化。 // 因为执行 return 时 a依然在调用栈中&#125; 尾调用优化例子 保证是一个尾调用 保证调用栈尽可能的,return 的函数无副作用 123456789101112131415161718192021222324252627// 阶乘函数function f1(n) &#123; if (n === 1) return n; return n * f1(n - 1);&#125;function f2(n, total) &#123; if (n === 1) &#123; return total; &#125; return arguments.callee(n - 1, n * total);&#125;// 斐波拉契函数function fb1(n) &#123; if (n &lt;= 2) &#123; return 1; &#125; return arguments.callee(n - 2) + arguments.callee(n - 1);&#125;function fb2(n, a1, a2) &#123; if (n === 1) &#123; return a2; &#125; return arguments.callee(n - 1, a2, a1 + a2);&#125; 缓存值的方式优化通过把函数中值缓存起来，加快速度，这种仅限于结果集固定的情况 12345678910111213function memoizer(fn, cache = &#123;&#125;) &#123; return function(arg) &#123; if (!(arg in cache)) &#123; cache[arg] = fn(arg); &#125; return cache[arg]; &#125;;&#125;let fac = memoizer(function(n) &#123; if (n === 1) return n; return n * arguments.callce(n - 1);&#125;);fac(5); 尾调用转 栈 + 迭代的通用方案阮一峰书中看到的方案，可以对任意尾调用进行优化, 只能尾调用形式的递归 12345678910111213141516function tco(fn) &#123; var value; var active = false; var accumulated = []; return function() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = fn.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125; 缓存值优化方案12345678910111213141516171819function fb(n) &#123; if (n === 1 || n === 2) &#123; return 1; &#125; return fb(n - 1) + fb(n - 2);&#125;// 优化function optimizeRecursion(fn) &#123; var cache = &#123;&#125;; return function() &#123; var arg = Array.prototype.join.call(arguments, "."); if (arg in cache) &#123; return cache[arg]; &#125; return (cache[arg] = fn.apply(this, arguments)); &#125;;&#125; 斐波拉契数列 转迭代 动态规划123456789var climbStairs = function(n) &#123; const dp = []; dp[0] = 1; dp[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;; 递归时间复杂度和空间复杂度计算规则递归次数和计算函数的时间的乘积 二叉树的最大深度普通迭代方案 123456function maxDeep(node) &#123; if (node === null) &#123; return 0; &#125; return Math.max(maxDeep(node.left), maxDeep(node.right)) + 1;&#125; 总结 二叉树数组的关系 深度 log2 (length+1) i 行第一个元素和最后一个: 第一个 2^i - 1 最后一个 2^(i+1) - 2 ， i 从 0 开始 i 行元素个数 2 ^ i 左节点 2 * i + 1 右节点 2 * i + 2]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试题库篇（一）]]></title>
    <url>%2Farchives%2F234b714c.html</url>
    <content type="text"><![CDATA[123456789101112131415// 打印结果new Promise(resolve =&gt; &#123; console.log("1") resolve() console.log("2")&#125;).then(() =&gt; &#123; console.log("3")&#125;)setTimeout(() =&gt; &#123; console.log("4")&#125;)console.log("5")// 1 2 5 3 4// 注意 1 2 为什么在5前面 ， 2为什么会先打印 使用原生实现 ajax 发送请求123456789101112131415var ajax = &#123; get(url, cb, options) &#123; let xhr = new XMLHttpRequest() xhr.open("get", url, options.async || false) xhr.onreadystatechange = function() &#123; if ( xhr.readState === XMLHttpRequest.DONE &amp;&amp; (xhr.state === 200 || xhr.state === 304) ) &#123; cb(xhr.responseText) &#125; &#125; // 全部小写 &#125;, post(url, cb, options) &#123;&#125;&#125; 监听所有 ajax 请求123456789101112131415function ajaxEventTrigger(eventName) &#123; var ajaxEvent = new CustomEvent(eventName, &#123; detail: this &#125;) window.dispatchEvent(ajaxEvent)&#125;var OldXHR = window.XMLHttpRquestfunction newXHR() &#123; var realXHR = new OldXHR() realXHR.addEventListener( "readystatechange", function() &#123; ajaxEventTrigger.call(this, "readystatechange") &#125;, false )&#125; DOMContentLoaded 事件和 Load 事件的区别？当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。 Load 事件是当所有资源加载完成后触发的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[shell笔记]]></title>
    <url>%2Farchives%2Fc3711ab9.html</url>
    <content type="text"><![CDATA[截取字符串\${day_id:0:7} 0 起始位置 7 截取多少个 替换字符串${file/dir/path}：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt${file//dir/path}：将全部 dir 替换为 path：/path1/path2/path3/my.file.txt 一串的命令执行()和{}()和{}都是对一串的命令进行执行,但有所区别：相同点：()和{}都是把一串的命令放在括号里面,并且命令之间用;号隔开不同点()只是对一串命令重新开一个子 shell 进行执行,{}对一串命令在当前 shell 执行()最后一个命令可以不用分号,{}最后一个命令要用分号()里的第一个命令和左边括号不必有空格,{}的第一个命令和左括号之间必须要有一个空格()和{}中括号里面的某个命令的重定向只影响该命令,但括号外的重定向则影响到括号里的所有命令 时间处理函数${date -d &quot;-6 days 2019-01-22&quot; +%Y-%m-%d} // 2019-01-16]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack杂谈]]></title>
    <url>%2Farchives%2F14b2e6bb.html</url>
    <content type="text"><![CDATA[概述webpack通过打包commonjs(现在能识别esm)格式的js文件，可以打包出浏览器能过识别的commonjs语法的代码，本质上是模拟commonjs的加载过程。对于非commonjs的资源，需要通过loader变换成commonjs风格。 打包后的文件分析打包成单文件精简了部分代码。123456789101112131415161718192021222324252627282930313233343536373839// a.jsexports.a = 1;// index.jsconst a = require('./a.js').a;exports.b = a;(function(context) &#123; const self = context; const wrapJsContent = (content) =&gt; &#123; return (_webpack_require_, module, exports, modules) =&gt; eval(content) &#125; const modules = &#123; 'a.js': wrapJsContent(`exports.a = 1`), 'main.js': wrapJsContent(` const a = _webpack_require_('./a.js').a; exports.b = a; `), &#125; const _webpack_require_ = (moduleId) =&gt; &#123; if(_webpack_require_.cache[moduleId]) &#123; return _webpack_require_.cache[moduleId].exports &#125;; const module = &#123; exports: &#123;&#125;, cache: false &#125; _webpack_require_.cache[moduleId] = module; modules[moduleId](_webpack_require_, module, module.exports); return module.exports; &#125; _webpack_require_.cache = &#123;&#125; _webpack_require_('main.js')&#125;)(this) 打包成多个文件通过import() 语法可以实现打包多个文件，每个文件就是一个chunk。通过output.chunkFilename修改。在浏览器中，异步的加载chunk通过jsonp的方式执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445// a.jsexports.a = 1;// index.jsconst a = import('./a.js').then(module =&gt; &#123;console.log(module.a)&#125;);exports.b = a;// a.chunk.jsself[xxx].push([['a.js'], &#123; 'a.js': wrapJsContent(`exports.a = 1`)&#125;])// main.jsconst modules = &#123; 'main.js': wrapJsContent(` const a = _webpack_require_.e('./a.js').then(() =&gt; _webpack_require_('.a.js')).then(module =&gt; &#123;console.log(module.a)&#125;); exports.b = a; `),&#125;_webpack_require_.e = (id) =&gt; &#123; return _webpack_require_.l(id)&#125;_webpack_require_.l = (id) =&gt; &#123; const src = genUrl(id); const result = [null, null, null] const result[2] = new Promise((resolve, reject) =&gt; [resolve, reject] = resolve); const s = document.createElement('script'); s.src = src; appendScript(s); s.onload = () =&gt; &#123; removeScript(s) result[0](); &#125;;&#125;self[xxx].push = (chunks) =&gt; &#123; modules = &#123; ...modules, ...chunks &#125;&#125; 打包细节webpack不是单纯的对js文件封装，需要匹配出文件中的require、import等引用。所以如果js文件有错（使用了高阶语法或者宏形式），打包不能正常运行。对于这种情况可以采用loader的形式先编译成js能够识别的内容。 rollup打包同理，需要解决上面源码中的语法错误。 打包库通过设置output.libraryTarget, 将打包结果添加到不同的目标上 详情 libraryTarget = ‘var’，将结果添加到library 设置的值上 ] libraryTarget = ‘umd’, 将函数结果使用umd格式包装起来, commonjs绑定到exports[library]或者module.exports = result 对比rolluprollup是esm文件格式的打包，rollup是简单的import，不会模拟commonjs的加载逻辑，比较轻量级。 external 和 targettarget默认等于’web’，在import()时采用jsonp的方式加载代码，而且不能引用内置模块，比如require(‘path’); 可以设置 target: ‘node’，这样就能正确的require内置模块。 依然是采用的webpack_require的方式加载，只是在modules有点特别的写法。webpack通过这种方式可以灵活的设置加载模式，比如后面的externals。123"path": ((module) =&gt; &#123; module.exports = require("path");&#125;) 对于node_module时的模块，依旧当做外部模块，还是会打包到output中，对于这种，可以采用externals的方式。12345678910const lodash = require('lodash')&#123; externals: &#123; lodash: "commonjs lodash", // 会将 require('lodash') 变成 module.exports = require('lodash'); lodash: "lodash", // 会将 require('lodash') 变成 module.exports = lodash; lodash: ['commonjs lodash', 'a'], // 会将 require('lodash') 变成 module.exports = require('lodash').a; lodash: ['require111('a')', 'a'], // 会将 require('lodash') 变成 module.exports = require111('lodash').a; &#125;&#125; 这样不管是在web还是node中，均可以实现。这个相当于一个宏，可以实现一些骚操作，比如不是绑定的全局变量。 webpack中的path.resolve和path.joinpath.join是从左往右依次执行，上一次的结果成为下一次的相对路径或者绝对路径的开头，是一个简单的拼接。不一定能得出相对路径。path.resolve是完成一个绝对路径，每一次碰到绝对路径重新计算路径，最后能获得一个绝对路径。1234567const path = require('path');const path1 = path.join('/a', 'b') // /a/bconst path2 = path.join(__dirname, '/a', 'b') // D://xx/xx/a/b const path2 = path.resolve(__dirname, '/a', 'b') // D:/a/b 第二个开始会独立计算，const path2 = path.join('a', 'b') // D://xx/xx/a/b module，chunk和bundle的理解moudle很好理解，一个资源就是就是一个modulechunk包括入口chunk和子chunk，webpack内部执行时将moudule转换成chunkbundle是多个chunk的合并，最终打包的产物，默认情况下每个入门文件和代码分离（import）的部分会生成bundle，其余的可以通过插件来设置。 如何降低入口文件的大小 externals 通过splitChunk调整 TODO: 调整bundle文件大小 配置文件可以采用函数、promise和数组的形式配置，数组的形式会独立的执行多个打包程序。promise的场景可以用在统一管理配置服务的地方。 context可以指定entry和loader的相对路径，本身必须是相对路径。entry entry 支持多入口，webpack会独立的从多个入口打包，如果遇到多个入口共享的chunk，只会打包一次。 单个入口支持数组的形式，相当于新建一个文件文件里面是依次rerquire 数组，同时数组最后一个require的内容作为导出 1234567891011121314&#123; entry: &#123; main: ['./a', '.b'] &#125;&#125;// 相当于新建一个文件temp.jsrequire('./a');module.exports = require('./b');&#123; entry: &#123; main: './temp.js' &#125;&#125; 最完整的配置方式是通过对象，output.filename中的name是entry的key(默认是main)，可以通过filename来修改。 12345678&#123; entry: &#123; 'main': &#123; import: ['./index.js'], filename: 'test' &#125; &#125;&#125; 可以通过dependOn来指明依赖，实现公共chunk的提取。 12345678910&#123; entry: &#123; 'lodash11': 'lodash' 'main': &#123; import: ['./index.js'], filename: 'test', dependOn: ['lodash11'] &#125; &#125;&#125; 最终生成bundle中 main实际的代码是 self[‘xxx’].push([‘main.js’, modules]),相当于import()分离的代码。lodash包含了主要代码。实际上不推荐这样做，lodash没办法复用。 output path必须是绝对路径，使用path.resolve或者path.join(__dirname, xxx) filename 用于配置入口chunk打包后的bundle, chunkFilename是其他chunk打包的bundlecontenthash、fullhash和chunkhashTODO: chunkFormat 和 chunkLoadingchunkFormat用于制定chunk的格式，’array-push’ | ‘commonjs’ | ‘module’ chunkLoading 表示入口main如何加载chunk module_require.f.xxx ‘jsonp’ | ‘import-scripts’ | ‘require’ | ‘async-node’ | ‘import’ 默认情况下和target有关，可以用于跨项目共享chunk上面，比如chunkFormat只要和chunkloading能匹配，项目中就可以引用其他项目的chunk 目前支持在每个entry中配置output.library1234567891011&#123; entry: &#123; main: &#123; import: '.index.js', library: &#123; name: 'xxx', type: 'umd', &#125; &#125; &#125;&#125; asset和publicPath以及base问题。 通过copy-webpack-plugin实现静态资源到dist目录的拷贝，所有的静态资源必须使用相对路劲。 publicPath用于chunk和部分其他资源的路劲前缀，请总是以\/结尾 base 定义了页面中所有资源相对路劲，如果未设置默认是当前文档（路径的最后一个\/前的目录）。同时也支持相对路径，相对时当前文档 支持动态publicPath，_webpack_publicpath__ 代码中设置即可。这些webpack内置变量都是宏，会在编译阶段替换。 部署子目录时需要涉及上面的问题，一般按照下面流程调整。 修改publicPath调整webpack资源，最终的请求地址是简单拼接，所以一定\/结尾，调整成./ 静态资源全部修改成相对路径，使用copy-webpack-plugin 拷贝到dist目录下 修改index.html 中的base，调整成子目录绝对路劲(history模式下) ,如果是hash模式不需要调整，只需要在浏览器路径后补齐\/ 针对开发环境asset异常的问题按照下面解决TODO: module.noParse对于externals的补充对于不需要打包的外部模块可以采用noParse的方式，webpack会忽略对当前文件的引用。这个行为发生在externals之前，用在node环境比较多 module.rules配置webpack对资源的处理，通过use一个一个loader，返回一个webpack能够识别的js文件。 resolve 别名和编辑器快速引用resolve.alias配置别名，需要配置绝对路径，使用别名相当于path.resolve(@xxx, ‘somepath’);搭配上jsconfig.json 或则 tsconfig.json 中的compilerOptions123456789&#123; "compilerOptions": &#123; "module": "commonjs esnext", // 使用import还是require实现自动补全 "baseUrl": "", // 指定后面的路径的基路径 "paths": &#123; "@": ["./src"] &#125; &#125;&#125; TODO:vscode中自动补全时，通过配置xx总是补全绝对路劲 webpack如何查找module resolve.extensions: array 省略后缀 resolve.mainFiles: ‘index’ 针对目录默认加载的文件 resolve.modules: [“node_modules”] 对于无路径的引用，到node_modules下查找目录。 查找目录后根据resolve.mainFields: array 配置，查询package.json对应字段中的入口文件。默认情况下, target: web是[browser, module, main]。target：node [module, main]，如果没有配置默认当做目录处理。 可以查看lodash的包 package.json 中的main browser和modulemain 对应 commonjs。module对应 esm。browser 对应 umd 规范。 优化篇优化检查点 reslove 优化，提高查找效率速度 extensions alias modules mainFields mainFiles resloveLoader noParse 跳过部分模块中的解析（模块本身还是会解析） 资源cdn化，在cdn过程提前查询dns域名。 external分离第三方资源，通过htmlWepbackPlugin引入 动态导入，分离模块。 bebael-loader使用缓存 配置webpack缓存 oneof loader提高loader的查找性能 optimization 常用字段12345678910&#123; optimization: &#123; chunkIds: 'named deterministic' // 调整的是chunkFilename中[name]字段 named 使用文件名 deterministic 使用有缓存的数字编码，比如刚开始是0.js 1.js 2.js 如果删除了1.js ，下次打包会生成0.js 2.js，不会生成1.js。利于长期缓存 moduleIds: 'natural size total-size', //生成bundle中modules moduleId。 同上 natural 从自然数开始 size尽可能让初始包小 total-size 尽可能让总包小。 flagIncludedChunks: boolean, // prod 默认开启，表示是否不重复加载子chunk，如果a,b 都同时引用了c c会打包两次 mergeDuplicateChunks: true, // 是否合并相同的chunk，在多个入口同时引用了相同的文件就会被合并。 minimize: true, // 是否开启内置压缩，生产默认开启，开发默认关闭 minimizer: xxx // 自定义压缩工具 &#125;&#125; minimizer TerserPlugin 插件使用TODO: dev server1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; devServer: &#123; client: &#123; overlay: true, &#123; errors: true, warnings: false &#125;, // 是否需要在浏览器全屏展示错误警告信息 progress: true, // 是否展示编译的进度条信息 reconnect: true number // 是否自动重连 compress: true, // 启用gzip压缩 &#125;, historyApiFallback: true // 启用history api headers: &#123; // 添加自定义响应头，可用于直接鉴权 "X-xx-x": 'something' &#125;, host: '0.0.0.0' // 配置本地监听的host，一般配置local-ip port: 8088 // 本地监听端口号 hot: true // 是否启动热刷新，开启后会默认打开插件 open: ['/xxx'] true // 自动打开新页面，详情参考open库 open: &#123; // open 包 target: ['first.html', 'http://localhost:8080/second.html'], app: &#123; name: 'google-chrome', arguments: ['--incognito', '--new-window'], &#125;, &#125; proxy: &#123; // http-proxy-middleware '/api': &#123; target: 'xcxx:xxxx', pathRewrite: &#123; '^/api': '' &#125;, secure: false, // 关闭https的安全校验，用于后端的https自签名情况 bypass: () =&gt; boolean // 判断是否转发 &#125; &#125;, // 开发环境配置静态目录 static: &#123; directory: ['./src/assets'], publicPath: './xxx' &#125;, devMiddleware: &#123; // webpack-dev-middleware 用于配置devServer在哪儿查找资源 &#125; &#125;&#125; devServer中的publicPath 和 output中的publicPath的区别devServer中会先将代码打包到内存中，和打包到dist一样，会按照output.publicPath组织chunk和资源的加载。 output.publicPath 仅用于chunk和资源加载的，是一个简单的拼接，不会影响入口chunk。比如设置了output.publicPath: ‘./xx’,入口chunk的地址还是localhost:3000/main.js，但是子chunk的加载地址会变成./xx/chunk.js devServer 中的publicPath是用于生成子目录服务器，会影响所有资源的加载。包括入口chunk。默认情况下这个值和output中的一致，所有output中不要设置相对路劲。output.publicPath: ./a devMiddleware.publicPath: /b 入口chunk的地址是host:3000/b/main.js 加载的资源地址变成了 host:3000/b/a/chunk.js，显而易见的main.js 和chunk.js 不在同济目录下。 这个时候有种方法，是把子chunk打包到目录下。 在CICD中如何利用缓存加快打包进度TODO: 监听文件变动watch 和 watchOption在开发服务器中默认开启，build默认是关闭。 watchOption控制监听的方式、重新构建间隔和目录。会监听已经解析的资源变更。如果新增了一个文件，只需要引用一次就可以实现监听 模块联邦模块联邦提供了加载其他模块的能力，可以用于跨项目共享chunk。 本地模块指的是入口文件构建的模块，远程模块是MF定义出的。相当于共享配置的两个入口文件。 每个构建都是一个容器，容器可以加载远程模块。 远程模块需要使用异步的方式加载。 远程模块也可以作为容器加载其他远程模块。 远程模块中，因为publicPath是简单的拼接，如果设置了publicPath会出现加载宿主域的问题。需要将publicPath设置为auto或则动态设置。 远程模块至少会生成runtime、remote和module 3种chunk文件 12345678910111213141516const MF = webpack.container.ModuleFederationPlugin;module.exports = &#123; plugins: [ // 打包逻辑 runtime -&gt; remote.js -&gt; ./componentA new MF(&#123; name: 'remote', // 远程模块名称 filename: 'remote.js', // 生成的远程模块文件，用于宿主容器加载 runtime: 'remote.runtime.js', // 默认情况下runtime文件生成在filename 定义的文件中，可以单独抽离出来。 exposes: [&#123; './componentA': './src/componentA.vue' // 需要使用./前缀，host 通过 import('remote/componentA') '.': 'src/componentA/index.js' // import('remote') &#125;] &#125;) ]&#125; 动态设置publicPath因为runtime.js 需要加载remote.js和module.js 所以需要提前设置publicPath。MF在打包时如果container chunk和入口chunk同名，会合并。所以需要将name设置为一个入口name相同。1234567891011121314151617module.exports = &#123; entry: &#123; main: './index.js', remote: './public-path.js' // 在入口文件中配置动态的js。 &#125;, plugins: [ new MF(&#123; name: 'remote', // 远程模块名称 filename: 'remote.js', // 生成的远程模块文件，用于宿主容器加载 runtime: 'remote.runtime.js', // 默认情况下runtime文件生成在filename 定义的文件中，可以单独抽离出来。 exposes: [&#123; './componentA': './src/componentA.vue' '.': 'src/componentA/index.js' &#125;] &#125;) ]&#125; 动态加载远程模块正常情况下远程模块是在webpack配置中制定的，可以手动实现远程模块的加载。123456const loadModule = async (url, containerName, module) =&gt; &#123; await loadScript(url); // 加载remoteEntry js 脚本。 const container = window[containerName]; // 默认情况下remoteEntry 按照var 导出。 通过window containerName 可以获取到container。 const factory = await container.get(module) // get方法是一个异步的方法，获取的是modules里的value。 return factory() // 执行一次相当于执行了module文件。&#125; 上面代码不够完整，缺少共享模块的加载以及重复引用下module不是单例问题。123456789101112const remoteModuleCache = new set();let loadModule = async (url, containerName, module) =&gt; &#123; if(hasCache(container, module)) &#123; return getCache() &#125; await loadScript(url); // 加载remoteEntry js 脚本 await __webpack_init_sharing__('default') // 全局初始化共享模块 const container = window[containerName]; // 默认情况下remoteEntry library 按照var 导出。 通过window containerName 可以获取到container。 container.init(__webpack_share_scoped__.default) const factory = await container.get(module) // get方法是一个异步的方法，获取的是modules里的value。 return factory() // 执行一次相当于执行了module文件。&#125; 远程模块加载流程 webpack_modules 声明了remoteEntry入口文件。 通过webpack_require.e 调用 webpackrequire.f.remote 中间件加载入口js文件。 入口js文件加载好后，在全局暴露remote变量 host中加载远程模块的module会固定编译成 一个chunkid， host 会调用remote去获取这个chunkId对应的js文件， 加载完成后回调在remote中，然后host执行这个remote中的回调函数得到module。 远程模块踩坑 远程模块的异步chunk加载方式务必不要和host应用雷同，会出现覆盖host modules问题。大坑，使用 output.chunkLoadingGlobal、output.uniquename修改 目前自动加载远程模块的方式仅默认方式能生效，即把远程模块绑定到全局变量上。其他的方式均需要自行加载远程模块 webpack宏变量webpack_xxx_xx 格式的都是webpack的宏，会在编译阶段替换成内置的命令，可以嚣张点直接写内置的命令或者使用DefinePlugin 插件来定义。 loaderloader用于将webpack不能直接识别的内容转换，一般来说需要返回一个具有导出对象的文件。可以用处理图片、代码宏等操作。 style-loader、css-loader、postcss-loader、sass-loader和less-loader样式处理按照如下loader顺序执行 vue-loader 根据style中lang将style的内容单独使用对应的loader处理。 sass-loader和less-loader调用sass或者less编译成css。 postcss-loader对编译后的css进行处理，添加autofixprefix、修复部分错误等 css-loader解决css文件中的@import和url() style-loader实现一个js，将css代码添加到style标签中。 重点关注的地方：各种样式、资源引用的处理细节。 vue-loader不会对资源进行任何处理，@import ‘../style/a.scss’。相对的是vue文件本身，简单理解vue-loader会将vue文件拆分成两个文件,一个js文件，一个scss文件。 sass-loader扩展了@import功能(同js require一致的查找规则)，添加~前缀可以从node_module中查找（可以不添加，默认相对路径，相对路径无法查询自动使用node_modules）。在js中被直接引用的scss文件视为入口文件，scss中@import文件的资源相对路径都参考这个（见后文例子）。 除此之外sass-loader不会处理代码中的url()。sass处理@import时，不会处理.css后缀、http开头、@import url() 格式。针对这个问题，可以使用resolve-url-loader 前置处理。 less-loader 大致同上。less也实现了webpackImport功能。less还扩展了一些，比如只引用不输出等。具体参考文档。不过less-loader 处理url，不需要使用resolve-url-loader css-loader中@import始终应该被处理，对于url() 按照webpackImport方式处理，不过别名使用的是~,node_modules使用的~moudle,配置上options.url,可以动态的判断是否需要处理url资源123456789// src/style/test/test.scss@import 'a'; // ./a.scss =&gt; node_modules/a.scss@import '@src/a'; // /src/a.scss.test &#123; background: url('xx.jpeg'); // src/style/test/xx.jpeg background: url('~@src/assets/img/xx.jpeg'); // src/assets/img/xx.jpegjpeg background: url('./public/xx.jpeg'); // ./public/xx.jpeg // 这个不会经过webpack处理，其余的都会 background: url('/src/xx.jpeg'); // /src/xx.jpeg'&#125; 图片、字体等资源的处理。webpack5中使用module.rules.type取代了file-loader, url-loader 和 raw-loader。 asset/resource 代替 raw-loader asset/inline 代替 url-loader asset/source 代替 file-loader asset 代替了url-loader 并自动选择data-url还是url 默认情况下总是会使用asset/source，并且以8KB为分界线，通过module.rules.parser.dataUrlCondition调整。在output.assetModuleFilename定义输出的文件名称。 默认情况下webapck总是会对资源asset处理, 如果需要自己配置loader，需要加上type: ‘javascript/auto’，否则资源会被打包两次。 loader的加载方式和加载顺序当use: [&#39;style-loader&#39;, &#39;css-loader&#39;]时，我们直到loader总是从后往前执行，css-loader 传递给style-loader的总是js代码，style-loader如何处理js代码将css提取出。 有如下两种require(‘xxx.css’) 和 require(‘style-loader!css-loader!xxx.css’)。前面是根据在rules中的规则进行解析，后者是直接在require时指明loader的处理方式，再和和rules指定的，以!作为间隔符。 loader分为下面四种加载，通过enforce可以制定loader应用时机。 pre 前置加载 normal 默认值，正常require(使用当前流程) post 后置加载 inline 上文的行内形式 加载流程 pre -&gt; inline -&gt; normal -&gt; post12345678910111213141516171819202122232425module.exports = &#123; module: &#123; rules: [ &#123; test: /\.less/, use: [ &#123; loader: 'pre-loader', enforce: 'pre' &#125;, &#123; loader: ['post-loader'], enforce: 'post' &#125;, &#123; loader: ['normal-loaderA', 'normal-loaderB'], // enforce: 'normal' &#125; ] &#125; ] &#125;&#125;require('inline-loader!xxx.less') // use: ['pre-loader', 'inline-loader', 'normal-loaderA', 'normal-loaderB', 'post-loader'] 在inline前面添加不同修饰符可以定义不同的行为 ! 禁用normal loader !! 禁用所有loader pre normal post -! 禁用pre normal12require('!inline-loader!xxx.less') // use: ['pre-loader', 'inline-loader', 'post-loader']require('-!inline-loader!xxx.less') // use: ['inline-loader', 'normal-loaderA', 'normal-loaderB', 'post-loader'] 在确定好顺序后开始加载loaderloader区分为pitch阶段和normal，pitch阶段相当于时间捕获，从前到后执行，具有break功能。pitch中能够获取后续loader链。pitch 如果有返回会直接跳到前一个loader的normal阶段。123require('inline-loader!xxx.less') 'pre-loader', 'inline-loader', 'normal-loaderA', 'normal-loaderB', 'post-loader' =&gt; 'post-loader', 'normal-loaderB', 'normal-loaderA', 'inline-loader', 'pre-loader', require('-!inline-loader!xxx.less') 'inline-loader' =&gt; 'inline-loader' 了解加载顺序后，分析一下style-loader 和 css-loader的执行流程。less-loader对less文件处理后会返回css内容，非js模块css-loader处理css中的url和import 返回js模块(为什么)，js导出一个对象，执行toString可以得到原始的css文件。style-loader 只接受css内容 ，不支持js模块包裹的css。 style-loader 通过pitch的方式在运行时获取了css-loader 返回的moudle，通过隐式调用toString拿到原始的css文本添加到style中。12345678910// css-loadermodule.exports = &#123; toString() &#123; return ` .test &#123; color: red &#125; ` &#125;&#125; 正常情况下css-loader 返回给下一级是包含module.exports语句的文本，需要动态执行才能获取到原始的文本，可以实现一个css-loader和style-loader的适配器123456789101112// css-style-loader.jsmodule.exports = (content) =&gt; &#123; const evalFn = () =&gt; &#123; const module = &#123; exports: &#123;&#125;&#125;; eval(content); return module &#125; const cssText = evalFn(content).toString(); const style = document.createElement('style') style.innerText = cssText; document.body.appendChild(style)&#125; 杂项提效scss中如何在组件使用scss变量 全局变量定义为引用文件，防止引入时重复编译 scss-loader中对每一个sass入口文件添加对全局变量的引用。 sass中全局变量、extend、mixin都应该使用引用并导出。 1$colors: ( blue: #007dc6, blue-hover: #3da1e0 ); @mixin colorSet($colorName) &#123; color: map-get($colors, $colorName); &amp;:hover &#123; color: map-get($colors, $colorName#&#123;-hover&#125;); &#125; &#125; a &#123; @include colorSet(blue); &#125;产出如下：a &#123; color:#007dc6 &#125; a:hover &#123; color:#3da1e0 &#125;动态创建：@function addColorSet($colorName, $colorValue, $colorHoverValue: null) &#123; $colorHoverValue: if($colorHoverValue == null, darken( $colorValue, 10% ), $colorHoverValue); $colors: map-merge($colors, ( $colorName: $colorValue, $colorName#&#123;-hover&#125;: $colorHoverValue )); @return $colors; &#125; @each $color in blue, red &#123; @if not map-has-key($colors, $color) &#123; $colors: addColorSet($color, $color); &#125; a &#123; &amp;.#&#123;$color&#125; &#123; @include colorSet($color); &#125; &amp;nbsp;&amp;nbsp;&#125; &#125;产出如下：a.blue&amp;nbsp;&#123;&amp;nbsp;color:&amp;nbsp;#007dc6;&amp;nbsp;&#125; a.blue:hover&amp;nbsp;&#123;&amp;nbsp;color:&amp;nbsp;#3da1e0;&amp;nbsp;&#125; a.red&amp;nbsp;&#123;&amp;nbsp;color:&amp;nbsp;red;&amp;nbsp;&#125; a.red:hover&amp;nbsp;&#123;&amp;nbsp;color:&amp;nbsp;#cc0000;&amp;nbsp;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器追踪]]></title>
    <url>%2Farchives%2Fbfdd4d38.html</url>
    <content type="text"><![CDATA[前言本文适用同机器同浏览器追踪。分为 5 个大指标：browser_fp canvas_fp webgl_fp audio_fp webrtc。采集指标需要具有稳定性， 即多次采集值不会变 场景 匿名用户系统 未登录的用户 广告 ID 浏览器指纹webdriver cpuClass deviceMemory UserAgent platform123456return navigator.webdriver; // 这个可以检测 自动化测试工具（puppeteer, selenium）return navigator.cpuClass; // cpu等级return navigator.deviceMemory; // 设备内存大小 8return navigator.UserAgent; // 浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言) 渲染引擎标识 版本信息return navigator.hardwareConcurrencyKey; // cpu核心数 4核几线程return navigator.platform; // Win32 languagenavigator 里面有两个关于 language 的 一个 language，一个是 languages, language 是不是和 languages 相等，来判断用户是不是改过语言，同时需要结合 ip 时区归属地来标记异常用户 12345678var getLanguage = function() &#123; return ( navigator.language || navigator.userLanguage || navigator.browserLanguage || navigator.systemLanguage );&#125;; colorDepth screenResolution devicePixelRatio1234return window.screen.colorDepth; // 颜色深度return [window.screen.width, window.screen.height]; // 设备分辨率return [window.screen.availHeight, window.screen.availWidth]; // 可用分辨率return window.devicePixelRatio; // 视网膜屏比例 timezone 时区判断 ip 是否和时区一致 123var getTimezone = function() &#123; return new window.Intl.DateTimeFormat().resolvedOptions().timeZone;&#125;; timezoneOffset 时区偏移和上面类似 123var getTimezoneOffset = function() &#123; return new Date().getTimezoneOffset();&#125;; sessionStorage localStorage IndexedDB openDatabase1234return !!window.localStorage;return !!window.sessionStorage;return !!window.indexedDB;return !!window.openDatabase; doNotTrack 浏览器设置的不追踪标记1return navigator.doNotTrack || navigator.msDoNotTrac || window.doNotTrack; plugins 浏览器插件1234567891011121314151617181920212223242526272829navigator.plugins; // 非IE// IEvar names = [ "AcroPDF.PDF", // Adobe PDF reader 7+ "Adodb.Stream", "AgControl.AgControl", // Silverlight "DevalVRXCtrl.DevalVRXCtrl.1", "MacromediaFlashPaper.MacromediaFlashPaper", "Msxml2.DOMDocument", "Msxml2.XMLHTTP", "PDF.PdfCtrl", // Adobe PDF reader 6 and earlier, brrr "QuickTime.QuickTime", // QuickTime "QuickTimeCheckObject.QuickTimeCheck.1", "RealPlayer", "RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)", "RealVideo.RealVideo(tm) ActiveX Control (32-bit)", "Scripting.Dictionary", "SWCtl.SWCtl", // ShockWave player "Shell.UIHelper", "ShockwaveFlash.ShockwaveFlash", // flash plugin "Skype.Detection", "TDCCtl.TDCCtl", "WMPlayer.OCX", // Windows media player "rmocx.RealPlayer G2 Control", "rmocx.RealPlayer G2 Control.1"];try &#123; new new window.ActiveXObject(names[i])(); // 通过是否能够成功构造对象来区分&#125; devices1navigator.mediaDevices.enumerateDevices().then(); canvas_fp画布指纹原理是通过 canvas 绘制图片，绘制的图片由于不同设备， 不同浏览器绘制的图片 base64 不相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 关于canvas的几个指标var result = [];var canvas = document.createElement("canvas");canvas.width = 2000;canvas.height = 200;canvas.style.display = "inline";var ctx = canvas.getContext("2d");ctx.rect(0, 0, 10, 10);ctx.rect(2, 2, 6, 6);result.push(&#123; name: "canvas winding", value: ctx.isPointInPath(5, 5, "evenodd") === false&#125;);ctx.textBaseline = "alphabetic";ctx.fillStyle = "#f60";ctx.fillRect(126, 1, 62, 20);ctx.fillStyle = "#069";ctx.font = "11pt no-real-font-123";ctx.fillStyle = "rgba(102, 204, 0 ,0.2)";ctx.fileText("QWEtyioio asdgh sad, ~! \ud83d\ude03", 4, 45);ctx.fileText("QWEtyioio asdgh sad, ~! \ud83d\ude03", 16, 56);ctx.globalCompositeOperation = "multiply";ctx.fillStyle = "rgba(255, 0, 255)";ctx.beginPath();ctx.arc(50, 50, 50, 0, Math.PI * 2, true);ctx.closePath();ctx.fill();ctx.fillStyle = "rgb(0,255,255)";ctx.beginPath();ctx.arc(100, 50, 50, 0, Math.PI * 2, true);ctx.closePath();ctx.fill();ctx.fillStyle = "rgb(255,255,0)";ctx.beginPath();ctx.arc(75, 100, 50, 0, Math.PI * 2, true);ctx.closePath();ctx.fill();ctx.fillStyle = "rgb(255,0,255)";// canvas winding// http://blogs.adobe.com/webplatform/2013/01/30/winding-rules-in-canvas/// http://jsfiddle.net/NDYV8/19/ctx.arc(75, 75, 75, 0, Math.PI * 2, true);ctx.arc(75, 75, 25, 0, Math.PI * 2, true);ctx.fill("evenodd");if (canvas.toDataURL) &#123; result.push(&#123; name: "img", value: canvas.toDataURL() &#125;);&#125; webgl_fp通过生成 webgl 图像来区分fp2.js 关于 webgl 实现 audio_fp通过生成的处理后音频来区分fp2.js 关于 audio_context 的 实现 webrtc参考 fingerprintjs2 Canvas,WebGL 以及 AudioContext 指纹原理 真正的感知：Web 客户端追踪技术 人的唯一性识别 everycookie]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuepress踩坑记录]]></title>
    <url>%2Farchives%2Ff8e87dde.html</url>
    <content type="text"><![CDATA[alias 设置需要使用 resolve 12345678910const path = require('path')module.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; '@public': path.resolve(__dirname, './public'), &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[开发小技巧]]></title>
    <url>%2Farchives%2F129533de.html</url>
    <content type="text"><![CDATA[查看端口是否开启 12345678910111213141516# Connection successful:$ timeout 1 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/google.com/80'$ echo $?0# Connection failure prior to the timeout$ timeout 1 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/sfsfdfdff.com/80'bash: sfsfdfdff.com: Name or service not knownbash: /dev/tcp/sfsfdfdff.com/80: Invalid argument$ echo $?1# Connection not established by the timeout$ timeout 1 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/google.com/81'$ echo $?124]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫]]></title>
    <url>%2Farchives%2F7ade1d5c.html</url>
    <content type="text"><![CDATA[泄露 500, 5000, 50000 个人信息关键数据库 ！！！！脱敏]]></content>
  </entry>
  <entry>
    <title><![CDATA[etcd使用]]></title>
    <url>%2Farchives%2F19889329.html</url>
    <content type="text"><![CDATA[介绍 分布式键值对存储仓库（基础使用） 配置共享和服务发现（高级场景）其他场景 使用软件版本 v3.4.3 下载解压12wget https://github.com/etcd-io/etcd/releases/download/v3.4.3/etcd-v3.4.3-linux-amd64.tar.gztar xzvf etcd-v3.4.3-linux-amd64.tar.gz 单机单节点部署1./etcd 参数说明参数支持命令行参数和 yaml 配置文件形式 1234567name // 节点名称 默认为defaultdata-dir // 存储目录 ;initial-advertise-peer -urls; // 初始化通信地址 默认 http://localhost:2380listen-peer-urls; // 通信地址 默认 http://localhost:2380initial-cluster; // 集群节点配置信息 node1=http://192.168.1.10:2380,node2=...listen-client-urls // 客户端地址advertise-client-urls // 对外公告的地址 发现模式123$ curl http://discovery.etcd.io/new?size=3http://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de$ ./etcd -discovery http://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de 扩展节点1234# 旧节点启动$ ./etcdctl member add node --peer-urls http://192.168.10.12# 新节点加入 initial-cluster-state 设置为 existing]]></content>
  </entry>
  <entry>
    <title><![CDATA[踩坑日记]]></title>
    <url>%2Farchives%2F8d485cf3.html</url>
    <content type="text"><![CDATA[data url 和 base 64 的区别网页上使用 data-url， 对文件进行 base64 编码data-url =&gt; data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAbase64 =&gt; R0lGODlhAwADAIAAAP///8zMzCH5BAAAA jsx 中千万不要把 slot 渲染写在 computed 中， 会导致无法响应]]></content>
  </entry>
  <entry>
    <title><![CDATA[js真值，隐形转换，比较]]></title>
    <url>%2Farchives%2F3c778964.html</url>
    <content type="text"><![CDATA[假值的情况 &quot;&quot;是假 数字 0，+0，-0，NaN 是假，其余是真 Symbol 是真 undefined、null 是假 除以上的情况，所有都是真值 真假值使用的情况 if语句 !取反 == 情况分析 NaN 均不== undefined和null相等 一个是boolean，另一个是Number或String， boolean转成数字 一个是对象，对象先valueOf再toString。变换成基本类型比较 关系运算符（&gt;、&lt;、==、!=…） ===、!==：同时对比类型和值，两个都为真才返回真 ==、!=: 若两边均为对象，对比它们的引用是否相同 逻辑非(!): 将其后变量或表达式转为布尔值 对比字符串：从头至尾扫描逐个比较每个字符的unicode码，直到分出大小 其他情况下，两边均转为数值类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试基础篇（二）]]></title>
    <url>%2Farchives%2F234b714a.html</url>
    <content type="text"><![CDATA[js 正在表达式高级用法记忆 非捕获 (?:x) x 参与匹配但是不参与捕获 断言 x(?=y) y 参与匹配， 但是不出现在匹配的子串中 /x(?=y)/.exec(“xy”)[0]=”x”, 和非捕获的差别是 /x(?=y)/.exec(“xy”)[0]=”xy” x(?!y) 表示 x 后面不跟 y (?&lt;=y)x x 前面是 y (?&lt;!y)x x 前面是不是 y 正则默认是贪婪匹配，在数量词后? 表示非贪婪匹配 正则表达式事深度优先原则，先一路到底，再回溯。如果出现了回溯，会使性能大幅度影响，尽量少出现回溯，数量词尽量明确。大型子串匹配时很容易出现回溯。 正则回溯举例12/a\d&#123;1,3&#125;0/.test("a220");// 这种情况会出现一次回溯， \d&#123;1,3&#125; 贪婪匹配, 220 ，然后再匹配0，不复活， 回溯成\d&#123;1,3&#125; 匹配22 正则表达式 | 的理解1/99|55/; // 匹配的应该是 99 或者55 而不是 9(9|5)5 正则 exec 和 g 修饰符理解123456789var reg = /\w/;reg.exec("abc"); // areg.exec("abc"); // areg.exec("abc"); // avar reg = /\w/g; // 必须是变量的方式reg.exec("abc"); // areg.exec("abc"); // breg.exec("abc"); // c match 和 replace 中 g 修饰符match(//g) 返回的是匹配的每个子串组成的数组，不加 g 同 execreplace 同上， 但是使用字符串模式时， $` $’ 需要注意]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端常用布局 - 两列布局]]></title>
    <url>%2Farchives%2F8930074f.html</url>
    <content type="text"><![CDATA[前言本编主要讲常用布局 两列布局，两列布局有两种，一是左边固定右边自适应，另一种是右边固定，左边自适应。只讲我认为最优的方案 左侧固定演示12&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="slide"&gt;slide&lt;/div&gt; 123456789101112.slide &#123; float: left; width: 100px; margin-left: -100%;&#125;.main &#123; float: left; padding-left: 100px; box-sizing: border-box; width: 100%; &#125; 右侧固定演示12&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="slide"&gt;slide&lt;/div&gt; 123456789101112.slide &#123; float: left; width: 100px; margin-left: -100%;&#125;.main &#123; float: left; padding-left: 100px; box-sizing: border-box; width: 100%; &#125; flex这个方案最简单，也最容易理解使用 order + flex 属性即可 table使用table也行， 兼容性高于flex。父：display: table;子：display: table-cell; 绝对定位比较简单容易理解123456789.slide &#123; position: absolute; top: 0; bottom: 0; width: 200px;&#125;.main &#123; margin-left: 200px;&#125; float + margin1234567.slide &#123; float: left; width: 200px;&#125;.main &#123; margin-left: 200px;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常用布局 - 三列布局]]></title>
    <url>%2Farchives%2Fe924f8d1.html</url>
    <content type="text"><![CDATA[前言收集了常用的3列布局方案，左右固定，中间自适应方案，其中圣杯布局和双飞翼需要慢慢琢磨原理， 琢磨不透直接记下来用。 浮动演示1234567891011&lt;div class="content"&gt; &lt;div class="left"&gt; left &lt;/div&gt; &lt;div class="right"&gt; right &lt;/div&gt; &lt;div class="main"&gt; main &lt;/div&gt;&lt;/div&gt; 123456789101112.left &#123; float: left; width: 200px;&#125;.right &#123; float: right; width: 200px;&#125;.main &#123; margin-left: 200px; margin-right: 200px;&#125; BFC演示1234567891011&lt;div class="content"&gt; &lt;div class="left"&gt; left &lt;/div&gt; &lt;div class="right"&gt; right &lt;/div&gt; &lt;div class="main"&gt; main &lt;/div&gt;&lt;/div&gt; 1234567891011.left &#123; float: left; width: 200px;&#125;.right &#123; float: right; width: 200px;&#125;.main &#123; overflow: auto;&#125; 定位演示1234567891011&lt;div class="content"&gt; &lt;div class="main"&gt; main &lt;/div&gt; &lt;div class="left"&gt; left &lt;/div&gt; &lt;div class="right"&gt; right &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.content &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; width: 200px;&#125;.right &#123; position: absolute; top: 0; right: 0; width: 200px;&#125;.main &#123; margin-left: 200px; margin-right: 200px;&#125; 双飞翼布局演示12345&lt;div class="content"&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; 1234567891011121314151617181920.left &#123; float: left; width: 200px; margin-left: -100%; &#125;.right &#123; float: right; width: 220px; margin-left: -230px&#125;.content &#123; float: left; width: 100%;&#125;.main &#123; clear: both; margin-left: 110px; margin-right: 220px;&#125; 圣杯布局演示12345&lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.container &#123; margin-left: 200px; margin-right: 200px;&#125;.left &#123; float: left; width: 200px; position: relative; margin-left: -100%; left: -200px;&#125;.right &#123; float: left; width: 200px; position: relative; right: -200px; margin-left: -200px&#125;.main &#123; float: left; width: 100%;&#125; flex演示12345&lt;div class="container"&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 123456789101112131415.container &#123; display: flex;&#125;.left &#123; order: 0; flex: 0 0 200px;&#125;.right &#123; order: 2; flex: 0 0 200px;&#125;.main &#123; order: 1; flex: 1 0 auto;&#125; table演示12345&lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 123456789101112131415.container &#123; display: table; width: 100%;&#125;.left &#123; display: table-cell; width: 200px;&#125;.right &#123; display: table-cell; width: 200px;&#125;.main &#123; display: table-cell;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试基础篇（一）]]></title>
    <url>%2Farchives%2F135d9d92.html</url>
    <content type="text"><![CDATA[前端 SEO 注意情况 title &gt; description &gt; keywords 搜索引擎从上到下，重要内容放前面 内容不用 js 动态输出 搜索引擎会跳过 frame 非装饰图片使用 alt post 和 put 区别put 是幂等的，多次操作不会新增数据条数，可以理解为修改某条数据。post 是非幂等的，多次操作会增加多条数据，理解为新增接口。建议管理系统不做区分， 都用 post。 优化的一些点 静态资源分布到多域名下 控制资源大小，小文件合并。 css 和 js 单独放置为文件 压缩图片，减少位深。 iframe 问题 阻塞主页面 onload 事件，通过 动态添加 src 或更优的 createElmenet 的形式来添加 iframe 和主页面同域共享连接池，会影响主页面资源加载 采用多个域名存储资源的原因 突破浏览器并发限制 节约 cookie 带宽 节约主域名连接数 电商图片处理 小图标 雪碧图 加载缩略图 懒加载，滚动位置再加载 BFC overflow 不为 visible; position: absolute || fixed; display: inline-block || table-cell || flex float 不为 none html 元素 清除浮动12345678910.clearfloat &#123; zoom: 1;&#125;.clearfloat:after &#123; display: block; clear: both; content: ''; visibility: hidden; height: 0;&#125; css 优先级!important &gt; 内联 &gt; id &gt; class &gt; tag 消除 display: inline-block 间隙 父元素 font-size: 0; 父元素 word-spacing: 0; // 单词间隙 删除空格 letter-spacing: 0 // 字母间隙 动画间隔时间保证 30fps 1000/30 = 33.333ms bind 注意bind 是强绑定的， 绑定后不能更换 this 浏览器缓存 强制缓存 =&gt; 根据 Expired(http1.0)(通过服务端返回有效时间) ， 或者 Cache-control 来控制， 一般使用 max-age： 1h。 强制缓存是直接从浏览器获得请求，一个是 from memory cache(页面刷新的缓存)，一个是 from disk cache（页面关闭再打开）js 和图片等文件 当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache 协商缓存 =&gt; 强制缓存失效时， 就会启用协商缓存 last-modified(第一次响应) =&gt; if-modified-since（浏览器再次请求） =&gt; 服务端和本地文件进行对比 Etag 和 if-none-match返回 etat =&gt; if-none-match =&gt; 对比 etag viewport 的值有哪些1234&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0 user-scaleable=yes"/&gt; 如何判断一个单链表是否有环使用快慢指针, 快指针追上慢指针表示有环，快指针到末尾还未追上， 表示没环。 如何判断环的长度和环的起点设置一个指针从 head 开始， 一个从相遇点开始，知道两个指针重合， 就是起点环的长度，可以通过快指针和慢指针下次相遇的，操作步数 两个无环链表，判断是否相交和相交节点是多少将任意一个链表守卫相接，然后从另一个链表开始， 如果是有环的，证明必然有环 xss 和 csrfxss 跨站脚本攻击，网站内容被插入了 js 代码。包括在 url 里面被植入 例如 javascript: alert()这种代码。 转义csrf 跨站请求伪造， 直接在 B 网站上发送请求 A 网站的请求。 禁止跨站访问，根据 referer 来判断。 点击劫持 嵌套 iframe, 服务端配置禁止被引用。 深拷贝 递归拷贝引用类型 循环引用的情况，每次检测是否某个对象的字段是本身对象或祖先对象 平级引用，使用 weakMap 检测有个属性是否在 weakMap 存在]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css显示显示更多功能]]></title>
    <url>%2Farchives%2Fca5e0d7a.html</url>
    <content type="text"><![CDATA[前言需要实现文本显示不超过两行，超过的两行的部分，用显示更多按钮，点击后显示展开全部文本。用html+css实现单行效果两行效果多行效果展开效果 实现html 部分12345678910111213141516171819202122232425262728&lt;div class="pay-info"&gt; &lt;input id="onekey-payInfoCheckbox" type="checkbox" style="display: none;" /&gt; &lt;p class="pay-info-text"&gt; &lt;span class="pay-info-text-detail" &gt;###***！！气asd asd 阿斯达阿达啊1 3阿达阿斯达暗杀是大法官地方甘道夫古典风格的公司的暗杀撒旦防守对方是否是是防守对方斯蒂芬撒旦放。&lt;/span &gt; &lt;span class="pay-info-text-detail1" &gt;###***！！气asd asd 阿斯达阿达啊1 3阿达阿斯达暗杀是大法官地方甘道夫古典风格的公司的暗杀撒旦防守对方是否是是防守对方斯蒂芬撒旦放。&lt;/span &gt; &lt;span class="pay-info-shade"&gt;&lt;/span&gt; &lt;/p&gt; &lt;label for="onekey-payInfoCheckbox" class="pay-info-text-con pay-info-text-open" &gt;&lt;span class="arrow-download"&gt;&lt;/span &gt;&lt;/label&gt; &lt;label for="onekey-payInfoCheckbox" class="pay-info-text-con pay-info-text-close" &gt;&lt;span class="arrow-up"&gt;&lt;/span &gt;&lt;/label&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677.pay-info &#123; position: relative; margin-top: 12px;&#125;.pay-info-text &#123; /* width: 100%; */ position: relative; font-size: 14px; max-height: 40px; /* min-height: 40px; */ overflow: hidden; transition: max-height 0.25s; color: #999999;&#125;.pay-info-text-detail &#123; font-size: 14px; line-height: 1.4; color: #999999;&#125;.pay-info-text-detail1 &#123; position: absolute; top: 0; left: 0; right: 0; z-index: 101; height: 20px; font-size: 14px; line-height: 1.4; color: #999999; overflow: hidden; background: white;&#125;.pay-info-shade &#123; position: absolute; right: 0; width: 16px; height: 16px; padding: 4px; background: #fff; z-index: 99;&#125;:checked ~ .pay-info-text .pay-info-shade &#123; display: none;&#125;:checked ~ .pay-info-text &#123; max-height: 250px; /* ä¸€ä¸ªè¶³å¤Ÿå¤§çš„æœ€å¤§é«˜åº¦å€¼ */&#125;.pay-info-text-con &#123; position: absolute; right: 0; /* left: 0; */ width: 16px; height: 16px; cursor: pointer; bottom: 0; text-align: right; padding: 4px; color: #000;&#125;.pay-info-text-open &#123; background: rgba(255, 255, 255, 0.5);&#125;.pay-info-text-close &#123; display: none;&#125;:checked ~ .pay-info-text-open &#123; display: none;&#125;:checked ~ .pay-info-text-close &#123; display: inline-block; bottom: -24px;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[记一次正则表达式的坑]]></title>
    <url>%2Farchives%2F636ae7c5.html</url>
    <content type="text"><![CDATA[开始问题如下123let regx = new RegExp("^[0-9]+(\.[0-9]&#123;0,2&#125;)?$") regx.test('0') // ?? =&gt; trueregx.test('0x') // ?? =&gt; true 这个结果就很奇怪了。 还以为是执行环境出错了。去查阅了一波MDN文档。有这么一句话使用 new RegExp(&quot;pattern&quot;) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。 1let newRegx = new RegExp("^\\b+(\.\\b&#123;0,2&#125;)?$") //解决]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>正则表达式</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript原型和constructor理解]]></title>
    <url>%2Farchives%2Fd0b04a7b.html</url>
    <content type="text"><![CDATA[前言前几日被同事问到js继承方面的东西，想来想去就知道是通过prototype来实现，具体实现也搞不清了。赶紧回去翻红宝书复习下。对原型这块的理解又更深了一步。 new 的理解：伪代码从下方可以看到 js继承是原型继承， 不是类继承。1234567 new Person("John") = &#123; var obj = &#123;&#125;; obj.__proto__ = Person.prototype; // 此时便建立了obj对象的原型链： // obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null var result = Person.call(obj,"John"); // 相当于obj.Person("John") return typeof result === 'object' ? result : obj; // 如果无返回值或者返回一个非对象值，则将obj返回作为新对象&#125; function 的constructor是什么默认情况下是指的是定义本身。 是对象上一个指向构造函数的引用。用来辅助 instanceof 等关键字的实现。下方例子看一看到，没什么用。F.prototype.constructor === f.__proto__.constructor === F123456789101112 function People(name) &#123; this.name = name &#125; People.prototype.constructor === People // true console.log(new People('yangmanman')) // yangmanman // 重新指向 People.prototype.constructor = function(name) &#123; this.name = "123" &#125; console.log(new People('yangmanman').name) // yangmanman 修改没用// ---------------------- 分割线 ----------------------------- 如何理解原型继承使用的是指向和call这种东西。 参考资料 JavaScript深入之继承的多种方式和优缺点 JavaScript 原型精髓 #一篇就够系列 小邵教你玩转JS面向对象]]></content>
      <categories>
        <category>javascript 基础</category>
      </categories>
      <tags>
        <tag>prototype</tag>
        <tag>原型</tag>
        <tag>constructor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css世界读书笔记（1）]]></title>
    <url>%2Farchives%2Fb78f1e6b.html</url>
    <content type="text"><![CDATA[前言上次去整了本张鑫旭大佬编的《CSS世界》，一直没有时间研读，仅记录一些之前未接触的内容。 块级元素粗略理解为 display 值为 table，block，list-item等值元素。具有独占一行水平流的功能，可以使用clear 属性。 list-item 出现项目符号理解元素可以理解为多个盒子构成，外在盒子，容器盒子（内在盒子），标记盒子（这个是list-item独有的盒子）。可以按照每种盒子具有自身的display来理解行为。block =&gt; block-flow inline-block =&gt; inline-block 理解width：auto 充分利用可用空间：表现在div，p等元素上，会尽可能扩伸。 收缩与包裹：表现在table，inline-block上面，收缩到合适。有种根据内容来设置min-width的感觉。 收缩到最小：table-layout：auto 会出现 超出限制：长连续的英文和数字会出现。还有 white-space:nowrap设置后的内联元素 元素的宽度是由什么决定的？外部尺寸指的是元素自身就能决定宽度 正常流，div，p等元素，总是尽可能扩伸。按照流来理解 position为absolute，fixed等情况下对边属性都存在时。可以理解为，自身把自身拉开 显式设置宽度 内部尺寸指的是元素的尺寸由内部元素决定 包裹性的元素：下方inline-block宽度为123宽度 12345&lt;div style="display: inline-block;"&gt; &lt;div&gt; 123 &lt;/div&gt;&lt;/div&gt; 首选最小宽度：当父元素宽度设置为0时，子元素表现出最小宽度 伪元素::after ::before 的定义命中元素的最后|最前一个子元素 宽度分离当需要限定宽度时，把宽度定义单独提取出一个元素，box-sizing: border-content功能相同 宽度100% 和 高度100%width：100% auto = 无效 height：100% auto = 无效。但是宽度这种未定义行为各个厂商把auto视为包含块的最小宽度来处理的。要明白其中的原因要先了解浏览器渲染的基本原理。首先，先下载文档内容，加载头部的样式资源（如果有的话），然后按照从上而下、自外而内的顺序渲染 DOM 内容。套用本例就是，先渲染父元素，后渲染子元素，是有先后顺序的。因此，当渲染到父元素的时候，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素宽度已经固定，此时的 width:100%就是已经固定好的父元素的宽度。宽度不够怎么办？溢出就好了，overflow 属性就为此而生的 如何让高度支持100%position: absolute; 不过注意的是绝对定位的宽高百分比计算是相对于 padding box 的 超越! important和超越最大权重优先级 min- &gt; max- &gt; ! important 任意高度的展开动画效果通过过度 max-* 来实现效果12345678.element &#123; max-height: 0; overflow: hidden; transition: max-height .25s;&#125;.element.active &#123; max-height: 666px; /* 一个足够大的最大高度值 */&#125; 幽灵空白节点在 HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; 高度为span空白节点的高度 内联元素的定义可以看做外在盒子是 inline 的元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css元素尺寸</tag>
        <tag>css世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openssl学习笔记]]></title>
    <url>%2Farchives%2Fc76c6f1c.html</url>
    <content type="text"><![CDATA[概念公钥端：C 私钥端：S — RS：非对称加密 AES：对称加密公钥加密，私钥解密。 私钥数字签名私钥端：将内容（A）hash内容（A-&gt;B），私钥加密内容（B-&gt;C），将内容（A）和加密后的内容(C) 发送给公钥端公钥端：使用公钥解开加密后的内容C，获得hash内容（C-&gt;B），将内容（A）hash后检查，如果相同，表示未被修改，否则表示修改。 合格公钥构成找一个信任的第三方介入，首先第三方将自己的公钥给C端，然后第三方将S端的公钥合一些信息用自己的私钥加密发送给C端，C使用私钥解密后就能获取S端的公钥，这样就可以实现保证C端拿到的的确是S端的公钥， 防止C端拿到错误的公钥后C端被冒名顶替。 https 构成浏览器发送请求公钥请求，服务器将签名（CA中心用私钥加密的内容）发送给浏览器， 浏览器使用CA拿到的公钥解开信息，验证服务器真伪，验证通过后，浏览器端和服务器协商加密等级，确定一个 公开密钥。至此安全连接建立，应用层通信时，内容会通过这个公开密钥进行对称加密，因为对称加密的方式远远快于非对称加密。 openssl 生成公私钥 生成RSA私钥：openssl genrsa -out private.key 2048 生成RSA公钥：openssl rsa -in private.key -pubout -out rsa_public.key, 通过私钥生成公钥 使用aes方式：openssl genrsa -aes256 -passout pass:yangmanman -out rsa_aes_private.key 2048，对生成的私钥进行 aes 加密，这种方式生成公钥时需要输入密码 使用aes方式生成公钥：openssl rsa -in ./rsa_aes.private.key -passin pass:yangmanman -pubout -out rsa_aes_public.key，生成公钥需要密码 密钥操作加密私钥转换为未加密状态open rsa -in rsa_aes_private.key -passin pass:yangmanman -out rsa_private.key私钥加密open rsa -in rsa_private.key -aes256 -passout pass:yangmanman -out rsa_aes_private.key默认私钥生成 PKCS#1, 转换为PKCS#8 pkcs8 默认需要加密openssl pkcs -topk8 -in rsa_private.key -passout pass:yangmanman -out pkcs8_private.key 证书操作服务器自建证书操作过程生成自签名的CA的证书，生成服务器证书请求，使用CA的证书，私钥对服务器证书请求进行签发，输出服务器证书 自签名的CA证书，并生成密钥1openssl req -newkey rsa:2048 -nodes -keyout ca_rsa_private.key -x509 -days 365 -out ca.crt -subj "/C=CN/ST=GD/L=SZ/O=vihoo/OU=dev/CN=xunserver.cn/emailAddress=xunserver.cn" 使用已有密钥生成 opensll req -new -x509 -days 365 -key rsa_private.key -out ca.crt 生成服务器私钥 openssl rsa -ase256 -passout pass:yangmanman -out server_private.key 2048 生成服务器csr签名 openssl req -new -key server_private.key -out servre.csr [-subj=&quot;/C=CN/ST=GD/L=SZ/O=vihoo/OU=dev/CN=xunserver.cn/emailAddress=xunserver.cn&quot;] 使用ca证书，私钥对服务器csr签名，签发x509证书openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca_private.key -passin:yangmanman -CAcreateserial -out server.crt 至此，服务器证书完全获取到，crt是证书，csr证书签名请求（可以认为是服务器的公钥） 证书操作查看证书细节openssl x509 -in cert.crt -noout -text转换证书编码格式openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem 合成 pkcs#12 证书(含私钥) // 将 pem 证书和私钥转 pkcs#12 证书 openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:111111 -password pass:111111 -out server.p12 //其中-export指导出pkcs#12 证书，-inkey 指定了私钥文件，-passin 为私钥(文件)密码(nodes为无加密)，-password 指定 p12文件的密码(导入导出) // 将 pem 证书和私钥/CA 证书 合成pkcs#12 证书 openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:111111 \ -chain -CAfile ca.crt -password pass:111111 -out server-all.p12 // 其中-chain指示同时添加证书链，-CAfile 指定了CA证书，导出的p12文件将包含多个证书。(其他选项：-name可用于指定server证书别名；-caname用于指定ca证书别名) // pcks#12 提取PEM文件(含私钥) openssl pkcs12 -in server.p12 -password pass:111111 -passout pass:111111 -out out/server.pem 仅提取私钥 openssl pkcs12 -in server.p12 -password pass:111111 -passout pass:111111 -nocerts -out out/key.pem 仅提取证书 openssl pkcs12 -in server.p12 -password pass:111111 -nokeys -out out/key.pem 仅提取ca证书 openssl pkcs12 -in server-all.p12 -password pass:111111 -nokeys -cacerts -out out/cacert.pem 仅提取server证书 openssl pkcs12 -in server-all.p12 -password pass:111111 -nokeys -clcerts -out out/cert.pem openssl 命名1. 命名格式 1) asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) 2) ca: ca用于CA的管理 openssl ca [options]: 2.1) -selfsign 使用对证书请求进行签名的密钥对来签发证书。即&quot;自签名&quot;，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个密钥对来进行&quot;自签名&quot; 2.2) -in file 需要进行处理的PEM格式的证书 2.3) -out file 处理结束后输出的证书文件 2.4) -cert file 用于签发的根CA证书 2.5) -days arg 指定签发的证书的有效时间 2.6) -keyfile arg CA的私钥证书文件 2.7) -keyform arg CA的根私钥证书文件格式: 2.7.1) PEM 2.7.2) ENGINE 2.8) -key arg CA的根私钥证书文件的解密密码(如果加密了的话) 2.9) -config file 配置文件 example1: 利用CA证书签署请求证书 openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key 1) req: X.509证书签发请求(CSR)管理 openssl req [options] &lt;infile &gt;outfile 3.1) -inform arg 输入文件格式 3.1.1) DER 3.1.2) PEM 3.2) -outform arg 输出文件格式 3.2.1) DER 3.2.2) PEM 3.3) -in arg 待处理文件 3.4) -out arg 待输出文件 3.5) -passin 用于签名待生成的请求证书的私钥文件的解密密码 3.6) -key file 用于签名待生成的请求证书的私钥文件 3.7) -keyform arg 3.7.1) DER 3.7.2) NET 3.7.3) PEM 3.8) -new 新的请求 3.9) -x509 输出一个X509格式的证书 3.10) -days X509证书的有效时间 3.11) -newkey rsa:bits 生成一个bits长度的RSA私钥文件，用于签发 3.12) -[digest] HASH算法 3.12.1) md5 3.12.2) sha1 3.12.3) md2 3.12.4) mdc2 3.12.5) md4 3.13) -config file 指定openssl配置文件 3.14) -text: text显示格式 example1: 利用CA的RSA密钥创建一个自签署的CA证书(X.509结构) openssl req -new -x509 -days 3650 -key server.key -out ca.crt example2: 用server.key生成证书签署请求CSR(这个CSR用于之外发送待CA中心等待签发) openssl req -new -key server.key -out server.csr example3: 查看CSR的细节 openssl req -noout -text -in server.csr 1) genrsa: 生成RSA参数 openssl genrsa [args] [numbits] [args] 4.1) 对生成的私钥文件是否要使用加密算法进行对称加密: 4.1.1) -des: CBC模式的DES加密 4.1.2) -des3: CBC模式的DES加密 4.1.3) -aes128: CBC模式的AES128加密 4.1.4) -aes192: CBC模式的AES192加密 4.1.5) -aes256: CBC模式的AES256加密 4.2) -passout arg: arg为对称加密(des、des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节) 4.3) -out file: 输出证书私钥文件 [numbits]: 密钥长度 example: 生成一个1024位的RSA私钥，并用DES加密(密码为1111)，保存为server.key文件 openssl genrsa -out server.key -passout pass:1111 -des3 1024 1) rsa: RSA数据管理 openssl rsa [options] &lt;infile &gt;outfile 5.1) -inform arg 输入密钥文件格式: 5.1.1) DER(ASN1) 5.1.2) NET 5.1.3) PEM(base64编码格式) 5.2) -outform arg 输出密钥文件格式 5.2.1) DER 5.2.2) NET 5.2.3) PEM 5.3) -in arg 待处理密钥文件 5.4) -passin arg 输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话) 5.5) -out arg 待输出密钥文件 5.6) -passout arg 如果希望输出的密钥文件继续使用加密算法的话则指定密码 5.7) -des: CBC模式的DES加密 5.8) -des3: CBC模式的DES加密 5.9) -aes128: CBC模式的AES128加密 5.10) -aes192: CBC模式的AES192加密 5.11) -aes256: CBC模式的AES256加密 5.12) -text: 以text形式打印密钥key数据 5.13) -noout: 不打印密钥key数据 5.14) -pubin: 检查待处理文件是否为公钥文件 5.15) -pubout: 输出公钥文件 example1: 对私钥文件进行解密 openssl rsa -in server.key -passin pass:111 -out server_nopass.key example:2: 利用私钥文件生成对应的公钥文件 openssl rsa -in server.key -passin pass:111 -pubout -out server_public.key 1) x509: 本指令是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作 openssl x509 [args] 6.1) -inform arg 待处理X509证书文件格式 6.1.1) DER 6.1.2) NET 6.1.3) PEM 6.2) -outform arg 待输出X509证书文件格式 6.2.1) DER 6.2.2) NET 6.2.3) PEM 6.3) -in arg 待处理X509证书文件 6.4) -out arg 待输出X509证书文件 6.5) -req 表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发 6.6) -days arg 表明将要签发的证书的有效时间 6.7) -CA arg 指定用于签发请求证书的根CA证书 6.8) -CAform arg 根CA证书格式(默认是PEM) 6.9) -CAkey arg 指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有 6.10) -CAkeyform arg 指定根CA私钥证书文件格式(默认为PEM格式) 6.11) -CAserial arg 指定序列号文件(serial number file) 6.12) -CAcreateserial 如果序列号文件(serial number file)没有指定，则自动创建它 example1: 转换DER证书为PEM格式 openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem example2: 使用根CA证书对&quot;请求签发证书&quot;进行签发，生成x509格式证书 openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt example3: 打印出证书的内容 openssl x509 -in server.crt -noout -text 1) crl: crl是用于管理CRL列表 openssl crl [args] 7.1) -inform arg 输入文件的格式 7.1.1) DER(DER编码的CRL对象) 7.1.2) PEM(默认的格式)(base64编码的CRL对象) 7.2) -outform arg 指定文件的输出格式 7.2.1) DER(DER编码的CRL对象) 7.2.2) PEM(默认的格式)(base64编码的CRL对象) 7.3) -text: 以文本格式来打印CRL信息值。 7.4) -in filename 指定的输入文件名。默认为标准输入。 7.5) -out filename 指定的输出文件名。默认为标准输出。 7.6) -hash 输出颁发者信息值的哈希值。这一项可用于在文件中根据颁发者信息值的哈希值来查询CRL对象。 7.7) -fingerprint 打印CRL对象的标识。 7.8) -issuer 输出颁发者的信息值。 7.9) -lastupdate 输出上一次更新的时间。 7.10) -nextupdate 打印出下一次更新的时间。 7.11) -CAfile file 指定CA文件，用来验证该CRL对象是否合法。 7.12) -verify 是否验证证书。 example1: 输出CRL文件，包括(颁发者信息HASH值、上一次更新的时间、下一次更新的时间) openssl crl -in crl.crl -text -issuer -hash -lastupdate –nextupdate example2: 将PEM格式的CRL文件转换为DER格式 openssl crl -in crl.pem -outform DER -out crl.der 1) crl2pkcs7: 用于CRL和PKCS#7之间的转换 openssl crl2pkcs7 [options] &lt;infile &gt;outfile 转换pem到spc openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc https://www.openssl.org/docs/apps/crl2pkcs7.html 1) pkcs12: PKCS#12数据的管理 pkcs12文件工具，能生成和分析pkcs12文件。PKCS#12文件可以被用于多个项目，例如包含Netscape、 MSIE 和 MS Outlook openssl pkcs12 [options] http://blog.csdn.net/as3luyuan123/article/details/16105475 https://www.openssl.org/docs/apps/pkcs12.html 1) pkcs7: PCKS#7数据的管理 用于处理DER或者PEM格式的pkcs#7文件 openssl pkcs7 [options] &lt;infile &gt;outfile http://blog.csdn.net/as3luyuan123/article/details/16105407 https://www.openssl.org/docs/apps/pkcs7.html 2. openssl list-message-digest-commands(消息摘要命令) 1) dgst: dgst用于计算消息摘要 openssl dgst [args] 1.1) -hex 以16进制形式输出摘要 1.2) -binary 以二进制形式输出摘要 1.3) -sign file 以私钥文件对生成的摘要进行签名 1.4) -verify file 使用公钥文件对私钥签名过的摘要文件进行验证 1.5) -prverify file 以私钥文件对公钥签名过的摘要文件进行验证 verify a signature using private key in file 1.6) 加密处理 1.6.1) -md5: MD5 1.6.2) -md4: MD4 1.6.3) -sha1: SHA1 1.6.4) -ripemd160 example1: 用SHA1算法计算文件file.txt的哈西值，输出到stdout openssl dgst -sha1 file.txt example2: 用dss1算法验证file.txt的数字签名dsasign.bin，验证的private key为DSA算法产生的文件dsakey.pem openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt 1) sha1: 用于进行RSA处理 openssl sha1 [args] 2.1) -sign file 用于RSA算法的私钥文件 2.2) -out file 输出文件爱你 2.3) -hex 以16进制形式输出 2.4) -binary 以二进制形式输出 example1: 用SHA1算法计算文件file.txt的HASH值,输出到文件digest.txt openssl sha1 -out digest.txt file.txt example2: 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的private key为RSA算法产生的文件rsaprivate.pem openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt 3. openssl list-cipher-commands (Cipher命令的列表) 1) aes-128-cbc 2) aes-128-ecb 3) aes-192-cbc 4) aes-192-ecb 5) aes-256-cbc 6) aes-256-ecb 7) base64 8) bf 9) bf-cbc 10) bf-cfb 11) bf-ecb 12) bf-ofb 13) cast 14) cast-cbc 15) cast5-cbc 16) cast5-cfb 17) cast5-ecb 18) cast5-ofb 19) des 20) des-cbc 21) des-cfb 22) des-ecb 23) des-ede 24) des-ede-cbc 25) des-ede-cfb 26) des-ede-ofb 27) des-ede3 28) des-ede3-cbc 29) des-ede3-cfb 30) des-ede3-ofb 31) des-ofb 32) des3 33) desx 34) rc2 35) rc2-40-cbc 36) rc2-64-cbc 37) rc2-cbc 38) rc2-cfb 39) rc2-ecb 40) rc2-ofb 41) rc4 42) rc4-40]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>linux</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp内网穿透]]></title>
    <url>%2Farchives%2Fc067e7e3.html</url>
    <content type="text"><![CDATA[下载安装github搜索frp star最多的项目，到release中根据系统下载响应压缩包 传送门，压缩包中包含frps（公网服务端），frpc（需要被穿透的客户端）.ini 结尾是配置文件，full.ini 是全部的配置文件 启动服务端和客户端./fprs -c ./frps.ini // 到公网服务器启动 ./frpc -c ./frpc.ini // 需要被穿透的机器上执行 服务器配置官网文档支持中文，更多细节查看官方文档 [common] # 通信端口 bind_port = 7000 # 外网访问端口 vhost_http_port=80 vhost_https_port=443 # 二级域名 subdomain_host=frp.xunserver.cn # 连接密码 token=adadadadad # 管理服务器 密码用户端口 dashboard_port=7500 dashboard_user=admin dashboard_pwd=adadadadad # 连接池 # max_pool_count=5 客户端管理[common] # 服务器地址 server_addr = xx.xx.xx.xx # 服务器配置中 bind_port 字段 server_port = 7000 # 本地管理 admin_addr = 127.0.0.1 admin_port = 7400 admin_user = admin admin_passwd = admin # 连接密码 token=xxxxx # 连接池 pool_count = 5 # 日志 log_file = ./frpc.log # 客户端名字，必须和其他客户端名字不同 [migu-http] type = http # 类型 local_port = 80 # 映射到本地端口 subdomain= migu # 子域名 # 同上 [migu-https] type = https local_port = 443 subdomain= migu https 配置由于frp 是全部转发，所以https的配置在应用上，可以在nginx上配置。具体参考 nginx-https配置 ssh 连接在客户端配置， 执行==ssh -oPort=6000 username@x.x.x.x== [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok内网穿透]]></title>
    <url>%2Farchives%2F64ba60b1.html</url>
    <content type="text"><![CDATA[下载安装github 搜索 ngrok star 最多的项目，clone 到本地，解压。 证书配置证书配置，没有证书的使用自签名证书。有证书的跳过这一步 自签名证书使用openssl 生成证书，openssl安装 查看opnessl 学习笔记 12345678910// 生成自签名证书私钥 ca.keyopenssl genrsa -out ca.key 2048// 根据 ca.key 生成自签名的CA证书openssl req -x509 -new -nodes -key ca.key -subj "/CN=domain.name" -days 5000 -out root.crt // 生成服务器私钥openssl genrsa -out server.key 2048// 生成服务器 csropenssl req -new -key server.key -subj "/CN=domain.name" -out server.csr// ca 颁发证书openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 5000 替换官方证书将官方证书替换掉, 官方的证书放在 assets/中, 具体替换下面3个 替换ca ———- assets/client/tls 替换服务器公钥 ———– assets/server/tls 替换服务器证书 ———— assets/server/tls 重新编译服务端和客户端编译需要安装go语言环境yum insatll golang，设置不同系统环境变量编译 1GOOS=[windows | linux] GOARCH=[386 | amd64] make [release-server | release-client] 启动服务器端123/usr/local/ngrok/bin/ngrokd [-tlsKey=/usr/local/ngrok/assets/server/tls/snakeoil.key] [-tlsCrt=/usr/local/ngrok/assets/server/tls/snakeoil.crt] -domain=xxx.xxxx.xx -httpAddr=:81 -httpsAddr=:4443 -tunnelAddr=:4445// -tlsKey 和 -tlsCrt可选，表示使用自己的证书和 key，-damain 绑定的域名； http 和https 监听的端口； -tunnelAddr 客户端通信端口 启动客户端根据平台下载对应的 ngrok程序新建配置文件，添加如下内容 12server_addr: "xxx.xxxx.xxx:port" // port 为服务器 -tunnelAddr 端口值 trust_host_root_certs: false // 如果是自签名证书，此项为false 新建log文件，前期调试用 log.log启动客户端,具体配置可以通过 ngrok -h 查看12ngrok -config config.cfg -log log.log -subdomain subdomainname port// ngrok -config config.cfg -log log.log -subdomain ngrok 80]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客（下）]]></title>
    <url>%2Farchives%2Fce3dc320.html</url>
    <content type="text"><![CDATA[前言本文主要记录在安装hexo主题next中遇到的一些坑 区分两个配置文件hexo 根目录下有个_config.yml，这个叫站点配置文件，目录/themes/xx/_config.yml这个叫主题配置文件，站点配置文件只有一份，而主题配置文件按目录可见是多份。配置时候注意看配置在哪个文件中配置。 接入评论系统折腾了好几种方案，本以为gitment最为轻松，不过也是需要自己的服务器，喜欢折腾的可以参考解决gitment错误。我选用的是畅言评论，这个需要网站备案。还好网站是备案过的。在主题配置中找到 chanyan，修改如下：1234changyan: enable: true appid: xxx # 在畅言中新建应用后可以查询到id和key appkey: xxxxx 更新 valine 评论系统偶然发现一个匿名评论的好东西valine，这个可以匿名评论，不得说不说leancloud大法好。hexo中已经集成valine组件，但是主题配置中_config.yml 配置项有问题，修改如下： 12345678910valine: enable: true appid: xxxxx # 这个字段，官方默认写的是app_id 需要改成 appid appkey: xxxxx # app_key 改成 appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 保存系统可以新建一个私有仓库来保存hexo配置和相关内容，这样可以在多台机器上编写博客。 自定义域名 + 强制https 首先需要一个域名。国内域名大多需要备案，可以到国外购买域名，需要折腾的也可以在国内购买。 将需要定义的域名指向xxx.github.io(xxx为github用户名)。添加CNAME记录可以完成。 新建文件/source/CNAME，写入域名。重新部署。 到github仓库中设置Enforce HTTPS选项。 如果设置成功后页面无效果，清除缓存后重试即可]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>教程</tag>
        <tag>githubpage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客（上）]]></title>
    <url>%2Farchives%2F7681a445.html</url>
    <content type="text"><![CDATA[前言本文章属于入门级别的，图文较多，大佬勿喷。为了时效性，基本工具安装都是指向其他教程。善于记录才能提升。 要求 PC github 帐号 git 安装nodejs，githexo是基于nodejs的框架，先安装nodejs 安装教程博客需要上传到github，需要安装git 安装教程，需要注意的是安装完需要配置git 12git config --global user.name "runoob" git config --global user.email test@runoob.com github准备工作 上传SSH凭证打开 Git GUI(可在开始菜单搜索找到) , 点击菜单中 Help =&gt; show ssh key如果没有key，点击 generate Key 生成公钥。复制下方生成的公钥打开页面https://github.com/settings/keys，点击New SSH Key 填写刚才生成的公钥 新建仓库新建一个仓库来保存博客页面，到https://github.com/new,按照下图提示新建 至此准备工作完成 安装初始化hexo12345npm i -g hexo # 全局安装hexo# 下列步骤均在项目根目录下执行hexo init # 初始化hexo npm i # 重新安装依赖npm i -S hexo-deployer-git # 安装git上传工具 配置git上传工具修改根目录下_config.yml文件，在末尾添加下面内容1234deploy: type: git repo: git@github.com:xxxx/xxxx.github.io.git # xxxx修改为github的用户名 branch: master 写博客上传博客使用markdown来编写的。不习惯的可以去下载可视化markdown编辑器 首先启动本地预览服务器hexo s，在localhost:4000可以看到预览效果 新建文章 hexo new xxx，xxx是博客的title，执行后在/source/_posts/下面可以看到刚生成的文章模版 编写好博客保存后，执行hexo d -g可将博客推送到github，在http://username.github.io可以看到博客已经推送到线上 后续后续记录hexo安装next主题]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>教程</tag>
        <tag>githubpage</tag>
      </tags>
  </entry>
</search>
